{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ApexSim Documentation","text":"<p>ApexSim is a modular lap-time simulation library for race cars with interchangeable vehicle models.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Guides: onboarding, solver derivation, assumptions, development notes.</li> <li>Examples: step-by-step script walkthroughs (synthetic tracks first, then Spa).</li> <li>API Reference: auto-generated reference from Python docstrings.</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>How to Use</li> <li>Compute Backends</li> <li>API Overview</li> <li>Examples Overview</li> <li>Synthetic Track Walkthrough</li> <li>Spa Walkthrough</li> <li>Transient Solver Walkthrough</li> <li>Solver Derivation</li> <li>Single-Track Model</li> <li>Point-Mass Model</li> <li>Assumptions</li> </ul>"},{"location":"API/","title":"API Overview","text":"<p>This page maps the public API to the engineering workflow.</p> <p>If you are new to the package, start with How to Use.</p>"},{"location":"API/#1-track-inputs","title":"1. Track inputs","text":""},{"location":"API/#load-measuredreal-track-data","title":"Load measured/real track data","text":"<ul> <li><code>apexsim.track.load_track_csv(path) -&gt; TrackData</code></li> </ul> <p>Required CSV columns:</p> <ul> <li><code>x</code></li> <li><code>y</code></li> <li><code>elevation</code></li> <li><code>banking</code></li> </ul>"},{"location":"API/#generate-synthetic-validation-tracks","title":"Generate synthetic validation tracks","text":"<ul> <li><code>apexsim.track.build_straight_track(...) -&gt; TrackData</code></li> <li><code>apexsim.track.build_circular_track(...) -&gt; TrackData</code></li> <li><code>apexsim.track.build_figure_eight_track(...) -&gt; TrackData</code></li> </ul>"},{"location":"API/#2-vehicle-and-tire-models","title":"2. Vehicle and tire models","text":""},{"location":"API/#shared-physical-vehicle-parameters","title":"Shared physical vehicle parameters","text":"<ul> <li><code>apexsim.vehicle.VehicleParameters</code></li> </ul>"},{"location":"API/#tire-parameters","title":"Tire parameters","text":"<ul> <li><code>apexsim.tire.default_axle_tire_parameters() -&gt; AxleTireParameters</code></li> </ul>"},{"location":"API/#single-track-backend","title":"Single-track backend","text":"<ul> <li><code>apexsim.vehicle.SingleTrackModel(vehicle, tires, physics, numerics)</code></li> <li><code>apexsim.vehicle.SingleTrackPhysics</code></li> <li><code>apexsim.vehicle.SingleTrackNumerics</code></li> <li><code>apexsim.vehicle.build_single_track_model(vehicle, tires, physics=None, numerics=None)</code></li> </ul> <p>Terminology note:</p> <ul> <li><code>SingleTrack</code> corresponds to the \"bicycle model\" terminology commonly used in literature.</li> </ul>"},{"location":"API/#point-mass-backend","title":"Point-mass backend","text":"<ul> <li><code>apexsim.vehicle.PointMassModel(vehicle, physics)</code></li> <li><code>apexsim.vehicle.PointMassPhysics</code></li> <li><code>apexsim.vehicle.build_point_mass_model(vehicle, physics=None)</code></li> <li><code>apexsim.vehicle.calibrate_point_mass_friction_to_single_track(vehicle, tires, ...)</code></li> </ul>"},{"location":"API/#3-simulation-setup-and-run","title":"3. Simulation setup and run","text":"<ul> <li><code>apexsim.simulation.RuntimeConfig</code></li> <li><code>apexsim.simulation.NumericsConfig</code></li> <li><code>apexsim.simulation.TransientConfig</code></li> <li><code>apexsim.simulation.TransientNumericsConfig</code></li> <li><code>apexsim.simulation.TransientPidGainSchedulingConfig</code></li> <li><code>apexsim.simulation.TransientRuntimeConfig</code></li> <li><code>apexsim.simulation.PidSpeedSchedule</code></li> <li><code>apexsim.simulation.SimulationConfig</code></li> <li><code>apexsim.simulation.build_simulation_config(...)</code></li> <li><code>apexsim.simulation.build_physics_informed_pid_gain_scheduling(...)</code></li> <li><code>apexsim.simulation.simulate_lap(track, model, config) -&gt; LapResult</code></li> <li><code>apexsim.simulation.solve_speed_profile_torch(track, model, config) -&gt; TorchSpeedProfileResult</code></li> <li><code>apexsim.simulation.solve_transient_lap_torch(track, model, config) -&gt; TorchTransientProfileResult</code></li> </ul> <p>Backend runtime controls:</p> <ul> <li><code>RuntimeConfig.compute_backend</code>: <code>\"numpy\"</code>, <code>\"numba\"</code>, or <code>\"torch\"</code></li> <li><code>RuntimeConfig.solver_mode</code>: <code>\"quasi_static\"</code> or <code>\"transient_oc\"</code></li> <li><code>RuntimeConfig.torch_device</code>: keep <code>\"cpu\"</code> for <code>numpy</code>/<code>numba</code>; use <code>\"cpu\"</code> or <code>\"cuda:0\"</code> for <code>torch</code></li> <li><code>RuntimeConfig.torch_compile</code>: reserved flag, must currently remain <code>False</code> for simulation</li> <li><code>RuntimeConfig.initial_speed</code>: optional start speed at first track sample [m/s]   (supports <code>0.0</code> for standing starts)</li> <li><code>TransientRuntimeConfig.driver_model</code>: <code>\"pid\"</code> (default) or <code>\"optimal_control\"</code></li> <li><code>TransientNumericsConfig.pid_gain_scheduling_mode</code>: <code>\"off\"</code> (default),   <code>\"physics_informed\"</code>, or <code>\"custom\"</code></li> <li><code>TransientNumericsConfig.pid_gain_scheduling</code>: optional   <code>TransientPidGainSchedulingConfig</code> (required for <code>\"custom\"</code> mode)</li> <li><code>driver_model=\"optimal_control\"</code> raises <code>ConfigurationError</code> if the optimizer   does not converge or returns a non-finite final profile.</li> </ul> <p>Constraint for differentiable solver use:</p> <ul> <li><code>solve_speed_profile_torch(...)</code> is the differentiable torch solver and requires   <code>RuntimeConfig.torch_compile = False</code></li> </ul> <p><code>PidSpeedSchedule</code> defines one gain table:</p> <ul> <li><code>speed_nodes_mps</code>: strictly increasing speed nodes [m/s]</li> <li><code>values</code>: gain values at each node</li> <li>interpolation: piecewise-linear with boundary clamping</li> </ul> <p>See Compute Backends for selection guidance and benchmarks.</p> <p>Vehicle-model solver contract:</p> <ul> <li><code>validate()</code></li> <li><code>lateral_accel_limit(speed, banking)</code></li> <li><code>max_longitudinal_accel(speed, lateral_accel_required, grade, banking)</code></li> <li><code>max_longitudinal_decel(speed, lateral_accel_required, grade, banking)</code></li> <li><code>diagnostics(speed, longitudinal_accel, lateral_accel, curvature)</code></li> </ul>"},{"location":"API/#4-postprocessing","title":"4. Postprocessing","text":"<ul> <li><code>apexsim.analysis.compute_kpis(result) -&gt; KpiSummary</code></li> <li><code>apexsim.analysis.export_standard_plots(result, output_dir)</code></li> <li><code>apexsim.analysis.export.export_kpi_json(kpis, path)</code></li> <li><code>apexsim.analysis.compute_performance_envelope(model, ...) -&gt; PerformanceEnvelopeResult</code></li> <li><code>apexsim.analysis.PerformanceEnvelopePhysics</code></li> <li><code>apexsim.analysis.PerformanceEnvelopeNumerics</code></li> <li><code>apexsim.analysis.PerformanceEnvelopeRuntime</code></li> <li><code>apexsim.analysis.build_performance_envelope_config(...) -&gt; PerformanceEnvelopeConfig</code></li> <li><code>apexsim.analysis.SensitivityParameter</code></li> <li><code>apexsim.analysis.SensitivityNumerics</code></li> <li><code>apexsim.analysis.SensitivityRuntime</code></li> <li><code>apexsim.analysis.SensitivityConfig</code></li> <li><code>apexsim.analysis.build_sensitivity_config(...) -&gt; SensitivityConfig</code></li> <li><code>apexsim.analysis.compute_sensitivities(objective, parameters, ...) -&gt; SensitivityResult</code></li> <li><code>apexsim.analysis.SensitivityStudyParameter</code></li> <li><code>apexsim.analysis.SensitivityStudyResult</code></li> <li><code>apexsim.analysis.register_sensitivity_model_adapter(...) -&gt; None</code></li> <li><code>apexsim.analysis.run_lap_sensitivity_study(...) -&gt; SensitivityStudyResult</code></li> </ul> <p><code>LapResult</code> provides:</p> <ul> <li>lap time</li> <li>speed / longitudinal acceleration / lateral acceleration traces</li> <li>yaw moment</li> <li>quasi-static mode: zero by model assumption</li> <li>transient mode: dynamic residual \\(M_z = I_z \\dot r\\)</li> <li>front/rear axle loads</li> <li>power and energy</li> <li>solver mode identifier (<code>quasi_static</code> or <code>transient_oc</code>)</li> <li>transient-only traces (<code>time</code>, <code>vx</code>, <code>vy</code>, <code>yaw_rate</code>, <code>steer_cmd</code>, <code>ax_cmd</code>)</li> </ul> <p><code>PerformanceEnvelopeResult</code> provides:</p> <ul> <li>speed support points</li> <li>lateral-acceleration limits per speed</li> <li>sampled lateral-acceleration grid</li> <li>max/min longitudinal acceleration grid</li> <li>optional <code>.to_dataframe()</code> conversion for tabular studies</li> </ul> <p><code>SensitivityResult</code> provides:</p> <ul> <li>baseline scalar objective value</li> <li>local sensitivities per parameter</li> <li>method metadata (<code>autodiff</code> or <code>finite_difference</code>)</li> <li>baseline parameter values and parameter kind (<code>physical</code> / <code>numerical</code>)</li> </ul> <p><code>SensitivityStudyResult</code> provides:</p> <ul> <li>multi-objective lap sensitivity outputs (<code>lap_time_s</code>, <code>energy_kwh</code>)</li> <li>long-form tabular export via <code>.to_dataframe()</code></li> <li>compact parameter \u00d7 objective table via <code>.to_pivot()</code></li> <li>AD-first evaluation on torch backend, including transient PID studies   (<code>solver_mode=\"transient_oc\"</code>, <code>driver_model=\"pid\"</code>).</li> <li><code>driver_model=\"optimal_control\"</code> currently requires explicit finite differences.</li> </ul>"},{"location":"API/#5-minimal-usage-pattern","title":"5. Minimal usage pattern","text":"<pre><code>track = load_track_csv(\"data/spa_francorchamps.csv\")\nmodel = build_single_track_model(vehicle=vehicle, tires=tires, physics=SingleTrackPhysics())\nconfig = build_simulation_config(max_speed=115.0)\nresult = simulate_lap(track=track, model=model, config=config)\nkpis = compute_kpis(result)\n</code></pre>"},{"location":"API/#6-related-guides","title":"6. Related guides","text":"<ul> <li>How to Use</li> <li>Examples Overview</li> <li>Solver</li> <li>Single-Track Model</li> <li>Point-Mass Model</li> </ul>"},{"location":"ASSUMPTIONS/","title":"Assumptions and Limitations","text":"<ul> <li>Base vehicle dynamics are 3-DOF (<code>vx</code>, <code>vy</code>, <code>yaw_rate</code>) with single-track abstraction.</li> <li>Point-mass backend is available as an alternative model and assumes zero yaw moment   in diagnostics by construction.</li> <li>Tire model implements Pacejka-style lateral force only in this phase.</li> <li>Longitudinal force limits are represented by configurable accel/brake envelopes.</li> <li>Point-mass backend uses an isotropic friction-circle with speed-dependent normal   load from aerodynamic downforce.</li> <li>Quasi-static mode solves a lateral speed envelope via fixed-point iteration with   configurable tolerance and iteration cap in <code>SimulationConfig.numerics</code>.</li> <li>Transient mode solves a minimum-time optimal-control problem on the fixed centerline   with bounded controls and dynamic-state propagation.</li> <li>In transient mode, <code>SingleTrackModel</code> steering limits are configured through   <code>SingleTrackPhysics.max_steer_angle</code> and <code>SingleTrackPhysics.max_steer_rate</code>.</li> <li>Transient PID gain scheduling (when enabled) is speed-only in v1:   no preview controller, no explicit curvature/load-state scheduling.</li> <li><code>pid_gain_scheduling_mode=\"physics_informed\"</code> uses deterministic heuristics   based on flat-road longitudinal authority and clipped speed scaling.</li> <li>Aero model uses constant coefficients (<code>c_l</code>, <code>c_d</code>) and rigid ride height.</li> <li>The lap-time solver is decoupled from specific vehicle equations and only   depends on the <code>VehicleModel</code> API contract.</li> <li>Track data expects closed-loop CSV with columns: <code>x</code>, <code>y</code>, <code>elevation</code>, <code>banking</code>.</li> <li>Current Spa import uses real centerline coordinates, while <code>elevation</code> and <code>banking</code> are   set to <code>0.0</code> until higher-fidelity telemetry/map layers are integrated.</li> </ul> <p>These simplifications are intentional to keep the architecture extensible for future modules: full vehicle, powertrain, and energy management.</p>"},{"location":"BACKENDS/","title":"Compute Backends","text":"<p>ApexSim separates physical modeling from numerical execution backends. This page helps you choose the right backend for your study.</p>"},{"location":"BACKENDS/#shared-core-architecture","title":"Shared Core Architecture","text":"<p>Solver backends intentionally share one algorithmic core where possible:</p> <ul> <li>Quasi-static speed profile:</li> <li>shared core: <code>src/apexsim/simulation/_profile_core.py</code></li> <li>numpy adapter: <code>src/apexsim/simulation/profile.py</code></li> <li>torch adapter: <code>src/apexsim/simulation/torch_profile.py</code></li> <li>numba keeps specialized kernels in <code>src/apexsim/simulation/numba_profile.py</code>     with parity checks against shared semantics.</li> <li>Transient PID infrastructure:</li> <li>shared helpers: <code>src/apexsim/simulation/_transient_pid_core.py</code></li> <li>shared control mesh/encoding: <code>src/apexsim/simulation/_transient_controls_core.py</code></li> <li>shared progress reporting: <code>src/apexsim/simulation/_progress.py</code></li> <li>Vehicle backend physics primitives:</li> <li>shared formulas: <code>src/apexsim/vehicle/_backend_physics_core.py</code></li> <li>consumed by point-mass and single-track backend adapters.</li> </ul> <p>This reduces backend-specific formula drift while preserving specialized performance paths (especially numba kernels).</p>"},{"location":"BACKENDS/#backend-policy","title":"Backend policy","text":"<p>Supported backends are intentionally restricted to:</p> <ul> <li><code>numpy</code>: CPU-only reference backend.</li> <li><code>numba</code>: CPU-only JIT-accelerated backend.</li> <li><code>torch</code>: CPU and GPU backend (device via <code>torch_device</code>).</li> </ul> <p>Solver modes:</p> <ul> <li><code>quasi_static</code> (default)</li> <li><code>transient_oc</code></li> </ul> <p>The runtime validator enforces this policy:</p> <ul> <li><code>numpy</code> and <code>numba</code> require <code>torch_device=\"cpu\"</code>.</li> <li><code>compute_backend=\"torch\"</code> currently requires <code>torch_compile=False</code> so the   solver path remains AD-compatible by default.</li> <li><code>solver_mode=\"transient_oc\"</code> with <code>driver_model=\"optimal_control\"</code> requires   backend-specific extras:</li> <li><code>numpy</code> and <code>numba</code>: <code>scipy</code></li> <li><code>torch</code>: <code>torchdiffeq</code></li> <li><code>TransientNumericsConfig.pid_gain_scheduling_mode</code> is supported in PID mode   on all three backends (<code>numpy</code>, <code>numba</code>, <code>torch</code>).</li> </ul>"},{"location":"BACKENDS/#current-model-support","title":"Current model support","text":"<p>Backend support is model-dependent:</p> <ul> <li><code>PointMassModel</code>: supports <code>numpy</code>, <code>numba</code>, <code>torch</code>.</li> <li><code>SingleTrackModel</code>: supports <code>numpy</code>, <code>numba</code>, <code>torch</code>.</li> </ul> <p>Terminology note:</p> <ul> <li><code>SingleTrackModel</code> corresponds to the \"bicycle model\" terminology often used   in literature.</li> </ul> <p>If you request a backend that a model does not implement, the solver raises a clear <code>ConfigurationError</code> describing the missing model-side methods.</p>"},{"location":"BACKENDS/#decision-guide","title":"Decision guide","text":"<p>Use this practical rule-set:</p> <ol> <li>Use <code>numpy</code> when you need robust baseline behavior and easiest debugging.</li> <li>Use <code>numba</code> for large CPU parameter sweeps with <code>PointMassModel</code> or <code>SingleTrackModel</code>.</li> <li>Use <code>torch</code> when you need tensor-native workflows, GPU execution, or AD-first    optimization workflows.</li> </ol>"},{"location":"BACKENDS/#trade-offs-at-a-glance","title":"Trade-offs at a glance","text":"Backend Hardware Typical strength Typical cost <code>numpy</code> CPU Stable baseline, easy to inspect Slower for huge batch studies <code>numba</code> CPU Very fast steady-state loops after JIT warmup First call includes compile overhead <code>torch</code> CPU/GPU Backend portability, tensor ecosystem Higher overhead for single-lap CPU workloads"},{"location":"BACKENDS/#transient-dependency-note","title":"Transient dependency note","text":"<p>The transient solver dependencies are included in the default install:</p> <ul> <li><code>scipy</code> for NumPy/Numba transient optimal-control paths</li> <li><code>torchdiffeq</code> for Torch transient optimal-control ODE integration</li> </ul>"},{"location":"BACKENDS/#configuration-examples","title":"Configuration examples","text":""},{"location":"BACKENDS/#numpy-cpu-reference","title":"NumPy (CPU reference)","text":"<pre><code>from apexsim.simulation import build_simulation_config\n\nconfig = build_simulation_config(\n    compute_backend=\"numpy\",\n    max_speed=115.0,\n)\n</code></pre>"},{"location":"BACKENDS/#numba-cpu-optimized","title":"Numba (CPU-optimized)","text":"<pre><code>from apexsim.simulation import build_simulation_config\n\nconfig = build_simulation_config(\n    compute_backend=\"numba\",\n    max_speed=115.0,\n)\n</code></pre>"},{"location":"BACKENDS/#torch-cpu-or-gpu","title":"Torch (CPU or GPU)","text":"<pre><code>from apexsim.simulation import build_simulation_config\n\n# CPU\nconfig_cpu = build_simulation_config(\n    compute_backend=\"torch\",\n    torch_device=\"cpu\",\n    torch_compile=False,\n)\n\n# GPU\nconfig_gpu = build_simulation_config(\n    compute_backend=\"torch\",\n    torch_device=\"cuda:0\",\n    torch_compile=False,\n)\n</code></pre>"},{"location":"BACKENDS/#benchmark-methodology","title":"Benchmark methodology","text":"<p>Reference scripts:</p> <pre><code>python examples/backend_benchmarks.py --warmup-runs 5 --timed-runs 20\npython scripts/benchmark_solver_matrix.py --warmup-runs 2 --timed-runs 5 --output baseline.json\npython scripts/benchmark_solver_matrix.py --warmup-runs 2 --timed-runs 5 --output candidate.json\npython scripts/compare_solver_benchmarks.py --baseline baseline.json --candidate candidate.json --max-slowdown-pct 5 --require-same-cases\n</code></pre> <p>Notes:</p> <ul> <li>Benchmarks run full Spa point-mass laps (<code>data/spa_francorchamps.csv</code>).</li> <li>\"First Call\" includes startup/JIT/compile effects.</li> <li>\"Steady\" values are from repeated post-warmup runs.</li> <li>Use your own machine data for final backend decisions.</li> <li>The solver matrix script covers:</li> <li>models: <code>PointMassModel</code>, <code>SingleTrackModel</code></li> <li>solver modes: <code>quasi_static</code>, <code>transient_oc</code> (PID)</li> <li>tracks: straight, circle, plus Spa smoke (unless <code>--skip-spa</code>).</li> <li><code>compare_solver_benchmarks.py</code> is intended as a PR gate for the   5%-slowdown policy.</li> </ul>"},{"location":"BACKENDS/#benchmark-snapshot-february-17-2026","title":"Benchmark snapshot (February 17, 2026)","text":"<p>Environment used for this snapshot:</p> <ul> <li>CPU: Intel Core i7-8550U (4C/8T)</li> <li><code>numpy==2.3.5</code></li> <li><code>numba==0.63.1</code></li> <li><code>torch==2.10.0+cpu</code></li> <li>CUDA unavailable in this run</li> </ul> Backend First Call [ms] Steady Mean [ms] Steady Median [ms] Lap Time [s] <code>numpy</code> 19.72 14.72 14.73 133.668234 <code>numba</code> 1303.90 0.69 0.68 133.668234 <code>torch</code> (<code>cpu</code>) 323.99 342.27 337.44 133.668234 <p>Interpretation of this snapshot:</p> <ul> <li><code>numba</code> steady-state is about 21x faster than <code>numpy</code> after JIT warmup.</li> <li><code>torch</code> on CPU is slower than <code>numpy</code> for single-lap workflows in this setup.</li> <li>Identical lap times across backends confirm numerical consistency for this case.</li> </ul>"},{"location":"BACKENDS/#reproducibility-tips","title":"Reproducibility tips","text":"<ul> <li>Run each benchmark at least twice and compare medians.</li> <li>Avoid other heavy processes during timing runs.</li> <li>For GPU evaluation, include <code>torch_device=\"cuda:0\"</code> runs in addition to CPU runs.</li> <li>Save your benchmark JSON using <code>--output</code> and keep it with your project notes.</li> </ul>"},{"location":"DEVELOPMENT/","title":"Development","text":""},{"location":"DEVELOPMENT/#environment","title":"Environment","text":"<p>A local virtual environment is expected at <code>.venv</code>.</p> <pre><code>python3 -m venv --system-site-packages .venv\nsource .venv/bin/activate\npip install -e '.[dev]'\n</code></pre>"},{"location":"DEVELOPMENT/#test-commands","title":"Test Commands","text":"<p>Because this environment may run offline, tests can be executed via <code>unittest</code> directly:</p> <pre><code>source .venv/bin/activate\nPYTHONPATH=src python -m unittest discover -s tests -v\n</code></pre> <p>Coverage:</p> <pre><code>source .venv/bin/activate\nPYTHONPATH=src python -m coverage run -m unittest discover -s tests\npython -m coverage report -m\n</code></pre> <p>Coverage policy:</p> <ul> <li>Keep overall coverage at or above <code>95%</code>.</li> </ul> <p>If <code>pytest</code> is available:</p> <pre><code>source .venv/bin/activate\nPYTHONPATH=src pytest\n</code></pre>"},{"location":"DEVELOPMENT/#docstring-policy","title":"Docstring Policy","text":"<p>This repository enforces Google-style docstrings through <code>ruff</code> (<code>D</code> rules with <code>pydocstyle</code> convention <code>google</code>) and an AST contract test.</p> <p>Rules:</p> <ul> <li>Public classes, functions, and interfaces must include full Google docstrings.</li> <li>Private/technical helpers must always include a summary line.</li> <li>If a callable has parameters other than <code>self</code>/<code>cls</code>, include an <code>Args:</code> section.</li> <li>If a callable returns a non-<code>None</code> value, include a <code>Returns:</code> section.</li> <li>If a callable intentionally raises domain/validation errors, include <code>Raises:</code>.</li> <li>Keep units explicit for physics-facing values (<code>m/s</code>, <code>m/s^2</code>, <code>1/m</code>, <code>rad</code>, <code>W</code>).</li> </ul> <p>Example:</p> <pre><code>def lateral_speed_limit(curvature: float, lateral_accel_limit: float, max_speed: float) -&gt; float:\n    \"\"\"Compute speed limit from curvature and lateral acceleration capability.\n\n    Args:\n        curvature: Signed path curvature [1/m].\n        lateral_accel_limit: Available lateral acceleration magnitude [m/s^2].\n        max_speed: Global hard speed cap [m/s].\n\n    Returns:\n        Maximum feasible speed [m/s] under curvature and lateral limits.\n    \"\"\"\n</code></pre>"},{"location":"DEVELOPMENT/#parameter-layering","title":"Parameter Layering","text":"<p>Keep parameter domains separate:</p> <ul> <li>Physical model inputs:</li> <li><code>VehicleParameters</code></li> <li><code>PacejkaParameters</code> / <code>AxleTireParameters</code></li> <li><code>SingleTrackPhysics</code></li> <li>Numerical/discretization controls:</li> <li><code>NumericsConfig</code></li> <li><code>SingleTrackNumerics</code></li> <li>Simulation runtime controls (non-physical scenario bounds):</li> <li><code>RuntimeConfig</code></li> </ul> <p>Avoid mixing fixed-point tolerances, iteration limits, and numerical floors into physical parameter dataclasses.</p> <p>Defaulting guidance:</p> <ul> <li>Numerical controls may include stable defaults to keep quick-start simulations   robust (<code>NumericsConfig</code>, <code>SingleTrackNumerics</code>).</li> <li>Physical parameter classes should stay explicit and scenario-specific.</li> </ul>"},{"location":"DEVELOPMENT/#vehicle-model-architecture","title":"Vehicle Model Architecture","text":"<p>The solver contract is represented at two levels:</p> <ul> <li><code>VehicleModel</code> (Protocol) in <code>src/apexsim/simulation/model_api.py</code>   keeps the simulation pipeline structurally open for external backends.</li> <li><code>VehicleModelBase</code> plus   <code>EnvelopeVehicleModel</code> in <code>src/apexsim/vehicle/_model_base.py</code>   provides inheritance-based code organization for built-in backends.</li> </ul> <p>Built-in models (<code>SingleTrackModel</code>, <code>PointMassModel</code>) inherit the same base class to share validation layering, friction-circle scaling, and net drag/grade-corrected longitudinal limits.</p> <p>For backend-enabled models, keep backend adapters out of the physics layer:</p> <ul> <li><code>PointMassModel</code> composes private mixins from   <code>src/apexsim/vehicle/_point_mass_physics.py</code> and   <code>src/apexsim/vehicle/_point_mass_backends.py</code>.</li> <li>Physics equations stay backend-agnostic.</li> <li>Backend-specific methods (<code>numba</code>, <code>torch</code>) stay isolated in adapter mixins.</li> <li><code>SingleTrackModel</code> composes <code>src/apexsim/vehicle/_single_track_physics.py</code>,   which extends <code>PointMassPhysicalMixin</code> to reuse the shared physical core.</li> <li>Single-track backend adapters live in <code>src/apexsim/vehicle/_single_track_backends.py</code>   and mirror the point-mass backend adapter structure.</li> <li>Single-track-specific dynamics/supporting components live in   <code>src/apexsim/vehicle/single_track/</code> (for example <code>dynamics.py</code>,   <code>load_transfer.py</code>) to keep model-specific code grouped together.</li> </ul>"},{"location":"DEVELOPMENT/#backend-unification-rules","title":"Backend Unification Rules","text":"<p>When changing solver backend behavior:</p> <ul> <li>Do not duplicate core algorithmics per backend when a shared implementation   is feasible.</li> <li>Extend shared solver cores first:</li> <li><code>src/apexsim/simulation/_profile_core.py</code></li> <li><code>src/apexsim/simulation/_transient_pid_core.py</code></li> <li><code>src/apexsim/simulation/_transient_controls_core.py</code></li> <li><code>src/apexsim/simulation/_progress.py</code></li> <li>Keep backend modules (<code>profile.py</code>, <code>torch_profile.py</code>, <code>transient_*</code>) as   thin adapters around the shared core plus backend-specific primitives.</li> <li>Keep vehicle backend physics formulas centralized in   <code>src/apexsim/vehicle/_backend_physics_core.py</code> and consume those helpers   from point-mass and single-track backends.</li> <li>If a new backend-specific branch is unavoidable for performance, add a parity   test against the shared semantics and document why specialization is needed.</li> </ul> <p>Performance policy for refactors:</p> <ul> <li>Run <code>scripts/benchmark_solver_matrix.py</code> before and after significant backend   refactors.</li> <li>Compare with <code>scripts/compare_solver_benchmarks.py</code>.</li> <li>Any case slower than 5% requires either optimization or explicit, documented   justification.</li> </ul>"},{"location":"DEVELOPMENT/#refreshing-spa-data","title":"Refreshing Spa Data","text":"<pre><code>source .venv/bin/activate\npython scripts/import_spa_from_tumftm.py\n</code></pre>"},{"location":"EXAMPLES/","title":"Examples","text":"<p>This section is the tutorial path through the example scripts. It is designed for race engineers and Students who want practical onboarding.</p>"},{"location":"EXAMPLES/#what-you-will-learn-from-the-examples","title":"What you will learn from the examples","text":"<p>After finishing all example pages, you should be able to:</p> <ul> <li>set up a complete lap-time run from scratch,</li> <li>choose between point-mass and single-track model for a study goal,</li> <li>interpret key plots and KPI outputs correctly,</li> <li>understand where model assumptions limit interpretation.</li> </ul>"},{"location":"EXAMPLES/#recommended-tutorial-sequence","title":"Recommended tutorial sequence","text":"<ol> <li>Synthetic Track Walkthrough</li> <li>Spa Walkthrough</li> <li>Transient Solver Walkthrough</li> <li>Sensitivity Walkthrough</li> </ol> <p>Reason:</p> <ul> <li>Synthetic tracks isolate single effects and simplify debugging.</li> <li>Spa introduces full-track interactions and realistic complexity.</li> <li>Transient examples introduce state/control trajectories beyond quasi-static envelopes.</li> <li>Sensitivity examples connect parameter changes to lap-time and energy outcomes.</li> </ul>"},{"location":"EXAMPLES/#mapping-scripts-to-engineering-questions","title":"Mapping scripts to engineering questions","text":"<ul> <li><code>examples/synthetic_track_scenarios.py</code></li> <li>\"Is my model setup physically consistent on canonical test geometries?\"</li> <li><code>examples/spa/spa_lap_single_track.py</code></li> <li>\"What does the single-track model predict on a realistic circuit?\"</li> <li><code>examples/spa/spa_lap_point_mass.py</code></li> <li>\"What is the low-complexity baseline on the same circuit?\"</li> <li><code>examples/spa/spa_model_comparison.py</code></li> <li>\"What do I gain from additional model fidelity?\"</li> <li><code>examples/spa/spa_performance_envelope.py</code></li> <li>\"How does the speed-dependent G-G envelope differ by model complexity?\"</li> <li><code>examples/backend_benchmarks.py</code></li> <li>\"Which compute backend should I use for my workload?\"</li> <li><code>examples/transient/transient_point_mass_lap.py</code></li> <li>\"How does transient minimum-time launch behavior look for point-mass dynamics?\"</li> <li><code>examples/transient/transient_single_track_lap.py</code></li> <li>\"How do steering-rate and yaw dynamics affect a maneuver-heavy transient lap?\"</li> <li><code>examples/sensitivity/synthetic_single_track_sensitivity.py</code></li> <li>\"How sensitive are lap time and energy to key parameters on a canonical track via the Sensitivity API?\"</li> <li><code>examples/sensitivity/spa_single_track_sensitivity.py</code></li> <li>\"Which parameters matter most for lap time and energy on Spa via the Sensitivity API?\"</li> </ul>"},{"location":"EXAMPLES/#what-the-example-suite-covers-well","title":"What the example suite covers well","text":"<ul> <li>End-to-end solver use on real and synthetic tracks.</li> <li>Side-by-side transient and quasi-static solver usage through the same public API.</li> <li>KPI and plot export workflows.</li> <li>Direct model-complexity comparison.</li> <li>Practical interpretation of speed/acceleration/yaw diagnostics.</li> <li>Parameter sensitivity interpretation for lap time and energy objectives.</li> </ul>"},{"location":"EXAMPLES/#what-the-example-suite-does-not-claim","title":"What the example suite does not claim","text":"<ul> <li>It is not a final validation against fully instrumented race telemetry.</li> <li>It does not include a full transient driver + powertrain control stack.</li> <li>It does not replace model-calibration work on real vehicle data.</li> </ul>"},{"location":"EXAMPLES/#output-structure","title":"Output structure","text":"<p>All scripts export into <code>examples/output/</code> with consistent folder logic (<code>examples/output/spa/</code> for Spa-specific workflows and <code>examples/output/transient/</code> for transient-specific workflows). Typical artifacts:</p> <ul> <li><code>kpis.json</code></li> <li>speed traces</li> <li>G-G diagram</li> <li>yaw moment vs. lateral acceleration</li> <li>tire-load and power traces</li> </ul> <p>Because output format is standardized, comparisons across scripts are straightforward.</p>"},{"location":"EXAMPLES/#before-applying-results-to-decisions","title":"Before applying results to decisions","text":"<p>Use this quick quality gate:</p> <ol> <li>Check whether the selected model can represent your target effect.</li> <li>Confirm basic sanity checks on synthetic tracks.</li> <li>Check if KPI magnitudes are plausible for your vehicle class.</li> <li>Document assumptions used in the run.</li> </ol>"},{"location":"EXAMPLES_SYNTHETIC/","title":"Synthetic Track Walkthrough","text":"<p>This tutorial walks through <code>examples/synthetic_track_scenarios.py</code> in code order.</p> <p>Goal: build intuition for solver behavior on controlled geometries before moving to real circuits.</p>"},{"location":"EXAMPLES_SYNTHETIC/#why-this-tutorial-is-important","title":"Why this tutorial is important","text":"<p>Synthetic tracks are your first physical consistency filter. If behavior is implausible here, Spa results are likely hard to trust.</p>"},{"location":"EXAMPLES_SYNTHETIC/#1-imports-map-code-to-engineering-blocks","title":"1. Imports: map code to engineering blocks","text":"<p>The script imports:</p> <ul> <li><code>analysis</code>: KPI and figure export,</li> <li><code>simulation</code>: lap solver,</li> <li><code>track</code>: synthetic layout generators,</li> <li><code>vehicle</code>: point-mass model and its physics settings,</li> <li><code>utils</code>: logging and constants.</li> </ul> <p>If you are new to Python: imports are simply selecting the tools you need.</p>"},{"location":"EXAMPLES_SYNTHETIC/#2-define-vehicle-and-model","title":"2. Define vehicle and model","text":""},{"location":"EXAMPLES_SYNTHETIC/#21-vehicle-parameter-block","title":"2.1 Vehicle parameter block","text":"<p><code>_example_vehicle_parameters()</code> provides a complete car definition.</p> <p>Most influential fields for this tutorial:</p> <ul> <li><code>mass</code>, <code>lift_coefficient</code>, <code>drag_coefficient</code>, <code>frontal_area</code></li> <li>govern acceleration/drag balance and high-speed behavior,</li> <li><code>front_weight_fraction</code></li> <li>influences axle-load diagnostics,</li> <li>remaining vehicle parameters</li> <li>keep cross-model compatibility.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#22-model-choice-point-mass","title":"2.2 Model choice: point-mass","text":"<pre><code>model = build_point_mass_model(vehicle=vehicle, physics=PointMassPhysics())\n</code></pre> <p>Interpretation:</p> <ul> <li>very fast and stable for benchmark scenarios,</li> <li>no explicit yaw state,</li> <li>yaw moment output is structurally zero by design.</li> </ul> <p>If your study requires yaw-moment dynamics, switch to single-track model.</p>"},{"location":"EXAMPLES_SYNTHETIC/#23-solver-setup","title":"2.3 Solver setup","text":"<pre><code>config = build_simulation_config(max_speed=115.0)\n</code></pre> <p><code>max_speed</code> is a runtime cap, not a guarantee that the car can sustain this speed. Actual speed comes from force balance and constraints.</p>"},{"location":"EXAMPLES_SYNTHETIC/#3-build-three-benchmark-tracks","title":"3. Build three benchmark tracks","text":"<pre><code>tracks = {\n    \"straight_1km\": build_straight_track(length=STRAIGHT_LENGTH),\n    \"circle_r50\": build_circular_track(radius=CIRCLE_RADIUS),\n    \"figure_eight\": build_figure_eight_track(lobe_radius=FIGURE_EIGHT_RADIUS),\n}\n</code></pre>"},{"location":"EXAMPLES_SYNTHETIC/#31-straight-1-km","title":"3.1 Straight (1 km)","text":"<p>Tests pure longitudinal behavior with no curvature demand.</p>"},{"location":"EXAMPLES_SYNTHETIC/#32-circle-50-m-radius","title":"3.2 Circle (50 m radius)","text":"<p>Tests quasi-steady cornering with near-constant curvature.</p>"},{"location":"EXAMPLES_SYNTHETIC/#33-figure-eight","title":"3.3 Figure-eight","text":"<p>Tests left/right transition dynamics and sign changes in lateral acceleration.</p>"},{"location":"EXAMPLES_SYNTHETIC/#4-run-simulation-loop","title":"4. Run simulation loop","text":"<p>Per scenario:</p> <pre><code>result = simulate_lap(track=track, model=model, config=config)\nkpis = compute_kpis(result)\nexport_standard_plots(result, scenario_dir)\nexport_kpi_json(kpis, scenario_dir / \"kpis.json\")\n</code></pre> <p>This is the canonical ApexSim pattern and can be reused for custom studies.</p>"},{"location":"EXAMPLES_SYNTHETIC/#5-cross-scenario-comparison-output","title":"5. Cross-scenario comparison output","text":"<p>After scenario runs, script generates:</p> <ul> <li><code>speed_trace_comparison.png</code></li> <li><code>scenario_summary.json</code></li> </ul> <p>These files support quick A/B/C interpretation across geometries.</p>"},{"location":"EXAMPLES_SYNTHETIC/#6-how-to-interpret-each-scenario","title":"6. How to interpret each scenario","text":""},{"location":"EXAMPLES_SYNTHETIC/#straight-straight_1km","title":"Straight (<code>straight_1km</code>)","text":"<p>Expected:</p> <ul> <li>lateral acceleration near zero,</li> <li>curvature near zero,</li> <li>speed governed by net longitudinal balance.</li> </ul> <p>Important nuance:</p> <ul> <li>speed can decrease if drag at current speed exceeds available drive acceleration.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#circle-circle_r50","title":"Circle (<code>circle_r50</code>)","text":"<p>Expected:</p> <ul> <li>interior speed close to steady value,</li> <li>interior longitudinal acceleration near zero,</li> <li>positive lateral acceleration around loop.</li> </ul> <p>Practical tip:</p> <ul> <li>ignore seam-adjacent points for steady-state assessment.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#figure-eight-figure_eight","title":"Figure-eight (<code>figure_eight</code>)","text":"<p>Expected:</p> <ul> <li>lateral acceleration changes sign,</li> <li>acceleration and braking phases near transitions,</li> <li>stronger speed variation than constant-radius cornering.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#7-what-this-tutorial-validates-well","title":"7. What this tutorial validates well","text":"<ul> <li>solver stability,</li> <li>unit consistency and sign conventions,</li> <li>gross physical plausibility,</li> <li>basic model-behavior sanity.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#8-what-this-tutorial-does-not-validate-alone","title":"8. What this tutorial does not validate alone","text":"<ul> <li>absolute lap-time fidelity on a real circuit,</li> <li>transient steering/yaw control quality,</li> <li>powertrain energy strategy realism.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#9-common-mistakes-and-fixes","title":"9. Common mistakes and fixes","text":"<ol> <li>Expecting nonzero yaw moment with point-mass model.</li> <li>Use single-track model if yaw diagnostics are required.</li> <li>Treating seam points as steady-state evidence.</li> <li>trim boundary points before concluding.</li> <li>Assuming <code>max_speed</code> is always reached.</li> <li>check drag and available drive force first.</li> </ol>"},{"location":"EXAMPLES_SYNTHETIC/#10-suggested-next-step","title":"10. Suggested next step","text":"<p>After this tutorial, continue with Spa Walkthrough.</p>"},{"location":"EXAMPLES_SYNTHETIC/#run-command","title":"Run command","text":"<pre><code>python examples/synthetic_track_scenarios.py\n</code></pre>"},{"location":"HOW_TO_USE/","title":"How to Use ApexSim","text":"<p>This guide is a practical, engineer-oriented walkthrough of the complete workflow. It is written for race engineers and Students who may have strong dynamics knowledge but limited software background.</p>"},{"location":"HOW_TO_USE/#what-apexsim-is-designed-to-do","title":"What ApexSim is designed to do","text":"<p>ApexSim is optimized for fast, physically grounded lap-time studies with modular vehicle models.</p> <p>Main strengths:</p> <ul> <li>Quasi-steady lap-time simulation on arbitrary track centerlines.</li> <li>Transient lap simulation through the same <code>simulate_lap(...)</code> API.</li> <li>Interchangeable vehicle models behind one solver API.</li> <li>Clear separation between physical inputs and numerical solver settings.</li> <li>Reproducible engineering outputs (KPIs + standardized plots).</li> <li>Fast iteration loops for setup changes and what-if studies.</li> </ul>"},{"location":"HOW_TO_USE/#what-apexsim-does-not-do-yet","title":"What ApexSim does not do (yet)","text":"<p>Current model boundaries are important for correct interpretation:</p> <ul> <li>No human-driver identification or preview-control model yet.</li> <li>No detailed powertrain/energy management model yet.</li> <li>No full multi-body chassis compliance model.</li> <li>No direct tire thermal/wear state evolution.</li> </ul> <p>Interpretation rule:</p> <ul> <li>Use ApexSim for comparative setup studies and first-order lap-time sensitivity,   not as final truth for every transient detail.</li> </ul>"},{"location":"HOW_TO_USE/#the-6-step-workflow-always-the-same","title":"The 6-step workflow (always the same)","text":"<ol> <li>Import modules.</li> <li>Define physical model inputs.</li> <li>Load or generate a track.</li> <li>Configure numerics and runtime bounds.</li> <li>Run the simulation.</li> <li>Postprocess and review outputs.</li> </ol> <p>This pattern is identical across all examples.</p>"},{"location":"HOW_TO_USE/#step-1-imports","title":"Step 1: Imports","text":"<pre><code>from pathlib import Path\n\nfrom apexsim.analysis import compute_kpis, export_standard_plots\nfrom apexsim.analysis.export import export_kpi_json\nfrom apexsim.simulation import build_simulation_config, simulate_lap\nfrom apexsim.tire import default_axle_tire_parameters\nfrom apexsim.track import load_track_csv\nfrom apexsim.utils.constants import STANDARD_AIR_DENSITY\nfrom apexsim.vehicle import SingleTrackPhysics, VehicleParameters, build_single_track_model\n</code></pre> <p>How to read these imports as an engineer:</p> <ul> <li><code>track</code>: geometry and road profile.</li> <li><code>vehicle</code> + <code>tire</code>: physical car model.</li> <li><code>simulation</code>: numerical solver and runtime bounds.</li> <li><code>analysis</code>: KPI and visualization outputs.</li> </ul>"},{"location":"HOW_TO_USE/#step-2-define-physical-model-inputs","title":"Step 2: Define physical model inputs","text":""},{"location":"HOW_TO_USE/#21-vehicle-parameters-real-system-inputs","title":"2.1 Vehicle parameters (real-system inputs)","text":"<pre><code>vehicle = VehicleParameters(\n    mass=798.0,\n    yaw_inertia=1120.0,\n    cg_height=0.31,\n    wheelbase=3.60,\n    front_track=1.60,\n    rear_track=1.55,\n    front_weight_fraction=0.46,\n    cop_position=0.10,\n    lift_coefficient=3.20,\n    drag_coefficient=0.90,\n    frontal_area=1.50,\n    roll_rate=4200.0,\n    front_spring_rate=180000.0,\n    rear_spring_rate=165000.0,\n    front_arb_distribution=0.55,\n    front_ride_height=0.030,\n    rear_ride_height=0.050,\n    air_density=STANDARD_AIR_DENSITY,\n)\n</code></pre> <p>This block should reflect the best available engineering estimate of the real car.</p>"},{"location":"HOW_TO_USE/#22-tire-data","title":"2.2 Tire data","text":"<pre><code>tires = default_axle_tire_parameters()\n</code></pre> <p>Recommendation:</p> <ul> <li>Start with defaults for initial integration.</li> <li>Replace with identified tire parameters for decision-quality studies.</li> </ul>"},{"location":"HOW_TO_USE/#23-choose-model-complexity","title":"2.3 Choose model complexity","text":"<p>Single-track model:</p> <pre><code>model = build_single_track_model(\n    vehicle=vehicle,\n    tires=tires,\n    physics=SingleTrackPhysics(),\n)\n</code></pre> <p>Point-mass model:</p> <pre><code>from apexsim.vehicle import PointMassPhysics, build_point_mass_model\n\nmodel = build_point_mass_model(\n    vehicle=vehicle,\n    physics=PointMassPhysics(),\n)\n</code></pre> <p>When to use which:</p> <ul> <li>Single-track (bicycle): better cornering interpretation and richer diagnostics   (axle-load dynamics in all modes, dynamic yaw-residual signal in transient mode).</li> <li>Point-mass: fast baseline and sensitivity sweeps.</li> </ul>"},{"location":"HOW_TO_USE/#step-3-load-or-generate-track","title":"Step 3: Load or generate track","text":""},{"location":"HOW_TO_USE/#option-a-real-track-from-csv","title":"Option A: Real track from CSV","text":"<pre><code>project_root = Path(__file__).resolve().parents[1]\ntrack = load_track_csv(project_root / \"data\" / \"spa_francorchamps.csv\")\n</code></pre> <p>Required columns:</p> <ul> <li><code>x</code></li> <li><code>y</code></li> <li><code>elevation</code></li> <li><code>banking</code></li> </ul> <p>Internally, ApexSim derives arc length, heading, curvature, and grade.</p>"},{"location":"HOW_TO_USE/#option-b-synthetic-validation-tracks","title":"Option B: Synthetic validation tracks","text":"<pre><code>from apexsim.track import build_straight_track, build_circular_track, build_figure_eight_track\n\nstraight = build_straight_track(length=1000.0)\ncircle = build_circular_track(radius=50.0)\nfigure_eight = build_figure_eight_track(lobe_radius=80.0)\n</code></pre> <p>Why synthetic tracks matter:</p> <ul> <li>You can verify single effects in isolation.</li> <li>Debugging is easier than on a full GP circuit.</li> </ul>"},{"location":"HOW_TO_USE/#step-4-configure-runtime-and-numerics","title":"Step 4: Configure runtime and numerics","text":"<p>Simple setup:</p> <pre><code>config = build_simulation_config(max_speed=115.0)\n</code></pre> <p>Explicit quasi-static setup:</p> <pre><code>from apexsim.simulation import NumericsConfig, RuntimeConfig, SimulationConfig\n\nconfig = SimulationConfig(\n    runtime=RuntimeConfig(\n        max_speed=115.0,\n        initial_speed=20.0,\n        solver_mode=\"quasi_static\",\n    ),\n    numerics=NumericsConfig(\n        min_speed=8.0,\n        lateral_envelope_max_iterations=20,\n        lateral_envelope_convergence_tolerance=0.1,\n        transient_step=0.01,\n    ),\n)\n</code></pre> <p>Explicit transient setup:</p> <pre><code>from apexsim.simulation import (\n    PidSpeedSchedule,\n    TransientConfig,\n    TransientNumericsConfig,\n    TransientPidGainSchedulingConfig,\n    TransientRuntimeConfig,\n    build_simulation_config,\n)\n\nconfig_transient = build_simulation_config(\n    compute_backend=\"numpy\",\n    solver_mode=\"transient_oc\",\n    initial_speed=0.0,  # standing start\n    transient=TransientConfig(\n        numerics=TransientNumericsConfig(\n            integration_method=\"rk4\",\n            max_iterations=60,\n            control_interval=8,  # optimize on coarser control mesh, then interpolate\n            pid_gain_scheduling_mode=\"off\",  # legacy-compatible default\n        ),\n        runtime=TransientRuntimeConfig(\n            ode_backend_policy=\"auto\",\n            optimizer_backend_policy=\"auto\",\n            driver_model=\"pid\",  # default\n            verbosity=1,  # 1: optimizer progress, 2: +track progress\n        ),\n    ),\n)\n</code></pre> <p>Physics-informed PID scheduling (recommended start for transient PID studies):</p> <pre><code>config_transient_pid_sched = build_simulation_config(\n    compute_backend=\"numpy\",\n    solver_mode=\"transient_oc\",\n    initial_speed=0.0,\n    transient=TransientConfig(\n        numerics=TransientNumericsConfig(\n            pid_gain_scheduling_mode=\"physics_informed\",\n        ),\n    ),\n)\n</code></pre> <p>Custom PWL schedule example:</p> <pre><code>custom_schedule = TransientPidGainSchedulingConfig(\n    longitudinal_kp=PidSpeedSchedule((0.0, 20.0, 60.0), (0.9, 0.8, 0.7)),\n    longitudinal_ki=PidSpeedSchedule((0.0, 20.0, 60.0), (0.03, 0.02, 0.01)),\n    longitudinal_kd=PidSpeedSchedule((0.0, 20.0, 60.0), (0.07, 0.06, 0.05)),\n    steer_kp=PidSpeedSchedule((0.0, 20.0, 60.0), (1.8, 1.4, 0.9)),\n    steer_ki=PidSpeedSchedule((0.0, 20.0, 60.0), (0.08, 0.05, 0.03)),\n    steer_kd=PidSpeedSchedule((0.0, 20.0, 60.0), (0.16, 0.12, 0.09)),\n    steer_vy_damping=PidSpeedSchedule((0.0, 20.0, 60.0), (0.2, 0.27, 0.35)),\n)\nconfig_transient_custom = build_simulation_config(\n    compute_backend=\"numpy\",\n    solver_mode=\"transient_oc\",\n    transient=TransientConfig(\n        numerics=TransientNumericsConfig(\n            pid_gain_scheduling_mode=\"custom\",\n            pid_gain_scheduling=custom_schedule,\n        ),\n    ),\n)\n</code></pre>"},{"location":"HOW_TO_USE/#backend-selection-numerical-execution","title":"Backend selection (numerical execution)","text":"<pre><code>config_numpy = build_simulation_config(compute_backend=\"numpy\", max_speed=115.0)\nconfig_numba = build_simulation_config(compute_backend=\"numba\", max_speed=115.0)\nconfig_torch = build_simulation_config(\n    compute_backend=\"torch\",\n    torch_device=\"cpu\",  # or \"cuda:0\"\n    torch_compile=False,\n    max_speed=115.0,\n)\n</code></pre> <p>Selection rule:</p> <ul> <li><code>numpy</code>: robust baseline and easiest debugging.</li> <li><code>numba</code>: fastest CPU sweeps (currently with <code>PointMassModel</code> and <code>SingleTrackModel</code>).</li> <li><code>torch</code>: CPU/GPU execution and AD-native workflows.</li> </ul> <p>For quantitative guidance, see Compute Backends.</p> <p>Critical distinction:</p> <ul> <li>Physical parameters represent the car/track reality.</li> <li>Numerical parameters control solver stability and convergence.</li> </ul> <p>Do not compensate wrong physics by over-tuning numerics.</p> <p><code>initial_speed</code> is optional. If omitted (<code>None</code>), the solver keeps the legacy start behavior. Set it explicitly when you need controlled acceleration phases from the first sample (for example, straight-line bottleneck studies or standing starts with <code>initial_speed=0.0</code>).</p> <p><code>solver_mode</code> selects the algorithm:</p> <ul> <li><code>quasi_static</code>: envelope-based speed-profile solver (default).</li> <li><code>transient_oc</code>: transient dynamic solver mode.</li> <li>Default driver model: PID (<code>TransientRuntimeConfig.driver_model=\"pid\"</code>).</li> <li>Optional full optimizer path: <code>driver_model=\"optimal_control\"</code>.<ul> <li>Non-converged OC runs fail fast with <code>ConfigurationError</code> (no silent fallback).</li> <li>OC is validated against quasi-static references on simple straight/circle cases.</li> </ul> </li> <li>PID scheduling modes:<ul> <li><code>off</code> (default): scalar gains only.</li> <li><code>physics_informed</code>: deterministic speed-dependent PWL schedule from vehicle physics.</li> <li><code>custom</code>: user-provided <code>TransientPidGainSchedulingConfig</code>.</li> </ul> </li> </ul> <p>Transient dependency note:</p> <ul> <li><code>driver_model=\"pid\"</code> does not require transient optimizer extras.</li> <li><code>numpy</code> / <code>numba</code> with <code>driver_model=\"optimal_control\"</code> requires <code>scipy</code>.</li> <li><code>torch</code> with <code>driver_model=\"optimal_control\"</code> requires <code>torchdiffeq</code>.</li> <li>Both are part of the default package dependencies.</li> </ul>"},{"location":"HOW_TO_USE/#step-5-run-the-lap-simulation","title":"Step 5: Run the lap simulation","text":"<pre><code>result = simulate_lap(track=track, model=model, config=config)\n</code></pre> <p><code>result</code> includes:</p> <ul> <li>lap time</li> <li>speed trace</li> <li>longitudinal/lateral accelerations</li> <li>yaw moment</li> <li>axle loads</li> <li>power trace</li> <li>integrated energy</li> </ul> <p>When <code>solver_mode=\"transient_oc\"</code>, <code>result</code> also contains:</p> <ul> <li><code>time</code></li> <li><code>vx</code>, <code>vy</code>, <code>yaw_rate</code></li> <li><code>steer_cmd</code>, <code>ax_cmd</code></li> </ul>"},{"location":"HOW_TO_USE/#step-6-postprocess-and-export","title":"Step 6: Postprocess and export","text":"<pre><code>kpis = compute_kpis(result)\n\noutput_dir = project_root / \"examples\" / \"output\"\nexport_standard_plots(result, output_dir)\nexport_kpi_json(kpis, output_dir / \"kpis.json\")\n</code></pre> <p>Optional: generate a speed-dependent performance envelope (G-G map family):</p> <pre><code>from apexsim.analysis import (\n    PerformanceEnvelopeNumerics,\n    PerformanceEnvelopePhysics,\n    compute_performance_envelope,\n)\n\nenvelope = compute_performance_envelope(\n    model=model,\n    physics=PerformanceEnvelopePhysics(speed_min=20.0, speed_max=90.0),\n    numerics=PerformanceEnvelopeNumerics(speed_samples=31, lateral_accel_samples=41),\n)\nenvelope_array = envelope.to_numpy()\n</code></pre> <p>Optional: run a local lap-sensitivity study (AD default on torch backend):</p> <pre><code>from apexsim.analysis import (\n    SensitivityStudyParameter,\n    SensitivityRuntime,\n    run_lap_sensitivity_study,\n)\n\nmodel = build_single_track_model(\n    vehicle=vehicle,\n    tires=tires,\n    physics=SingleTrackPhysics(),\n)\nstudy = run_lap_sensitivity_study(\n    track=track,\n    model=model,\n    simulation_config=config_torch,\n    parameters=[\n        SensitivityStudyParameter(name=\"mass\", target=\"vehicle.mass\", label=\"Vehicle mass\"),\n        SensitivityStudyParameter(\n            name=\"drag_coefficient\",\n            target=\"vehicle.drag_coefficient\",\n            label=\"Drag coefficient\",\n        ),\n    ],\n    label=\"Spa single-track\",\n)\nlong_table = study.to_dataframe()\npivot_table = study.to_pivot()\n</code></pre> <p>For transient studies, AD is supported with PID driver mode. AD for <code>solver_mode=\"transient_oc\"</code> with <code>driver_model=\"optimal_control\"</code> is currently not supported.</p> <p>To force finite differences (for regression checks or transient <code>optimal_control</code> studies), pass:</p> <pre><code>study_fd = run_lap_sensitivity_study(\n    track=track,\n    model=model,\n    simulation_config=config_torch,\n    parameters=[SensitivityStudyParameter(name=\"mass\", target=\"vehicle.mass\")],\n    runtime=SensitivityRuntime(method=\"finite_difference\"),\n)\n</code></pre> <p>To support custom model classes, register an adapter once:</p> <pre><code>from apexsim.analysis import register_sensitivity_model_adapter\n\nregister_sensitivity_model_adapter(\n    model_type=TwinTrackModel,\n    model_factory=build_twin_track_model,\n    model_inputs_getter=lambda model: {\n        \"vehicle\": model.vehicle,\n        \"tires\": model.tires,\n        \"physics\": model.physics,\n        \"numerics\": model.numerics,\n    },\n)\n</code></pre> <p>Optional: run the public differentiable torch speed-profile API directly for custom gradient workflows:</p> <pre><code>from apexsim.simulation import build_simulation_config, solve_speed_profile_torch\n\ntorch_config = build_simulation_config(\n    compute_backend=\"torch\",\n    torch_device=\"cpu\",\n    torch_compile=False,  # torch backend keeps AD-compatible behavior\n    max_speed=115.0,\n    initial_speed=20.0,\n)\ntorch_result = solve_speed_profile_torch(track=track, model=model, config=torch_config)\nlap_time_tensor = torch_result.lap_time\n</code></pre> <p>Optional: run the public differentiable torch transient API directly:</p> <pre><code>from apexsim.simulation import solve_transient_lap_torch\n\ntorch_transient_config = build_simulation_config(\n    compute_backend=\"torch\",\n    solver_mode=\"transient_oc\",\n    torch_device=\"cpu\",\n    torch_compile=False,\n    initial_speed=0.0,\n)\ntorch_transient_result = solve_transient_lap_torch(\n    track=track,\n    model=model,\n    config=torch_transient_config,\n)\nlap_time_tensor = torch_transient_result.lap_time\n</code></pre> <p>Minimum review set:</p> <ul> <li>lap time</li> <li>max lateral acceleration</li> <li>max longitudinal acceleration/deceleration</li> <li>speed trace shape vs track layout</li> </ul>"},{"location":"HOW_TO_USE/#engineering-interpretation-checklist","title":"Engineering interpretation checklist","text":"<p>Before using results for decisions:</p> <ol> <li>Straight track check: near-zero lateral acceleration.</li> <li>Constant-radius check: quasi-steady cornering in interior segments.</li> <li>Figure-eight check: lateral acceleration sign change and entry/exit transitions.</li> <li>Magnitude check: compare against realistic bounds for your car class.</li> <li>Model check: verify whether selected model complexity can represent the effect you study.</li> </ol>"},{"location":"HOW_TO_USE/#typical-pitfalls-and-fixes","title":"Typical pitfalls (and fixes)","text":"<ol> <li>\"The solver should always accelerate to max speed.\"</li> <li>Not necessarily. At high speed, drag can exceed available drive force.</li> <li>\"Yaw moment should always be visible.\"</li> <li>Not in quasi-static mode (steady-state assumption -&gt; zero yaw moment), and      not with point-mass model (structurally zero in both modes).</li> <li>\"Changing numerics changed physics dramatically.\"</li> <li>Re-check physical parameters first; numerics should refine stability, not redefine behavior.</li> <li>\"My results jump near lap closure.\"</li> <li>For closed loops, inspect interior segments and avoid over-interpreting seam points.</li> </ol>"},{"location":"HOW_TO_USE/#recommended-onboarding-path","title":"Recommended onboarding path","text":"<ol> <li>Read Synthetic Track Walkthrough.</li> <li>Run Spa Walkthrough.</li> <li>Compare model complexity with <code>examples/spa/spa_model_comparison.py</code>.</li> <li>Move from default tire/model settings to identified vehicle data.</li> </ol>"},{"location":"POINT_MASS_MODEL/","title":"Point-Mass Model","text":"<p>This document defines the implemented point-mass backend in <code>src/apexsim/vehicle/point_mass_model.py</code>.</p>"},{"location":"POINT_MASS_MODEL/#1-scope","title":"1. Scope","text":"<p>The point-mass model keeps the solver API contract but replaces detailed chassis/yaw dynamics with a scalar acceleration envelope.</p> <p>State assumptions at each track point:</p> <ul> <li>no resolved yaw dynamics in diagnostics (\\(M_z = 0\\)),</li> <li>isotropic tire friction-circle coupling,</li> <li>normal load from gravity plus aerodynamic downforce.</li> </ul> <p>This corresponds to a reduced longitudinal/lateral envelope model commonly used for first-order lap-time studies [1], [3].</p>"},{"location":"POINT_MASS_MODEL/#2-tire-normal-acceleration-budget","title":"2. Tire Normal-Acceleration Budget","text":"<p>At speed \\(v\\):</p> \\[ a_n(v) = g + \\frac{F_\\text{down}(v)}{m}, \\] <p>with</p> \\[ F_\\text{down}(v) = \\frac{1}{2}\\rho C_L A v^2. \\] <p>The model applies a lower bound \\(a_n(v)\\ge\\varepsilon\\) for numerical robustness.</p>"},{"location":"POINT_MASS_MODEL/#3-lateral-limit","title":"3. Lateral Limit","text":"<p>With isotropic friction coefficient \\(\\mu\\):</p> \\[ a_{y,\\text{tire}}(v) = \\mu a_n(v). \\] <p>Including banking contribution:</p> \\[ a_{y,\\text{lim}}(v,\\beta) = \\max\\left(a_{y,\\text{tire}}(v) + g\\sin\\beta,\\ \\varepsilon\\right). \\] <p>The friction-circle and combined-acceleration interpretation follows [3].</p>"},{"location":"POINT_MASS_MODEL/#4-friction-circle-coupling","title":"4. Friction-Circle Coupling","text":"<p>For required lateral acceleration magnitude \\(|a_{y,\\text{req}}|\\):</p> \\[ \\lambda = \\sqrt{\\max\\left(0,\\ 1 - \\left(\\frac{|a_{y,\\text{req}}|}{a_{y,\\text{lim}}}\\right)^2\\right)}. \\]"},{"location":"POINT_MASS_MODEL/#5-longitudinal-limits","title":"5. Longitudinal Limits","text":"<p>Tire-limited longitudinal acceleration magnitude:</p> \\[ a_{x,\\text{tire,lim}}(v) = \\mu a_n(v). \\] <p>Drive envelope:</p> \\[ a_{x,\\text{drive}}(v) = \\min\\left(a_{x,\\text{drive,max}},\\ a_{x,\\text{tire,lim}}(v)\\right)\\lambda. \\] <p>Brake envelope:</p> \\[ a_{x,\\text{brake}}(v) = \\min\\left(a_{x,\\text{brake,max}},\\ a_{x,\\text{tire,lim}}(v)\\right)\\lambda. \\] <p>Net along-track acceleration:</p> \\[ a_{x,\\text{net}} = a_{x,\\text{drive}} - \\frac{D(v)}{m} - g\\,\\gamma, \\] <p>available deceleration magnitude:</p> \\[ a_{x,\\text{decel,avail}} = \\max\\left(a_{x,\\text{brake}} + \\frac{D(v)}{m} + g\\,\\gamma,\\ 0\\right), \\] <p>with</p> \\[ D(v)=\\frac{1}{2}\\rho C_D A v^2. \\] <p>The aerodynamic force expressions follow the standard quadratic law [1], [3].</p>"},{"location":"POINT_MASS_MODEL/#6-diagnostics","title":"6. Diagnostics","text":"<p>The backend reports:</p> <ul> <li>yaw moment: \\(0\\),</li> <li>axle loads from static split plus aero split:</li> <li>\\(F_{z,f} = mg\\phi_f + F_{\\text{down},f}\\),</li> <li>\\(F_{z,r} = mg(1-\\phi_f) + F_{\\text{down},r}\\),</li> <li>tractive power: [   P = \\left(m a_x + D(v)\\right)v. ]</li> </ul>"},{"location":"POINT_MASS_MODEL/#7-equation-to-code-mapping","title":"7. Equation-to-Code Mapping","text":"<ul> <li>normal-acceleration budget:   <code>PointMassModel._normal_accel_limit(...)</code></li> <li>lateral limit:   <code>PointMassModel.lateral_accel_limit(...)</code></li> <li>friction-circle scaling:   <code>PointMassModel._friction_circle_scale(...)</code></li> <li>longitudinal accel/decel limits:   <code>PointMassModel.max_longitudinal_accel(...)</code>,   <code>PointMassModel.max_longitudinal_decel(...)</code></li> <li>diagnostics:   <code>PointMassModel.diagnostics(...)</code></li> </ul>"},{"location":"POINT_MASS_MODEL/#8-cross-model-calibration","title":"8. Cross-Model Calibration","text":"<p>To align the point-mass model with the single-track model's lateral envelope, the library provides:</p> <ul> <li><code>calibrate_point_mass_friction_to_single_track(vehicle, tires, ...)</code></li> </ul> <p>This identifies an effective isotropic \\(\\mu\\) by least-squares fitting:</p> \\[ \\mu^\\star = \\arg\\min_\\mu \\sum_i \\left(\\mu a_n(v_i) - a_{y,\\text{lim,single-track}}(v_i)\\right)^2. \\] <p>The comparison example uses this calibration before running the point-mass model.</p>"},{"location":"POINT_MASS_MODEL/#9-example","title":"9. Example","text":"<ul> <li>Point-mass standalone usage:   <code>examples/spa/spa_lap_point_mass.py</code></li> <li>Side-by-side comparison against single-track model:   <code>examples/spa/spa_model_comparison.py</code></li> </ul>"},{"location":"POINT_MASS_MODEL/#references","title":"References","text":"<p>[1] D. Schramm, M. Hiller, and R. Bardini, Vehicle Dynamics: Modeling and Simulation. Berlin, Heidelberg: Springer, 2014.</p> <p>[2] H. B. Pacejka, Tyre and Vehicle Dynamics, 2nd ed. Oxford: Butterworth-Heinemann, 2006.</p> <p>[3] W. F. Milliken and D. L. Milliken, Race Car Vehicle Dynamics. Warrendale, PA: Society of Automotive Engineers, 1995.</p>"},{"location":"SINGLE_TRACK_MODEL/","title":"Single-Track Model","text":"<p>This document defines the implemented single-track backend in <code>src/apexsim/vehicle/single_track_model.py</code> and <code>src/apexsim/vehicle/_single_track_physics.py</code>.</p> <p>Terminology note:</p> <ul> <li><code>SingleTrack</code> in this package corresponds to the \"bicycle model\" terminology   frequently used in vehicle-dynamics literature.</li> </ul> <p>The single-track backend is implemented as a physical extension of the point-mass physical core (<code>PointMassPhysicalMixin</code>), with single-track-specific lateral force and diagnostic equations layered on top.</p>"},{"location":"SINGLE_TRACK_MODEL/#1-scope","title":"1. Scope","text":"<p>The single-track model keeps the solver API contract and adds axle-level lateral tire force modeling and quasi-static load transfer, while transient runs expose dynamic yaw behavior through residual diagnostics.</p> <p>State assumptions in the lap-time solver context:</p> <ul> <li>quasi-steady envelope evaluation (no transient tire relaxation in profile solve),</li> <li>lateral force from load-sensitive Pacejka at front and rear axle,</li> <li>friction-circle coupling between lateral demand and longitudinal capability,</li> <li>net along-track acceleration after drag and grade corrections.</li> </ul>"},{"location":"SINGLE_TRACK_MODEL/#2-lateral-limit","title":"2. Lateral Limit","text":"<p>At speed \\(v\\) and banking angle \\(\\beta\\), the model solves lateral capacity by a fixed-point iteration because normal load and lateral force depend on the lateral-acceleration estimate itself [1, Ch. 10].</p> <p>Given current iterate \\(a_y^{(k)}\\):</p> <ol> <li>Estimate axle loads from quasi-static vertical balance and load transfer.</li> <li>Evaluate axle lateral forces at representative peak slip angle    \\(\\alpha_\\text{peak}\\).</li> <li>Update the lateral limit with banking contribution. The dependence on the    previous iterate is carried by the axle normal loads used in tire-force    evaluation:</li> </ol> \\[ a_y^{(k+1)} = \\max\\left( a_{y,\\min}, \\frac{2F_y\\!\\left(\\alpha_\\text{peak}, F_{z,f}\\!\\left(a_y^{(k)}\\right)/2\\right) + 2F_y\\!\\left(\\alpha_\\text{peak}, F_{z,r}\\!\\left(a_y^{(k)}\\right)/2\\right)}{m} + g\\sin\\beta \\right). \\] <p>Equivalently, writing axle-level lateral forces explicitly as \\(F_{y,f}^{(k)}\\) and \\(F_{y,r}^{(k)}\\):</p> \\[ a_y^{(k+1)} = \\max\\left(a_{y,\\min}, \\frac{F_{y,f}^{(k)} + F_{y,r}^{(k)}}{m} + g\\sin\\beta\\right), \\] <p>with \\(F_{y,f}^{(k)}, F_{y,r}^{(k)}\\) computed from \\(F_{z,f}(a_y^{(k)})\\) and \\(F_{z,r}(a_y^{(k)})\\) [1, Ch. 10].</p> <p>Stop criterion:</p> \\[ \\left|a_y^{(k+1)} - a_y^{(k)}\\right| \\le \\text{tol}_y \\] <p>or max iteration count.</p>"},{"location":"SINGLE_TRACK_MODEL/#3-lateral-tire-force-model-pacejka","title":"3. Lateral Tire Force Model (Pacejka)","text":"<p>Each axle force is the sum of two equivalent tires:</p> \\[ F_{y,f} = 2\\,F_y(\\alpha_f, F_{z,f}/2), \\quad F_{y,r} = 2\\,F_y(\\alpha_r, F_{z,r}/2). \\] <p>Per-tire Pacejka-style lateral force:</p> \\[ F_y = D\\left(\\frac{F_z}{F_{z,\\text{ref}}}\\right)\\mu_\\text{scale}(F_z)\\sin\\left(C\\,\\arctan\\left(\\xi\\right)\\right), \\] \\[ \\xi = B\\alpha - E\\left(B\\alpha - \\arctan(B\\alpha)\\right), \\] <p>with load sensitivity factor:</p> \\[ \\mu_\\text{scale}(F_z) = \\max\\left(1 + s\\,\\frac{F_z - F_{z,\\text{ref}}}{F_{z,\\text{ref}}},\\ \\mu_{\\min}\\right). \\] <p>Here, \\(D\\) is the peak lateral force at the reference load \\(F_{z,\\text{ref}}\\) with unit newton [1], [2].</p>"},{"location":"SINGLE_TRACK_MODEL/#4-quasi-static-normal-loads","title":"4. Quasi-Static Normal Loads","text":"<p>Total vertical load:</p> \\[ F_{z,\\text{tot}} = mg + F_\\text{down}(v), \\quad F_\\text{down}(v)=\\tfrac{1}{2}\\rho C_L A v^2. \\] <p>Front axle raw load with longitudinal transfer:</p> \\[ F_{z,f}^\\text{raw} = mg\\,\\phi_f + F_{\\text{down},f} - \\frac{m a_x h}{L}. \\] <p>Rear axle load follows from equilibrium:</p> \\[ F_{z,r} = F_{z,\\text{tot}} - F_{z,f}. \\] <p>Lateral transfer is distributed by effective front roll-stiffness share and split to left/right wheel loads while preserving axle totals [1, Ch. 9], [3].</p>"},{"location":"SINGLE_TRACK_MODEL/#5-longitudinal-limits-with-friction-circle","title":"5. Longitudinal Limits with Friction Circle","text":"<p>For required lateral acceleration magnitude \\(|a_{y,\\text{req}}|\\):</p> \\[ \\lambda = \\sqrt{\\max\\left(0,\\ 1 - \\left(\\frac{|a_{y,\\text{req}}|}{a_{y,\\text{lim}}}\\right)^2\\right)}. \\] <p>Drive and brake envelopes:</p> \\[ a_{x,\\text{drive}} = a_{x,\\text{drive,max}}\\,\\lambda,\\quad a_{x,\\text{brake}} = a_{x,\\text{brake,max}}\\,\\lambda. \\] <p>Net along-track acceleration:</p> \\[ a_{x,\\text{net}} = a_{x,\\text{drive}} - \\frac{D(v)}{m} - g\\gamma, \\] <p>available deceleration magnitude:</p> \\[ a_{x,\\text{decel,avail}} = \\max\\left(a_{x,\\text{brake}} + \\frac{D(v)}{m} + g\\gamma,\\ 0\\right), \\] <p>with</p> \\[ D(v)=\\tfrac{1}{2}\\rho C_D A v^2. \\] <p>The coupling above follows the common friction-circle approximation used in race-vehicle performance analysis [3].</p>"},{"location":"SINGLE_TRACK_MODEL/#6-diagnostics","title":"6. Diagnostics","text":"<p>The backend reports at each operating point:</p> <ul> <li>yaw moment according to solver-mode semantics:</li> <li>quasi-static mode: zero by steady-state model assumption,</li> <li>transient mode: dynamic residual [ M_z = I_z \\dot r, ]</li> <li>front and rear axle normal loads,</li> <li>tractive power:</li> </ul> \\[ P = \\left(m a_x + D(v)\\right)v. \\] <p>The solver uses quasi-steady envelopes for speed profile generation; the 3-DOF single-track dynamics model is used primarily for physically meaningful analysis diagnostics (e.g., yaw-moment traces).</p>"},{"location":"SINGLE_TRACK_MODEL/#7-equation-to-code-mapping","title":"7. Equation-to-Code Mapping","text":"<ul> <li>lateral limit fixed-point:   <code>SingleTrackModel.lateral_accel_limit(...)</code></li> <li>Pacejka lateral force:   <code>magic_formula_lateral(...)</code></li> <li>normal-load estimation:   <code>estimate_normal_loads(...)</code></li> <li>friction-circle scaling:   <code>EnvelopeVehicleModel._friction_circle_scale(...)</code></li> <li>longitudinal accel/decel:   <code>SingleTrackModel.max_longitudinal_accel(...)</code>,   <code>SingleTrackModel.max_longitudinal_decel(...)</code></li> <li>diagnostics:   <code>SingleTrackModel.diagnostics(...)</code>, <code>SingleTrackDynamicsModel.force_balance(...)</code></li> </ul>"},{"location":"SINGLE_TRACK_MODEL/#8-example","title":"8. Example","text":"<ul> <li>Single-track standalone usage:   <code>examples/spa/spa_lap_single_track.py</code></li> <li>Side-by-side comparison against point-mass model:   <code>examples/spa/spa_model_comparison.py</code></li> </ul>"},{"location":"SINGLE_TRACK_MODEL/#references","title":"References","text":"<p>[1] D. Schramm, M. Hiller, and R. Bardini, Vehicle Dynamics: Modeling and Simulation. Berlin, Heidelberg: Springer, 2014.</p> <p>[2] H. B. Pacejka, Tyre and Vehicle Dynamics, 2nd ed. Oxford: Butterworth-Heinemann, 2006.</p> <p>[3] W. F. Milliken and D. L. Milliken, Race Car Vehicle Dynamics. Warrendale, PA: Society of Automotive Engineers, 1995.</p>"},{"location":"SOLVER/","title":"Solver Mathematics","text":"<p>This document explains the two solver modes available through <code>simulate_lap(track, model, config)</code>:</p> <ul> <li>quasi-static speed-profile solver (<code>solver_mode=\"quasi_static\"</code>)</li> <li>transient dynamic solver (<code>solver_mode=\"transient_oc\"</code>)</li> </ul> <p>Sections 1-10 cover the quasi-static formulation implemented in the shared core (<code>src/apexsim/simulation/_profile_core.py</code>) and backend adapters (<code>src/apexsim/simulation/profile.py</code>, <code>src/apexsim/simulation/torch_profile.py</code>). Section 11 summarizes the transient formulations (<code>src/apexsim/simulation/transient_*.py</code>).</p> <p>The underlying equations are based on standard vehicle-dynamics and lap-time simulation formulations [1], [3].</p>"},{"location":"SOLVER/#1-discretization-and-state","title":"1. Discretization and State","text":"<p>The track is represented in arc-length domain by points \\(i = 0,\\dots,N-1\\) with:</p> <ul> <li>position \\((s_i)\\) [m]</li> <li>curvature \\(\\kappa_i\\) [1/m]</li> <li>grade \\(\\gamma_i = dz/ds\\) [-]</li> <li>banking angle \\(\\beta_i\\) [rad]</li> </ul> <p>Segment length: [ \\Delta s_i = s_{i+1} - s_i, \\quad i=0,\\dots,N-2. ]</p> <p>The solver computes a speed profile \\(v_i\\) [m/s], then derives:</p> <ul> <li>longitudinal acceleration \\(a_{x,i}\\) [m/s\u00b2]</li> <li>lateral acceleration \\(a_{y,i}\\) [m/s\u00b2]</li> <li>lap time \\(T\\) [s]</li> </ul>"},{"location":"SOLVER/#2-lateral-envelope-cornering-limit","title":"2. Lateral Envelope (Cornering Limit)","text":"<p>A lateral speed limit \\(v_{\\text{lat},i}\\) is computed at each point. Core relation: [ |a_{y,i}| = v_i^2 |\\kappa_i|. ]</p> <p>Given lateral acceleration capacity \\(a_{y,\\text{lim},i}\\): [ v_{\\text{lat},i} = \\begin{cases} \\sqrt{a_{y,\\text{lim},i}/|\\kappa_i|}, &amp; |\\kappa_i| &gt; \\varepsilon \\ v_{\\max}, &amp; |\\kappa_i| \\le \\varepsilon \\end{cases} ] with clipping to \\([v_{\\min}, v_{\\max}]\\).</p>"},{"location":"SOLVER/#21-lateral-acceleration-capacity","title":"2.1 Lateral Acceleration Capacity","text":"<p><code>SingleTrackModel.lateral_accel_limit(...)</code> solves a fixed-point problem because tire force capacity depends on normal load, and normal load depends on lateral acceleration through load transfer. This is the quasi-steady coupled load-transfer/tire-force formulation described in [1, Ch. 10].</p> <p>For fixed speed \\(v\\):</p> <ol> <li>Estimate axle loads from quasi-static vertical balance using current \\(a_y\\) guess.</li> <li>Compute front/rear lateral tire forces at a representative peak slip angle    (Pacejka Magic Formula).</li> <li>Update lateral limit: [ a_{y,\\text{next}} = \\max\\left(a_{y,\\min}, \\frac{F_{y,f}+F_{y,r}}{m} + g\\sin\\beta\\right). ]</li> <li>Repeat until \\(|a_{y,\\text{next}}-a_{y,\\text{current}}|\\le\\text{tol}\\) or max iterations.</li> </ol>"},{"location":"SOLVER/#3-longitudinal-coupling-via-friction-circle","title":"3. Longitudinal Coupling via Friction Circle","text":"<p>Available longitudinal capability is reduced by lateral usage: [ \\lambda_i = \\sqrt{\\max\\left(0, 1 - \\left(\\frac{|a_{y,\\text{req},i}|}{a_{y,\\text{lim},i}}\\right)^2\\right)}, \\quad |a_{y,\\text{req},i}| = v_i^2 |\\kappa_i|. ]</p> <ul> <li>Drive limit: \\(a_{x,\\text{drive},i} = a_{x,\\text{drive,max}}\\,\\lambda_i\\)</li> <li>Brake limit: \\(a_{x,\\text{brake},i} = a_{x,\\text{brake,max}}\\,\\lambda_i\\)</li> </ul> <p>This is a simplified isotropic friction-circle approximation. It follows the standard combined-acceleration envelope approximation used in race-car analysis [3].</p>"},{"location":"SOLVER/#4-forward-pass-acceleration-limited","title":"4. Forward Pass (Acceleration-Limited)","text":"<p>Starting from \\(v_0\\), propagate forward with kinematic relation: [ v_{i+1}^2 = v_i^2 + 2 a_{x,\\text{net},i} \\Delta s_i. ]</p> <p>Initial-condition rule: [ v_0 = \\min\\left(v_{\\text{lat},0}, v_{\\max}, v_{\\text{init}}\\right), ] where \\(v_{\\text{init}}\\) is:</p> <ul> <li><code>RuntimeConfig.initial_speed</code>, if provided.</li> <li>otherwise the legacy fallback \\(v_{\\max}\\).</li> </ul> <p>Net acceleration model: [ a_{x,\\text{net},i} = a_{x,\\text{drive},i} - \\frac{D(v_i)}{m} - g\\,\\gamma_i, ] where drag force is [ D(v) = \\tfrac{1}{2}\\rho c_d A v^2. ] The aerodynamic force law follows [1], [3].</p> <p>Then enforce bounds: [ v_{i+1} \\leftarrow \\min(v_{i+1}, v_{\\text{lat},i+1}, v_{\\max}), \\quad v_{i+1} \\ge v_{\\min}. ]</p>"},{"location":"SOLVER/#5-backward-pass-braking-limited","title":"5. Backward Pass (Braking-Limited)","text":"<p>From the end of the lap backwards, enforce braking feasibility: [ v_i^2 = v_{i+1}^2 + 2 a_{x,\\text{decel,avail},i} \\Delta s_i, ] with [ a_{x,\\text{decel,avail},i} = a_{x,\\text{brake},i} + \\frac{D(v_{i+1})}{m} + g\\,\\gamma_{i+1}. ]</p> <p>Again clamp by lateral and global speed bounds.</p>"},{"location":"SOLVER/#6-final-accelerations-and-lap-time","title":"6. Final Accelerations and Lap Time","text":"<p>After forward/backward constraints, the final profile is \\(v_i\\). Longitudinal acceleration is reconstructed by finite differences: [ a_{x,i} = \\frac{v_{i+1}^2 - v_i^2}{2\\Delta s_i}, \\quad i=0,\\dots,N-2. ]</p> <p>Lateral acceleration: [ a_{y,i} = v_i^2\\kappa_i. ]</p> <p>Segment time is approximated with average segment speed: [ \\Delta t_i = \\frac{\\Delta s_i}{\\max\\left(\\tfrac{v_i+v_{i+1}}{2}, \\varepsilon_v\\right)}. ]</p> <p>Total lap time: [ T = \\sum_{i=0}^{N-2} \\Delta t_i. ]</p>"},{"location":"SOLVER/#7-numerical-convergence-controls","title":"7. Numerical Convergence Controls","text":"<p>Lateral envelope convergence in <code>solve_speed_profile(...)</code> is configurable via <code>SimulationConfig.numerics</code>:</p> <ul> <li><code>lateral_envelope_max_iterations</code></li> <li><code>lateral_envelope_convergence_tolerance</code></li> </ul> <p>Stop criterion: [ \\max_i |v^{(k)}{\\text{lat},i} - v^{(k-1)}{\\text{lat},i}| \\le \\text{tol}_v. ]</p> <p>The actual number of iterations used is reported as <code>SpeedProfileResult.lateral_envelope_iterations</code>.</p>"},{"location":"SOLVER/#8-physical-scope-and-limitations","title":"8. Physical Scope and Limitations","text":"<p>Quasi-static mode is intentionally envelope-based:</p> <ul> <li>No transient tire relaxation dynamics.</li> <li>No explicit driver/controller model in the speed-profile pass.</li> <li>Longitudinal limits are envelope-based constants (drive/brake maxima).</li> <li>Tire model uses fixed representative peak slip-angle for envelope estimation.</li> </ul> <p>These simplifications keep the solver fast and stable, while preserving core constraints for lap-time studies.</p> <p>The same solver routine can be used with different backends implementing <code>VehicleModel</code>, including the single-track and point-mass models.</p>"},{"location":"SOLVER/#81-yaw-moment-output-semantics","title":"8.1 Yaw-Moment Output Semantics","text":"<p><code>LapResult.yaw_moment</code> is reported with solver-mode-consistent semantics:</p> <ul> <li>quasi-static mode: the model is solved in steady-state envelope form, so   yaw-moment output is set to zero by assumption.</li> <li>transient mode: yaw moment is reported as the dynamic residual [ M_z = I_z \\dot r, ] with yaw acceleration \\(\\dot r\\) reconstructed from transient yaw-rate and time traces.</li> </ul> <p>For steady-state cornering this residual should approach zero in the interior of the lap (excluding seam transients), which provides a direct stability and convergence indicator.</p>"},{"location":"SOLVER/#9-equation-to-code-mapping","title":"9. Equation-to-Code Mapping","text":"<ul> <li>\\(a_{y,i} = v_i^2\\kappa_i\\):</li> <li><code>src/apexsim/simulation/_profile_core.py</code> (<code>solve_speed_profile_core</code>)</li> <li>\\(v_{\\text{lat},i} = \\sqrt{a_{y,\\text{lim},i}/|\\kappa_i|}\\) (with clipping):</li> <li><code>src/apexsim/simulation/_profile_core.py</code> (<code>lateral_speed_limit_core</code>)</li> <li>Friction-circle scaling \\(\\lambda_i\\) (vehicle-model dependent):</li> <li><code>src/apexsim/vehicle/single_track_model.py</code> (<code>_friction_circle_scale</code>)</li> <li>Forward pass \\(v_{i+1}^2 = v_i^2 + 2a\\Delta s\\):</li> <li><code>src/apexsim/simulation/_profile_core.py</code> (<code>solve_speed_profile_core</code>)</li> <li>Backward pass braking feasibility:</li> <li><code>src/apexsim/simulation/_profile_core.py</code> (<code>solve_speed_profile_core</code>)</li> <li>Lap-time accumulation \\(T = \\sum \\Delta t_i\\):</li> <li><code>src/apexsim/simulation/_profile_core.py</code> (<code>solve_speed_profile_core</code>)</li> <li>Segment time model \\(\\Delta t_i = \\Delta s_i / \\bar v_i\\):</li> <li><code>src/apexsim/simulation/_profile_core.py</code> (<code>solve_speed_profile_core</code>)</li> <li>Lateral limit fixed-point update:</li> <li><code>src/apexsim/vehicle/single_track_model.py</code> (<code>lateral_accel_limit</code>)</li> <li>Lateral envelope fixed-point convergence in speed domain:</li> <li><code>src/apexsim/simulation/_profile_core.py</code> (<code>solve_speed_profile_core</code>)</li> <li>Vehicle-model API contract consumed by the solver:</li> <li><code>src/apexsim/simulation/model_api.py</code> (<code>VehicleModel</code>)</li> <li><code>src/apexsim/simulation/profile.py</code> and <code>src/apexsim/simulation/torch_profile.py</code>     (backend adapters calling shared core)</li> </ul>"},{"location":"SOLVER/#10-differentiable-torch-solver-api","title":"10. Differentiable Torch Solver API","text":"<p>For gradient-based workflows (e.g. autodiff sensitivities), ApexSim exposes:</p> <ul> <li><code>apexsim.simulation.solve_speed_profile_torch(track, model, config)</code></li> </ul> <p>This API returns tensor-valued outputs (<code>TorchSpeedProfileResult</code>) and keeps the autograd graph intact for downstream <code>backward()</code> calls.</p> <p>Current constraint:</p> <ul> <li><code>RuntimeConfig.torch_compile</code> must be <code>False</code> for   <code>solve_speed_profile_torch</code>.</li> </ul>"},{"location":"SOLVER/#11-transient-solver-mathematics","title":"11. Transient Solver Mathematics","text":"<p>Transient mode supports two driver/control strategies over fixed track arc-length samples:</p> <ul> <li><code>driver_model=\"pid\"</code> (default): closed-loop PID driver tracking a quasi-static   reference profile.</li> <li><code>driver_model=\"optimal_control\"</code>: minimum-time optimal-control formulation.</li> </ul> <p>The OC objective is: [ \\min_{u} \\; T + w_{\\text{lat}} J_{\\text{lat}} + w_{\\text{trk}} J_{\\text{trk}} + w_{\\text{sm}} J_{\\text{sm}}. ]</p>"},{"location":"SOLVER/#111-state-and-controls","title":"11.1 State and controls","text":"<ul> <li>Point-mass transient state: [ x_i = [v_i] ]</li> <li>Single-track transient state: [ x_i = [v_{x,i}, v_{y,i}, r_i] ] where \\(r\\) is yaw rate.</li> </ul> <p>Controls:</p> <ul> <li>Point-mass: longitudinal command \\(a_{x,\\text{cmd},i}\\).</li> <li>Single-track: \\(a_{x,\\text{cmd},i}\\) and steering command \\(\\delta_i\\).</li> </ul> <p>Single-track control bounds are physical model inputs:</p> <ul> <li><code>SingleTrackPhysics.max_steer_angle</code></li> <li><code>SingleTrackPhysics.max_steer_rate</code></li> </ul>"},{"location":"SOLVER/#112-dynamics-propagation","title":"11.2 Dynamics propagation","text":"<p>Arc-length segments are converted to physical segment travel times: [ \\Delta t_i = \\max\\left(\\frac{\\Delta s_i}{\\max(|v_i|,\\varepsilon_v)},\\; \\Delta t_{\\min}\\right). ] <code>max_time_step</code> is then applied as an integration-substep cap only: [ n_i = \\left\\lceil \\frac{\\Delta t_i}{\\Delta t_{\\max}} \\right\\rceil,\\quad \\delta t_i = \\frac{\\Delta t_i}{\\max(n_i, 1)}. ]</p> <p>Point-mass update: [ v_{i+1} = \\operatorname{clip}(v_i + a_{x,\\text{net},i}\\Delta t_i, 0, v_{\\max}). ]</p> <p>Single-track update uses Euler or RK4 integration of: [ \\dot{x} = f(x, u), ] with a 3-DOF single-track dynamic model. The state-space structure matches the single-track equations in [1, Ch. 10].</p>"},{"location":"SOLVER/#113-constraint-penalties-and-objective-terms","title":"11.3 Constraint penalties and objective terms","text":"<p>The transient objective combines:</p> <ul> <li>lap-time term \\(T\\),</li> <li>lateral-feasibility penalty \\(J_{\\text{lat}}\\),</li> <li>single-track tracking penalty \\(J_{\\text{trk}}\\),</li> <li>control smoothness penalty \\(J_{\\text{sm}}\\).</li> </ul> <p>Penalty weights come from <code>TransientNumericsConfig</code>:</p> <ul> <li><code>lateral_constraint_weight</code></li> <li><code>tracking_weight</code></li> <li><code>control_smoothness_weight</code></li> </ul>"},{"location":"SOLVER/#114-backend-strategies","title":"11.4 Backend strategies","text":"<ul> <li>NumPy: SciPy optimizer with transient simulation core.</li> <li>Numba: numba backend dispatch with shared transient core semantics.</li> <li>Torch: differentiable transient graph plus torch optimizer and <code>torchdiffeq</code>.</li> </ul> <p>All modes are accessed through the same public runner:</p> <pre><code>result = simulate_lap(track=track, model=model, config=config)\n</code></pre> <p>Transient mode adds time/state/control traces in <code>LapResult</code>:</p> <ul> <li><code>time</code></li> <li><code>vx</code>, <code>vy</code>, <code>yaw_rate</code></li> <li><code>steer_cmd</code>, <code>ax_cmd</code></li> </ul>"},{"location":"SOLVER/#115-pid-gain-scheduling","title":"11.5 PID Gain Scheduling","text":"<p>The default transient driver is PID. ApexSim supports optional speed-dependent gain scheduling with piecewise-linear (PWL) tables: [ k(v) = \\operatorname{interp}(v;\\, v_{\\text{nodes}}, k_{\\text{nodes}}) ] with boundary clamping at the first/last node.</p> <p>Scheduling modes in <code>TransientNumericsConfig</code>:</p> <ul> <li><code>off</code>: scalar gains only (legacy-compatible behavior).</li> <li><code>physics_informed</code>: deterministic schedule generated from vehicle physics.</li> <li><code>custom</code>: user-provided <code>TransientPidGainSchedulingConfig</code>.</li> </ul>"},{"location":"SOLVER/#116-optimal-control-quality-gate","title":"11.6 Optimal-Control Quality Gate","text":"<p>For <code>driver_model=\"optimal_control\"</code>, ApexSim applies a hard fail-fast policy:</p> <ul> <li>if the optimizer does not converge, <code>simulate_lap(...)</code> raises   <code>ConfigurationError</code> (no silent fallback),</li> <li>if the final transient profile is non-finite, <code>simulate_lap(...)</code> raises   <code>ConfigurationError</code>.</li> </ul> <p>Validation is additionally enforced by regression tests that require OC to match quasi-static reference behavior on simple straight/circle scenarios within the same consistency thresholds used for transient PID checks.</p> <p>Physics-informed longitudinal scaling at node \\(v_j\\): [ a_+(v_j) = a_{x,\\max}(v_j, a_y=0, \\theta=0, \\beta=0), \\quad a_-(v_j) = a_{x,\\min}(v_j, a_y=0, \\theta=0, \\beta=0), ] [ a_{\\text{eff}}(v_j) = \\frac{a_+(v_j) + a_-(v_j)}{2}, \\quad s_a(v_j) = \\frac{a_{\\text{eff}}(v_j)}{a_{\\text{eff}}(v_{\\text{ref}})}. ] The scheduled gains are: [ k_{p,\\text{long}}(v_j) = k_{p,0}\\,\\operatorname{clip}(s_a, s_{\\min}, s_{\\max}), ] [ k_{i,\\text{long}}(v_j) = k_{i,0}\\,\\operatorname{clip}(s_a, s_{\\min}, s_{\\max}), ] [ k_{d,\\text{long}}(v_j) = k_{d,0}\\,\\operatorname{clip}(\\sqrt{s_a}, s_{d,\\min}, s_{d,\\max}). ]</p> <p>Single-track steering scaling uses speed normalization: [ s_v(v_j) = \\frac{v_{\\text{ref}}}{\\max(v_j, v_{\\min})}. ] This yields: [ k_{p,\\delta}(v_j) = k_{p,0}\\,\\operatorname{clip}(s_v, s_{kp,\\min}, s_{kp,\\max}), ] [ k_{i,\\delta}(v_j) = k_{i,0}\\,\\operatorname{clip}(s_v, s_{ki,\\min}, s_{ki,\\max}), ] [ k_{d,\\delta}(v_j) = k_{d,0}\\,\\operatorname{clip}(\\sqrt{s_v}, s_{kd,\\min}, s_{kd,\\max}), ] [ k_{v_y}(v_j) = k_{v_y,0}\\,\\operatorname{clip}!\\left( 1 + c_{v_y}\\frac{v_j}{v_{\\text{ref}}}, s_{vy,\\min}, s_{vy,\\max} \\right). ]</p> <p>Default node set: [ v_{\\text{nodes}} = (0,\\,10,\\,20,\\,35,\\,55,\\,v_{\\max})\\ \\text{m/s} ] (intermediate nodes above \\(v_{\\max}\\) are omitted).</p> <p>Rationale:</p> <ul> <li>Longitudinal gains rise with available traction/braking authority.</li> <li>Steering gains decrease with speed because yaw response sensitivity grows.</li> <li>Lateral-velocity damping increases with speed to stabilize transient sideslip.</li> </ul>"},{"location":"SOLVER/#references","title":"References","text":"<p>[1] D. Schramm, M. Hiller, and R. Bardini, Vehicle Dynamics: Modeling and Simulation. Berlin, Heidelberg: Springer, 2014.</p> <p>[2] H. B. Pacejka, Tyre and Vehicle Dynamics, 2nd ed. Oxford: Butterworth-Heinemann, 2006.</p> <p>[3] W. F. Milliken and D. L. Milliken, Race Car Vehicle Dynamics. Warrendale, PA: Society of Automotive Engineers, 1995.</p>"},{"location":"examples/sensitivity/","title":"Sensitivity Examples","text":"<p>These examples focus on practical interpretation of parameter sensitivities with the single-track model on the torch backend and the high-level <code>apexsim.analysis.run_lap_sensitivity_study(...)</code> API.</p>"},{"location":"examples/sensitivity/#study-scope","title":"Study scope","text":"<p>Both example studies use local derivatives around one operating point and report an engineering-friendly <code>%/%</code> interpretation. The same four physical parameters are included:</p> <ol> <li>Vehicle mass</li> <li>Center of gravity height</li> <li>Yaw inertia</li> <li>Drag coefficient</li> </ol> <p>Two objective metrics are evaluated:</p> <ol> <li>Lap time \\([s]\\)</li> <li>Energy consumption \\([kWh]\\)</li> </ol>"},{"location":"examples/sensitivity/#why-this-setup-is-useful","title":"Why this setup is useful","text":"<ul> <li>It gives a consistent sensitivity baseline across different track classes.</li> <li>It highlights which parameters matter globally (lap time) vs. energetically.</li> <li>It uses one compact, model-agnostic API with clear parameter targets.</li> <li>The Spa notebook additionally compares quasi-static and transient sensitivities   in an AD-first workflow to expose solver-path limitations (notably for yaw inertia).</li> </ul>"},{"location":"examples/sensitivity/#output-artifacts","title":"Output artifacts","text":"<p>Each study exports:</p> <ul> <li><code>sensitivities_long.csv</code>: one row per <code>(objective, parameter)</code> pair</li> <li><code>sensitivities_pivot.csv</code>: compact parameter \u00d7 objective sensitivity map</li> <li><code>sensitivity_bars.png</code>: compact comparison plot for both objectives</li> </ul> <p>All outputs are written below:</p> <ul> <li><code>examples/output/sensitivity/</code></li> </ul>"},{"location":"examples/sensitivity/#notebooks","title":"Notebooks","text":"<ol> <li>Synthetic Single-Track Sensitivity</li> <li>Spa Single-Track Sensitivity</li> </ol>"},{"location":"examples/sensitivity/spa_single_track_sensitivity/","title":"Spa Single-Track","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\n\nfrom pathlib import Path\nimport sys\n\nimport pandas as pd\n\n\ndef find_repo_root(start: Path) -&gt; Path:\n    for candidate in (start, *start.parents):\n        if (candidate / \"pyproject.toml\").exists() and (candidate / \"src\").exists():\n            return candidate\n    raise RuntimeError(\"Could not locate repository root from current working directory\")\n\n\nrepo_root = find_repo_root(Path.cwd())\nif str(repo_root) not in sys.path:\n    sys.path.insert(0, str(repo_root))\n\nexamples_sensitivity = repo_root / \"examples\" / \"sensitivity\"\nif str(examples_sensitivity) not in sys.path:\n    sys.path.insert(0, str(examples_sensitivity))\n\nfrom apexsim.analysis import SensitivityStudyParameter\nfrom apexsim.simulation import (\n    TransientConfig,\n    TransientNumericsConfig,\n    TransientRuntimeConfig,\n    build_simulation_config,\n)\nfrom apexsim.track import load_track_csv\nfrom common import (\n    build_solver_comparison_table,\n    example_vehicle_parameters,\n    plot_yaw_inertia_solver_comparison,\n    run_single_track_sensitivity_study,\n    sensitivity_output_root,\n    spa_track_path,\n)\n\npd.set_option(\"display.max_columns\", 60)\npd.set_option(\"display.width\", 200)\n\nfrom apexsim.vehicle import SingleTrackPhysics\n</pre> from __future__ import annotations  from pathlib import Path import sys  import pandas as pd   def find_repo_root(start: Path) -&gt; Path:     for candidate in (start, *start.parents):         if (candidate / \"pyproject.toml\").exists() and (candidate / \"src\").exists():             return candidate     raise RuntimeError(\"Could not locate repository root from current working directory\")   repo_root = find_repo_root(Path.cwd()) if str(repo_root) not in sys.path:     sys.path.insert(0, str(repo_root))  examples_sensitivity = repo_root / \"examples\" / \"sensitivity\" if str(examples_sensitivity) not in sys.path:     sys.path.insert(0, str(examples_sensitivity))  from apexsim.analysis import SensitivityStudyParameter from apexsim.simulation import (     TransientConfig,     TransientNumericsConfig,     TransientRuntimeConfig,     build_simulation_config, ) from apexsim.track import load_track_csv from common import (     build_solver_comparison_table,     example_vehicle_parameters,     plot_yaw_inertia_solver_comparison,     run_single_track_sensitivity_study,     sensitivity_output_root,     spa_track_path, )  pd.set_option(\"display.max_columns\", 60) pd.set_option(\"display.width\", 200)  from apexsim.vehicle import SingleTrackPhysics  In\u00a0[\u00a0]: Copied! <pre>variation_pct = 10.0\n\ntrack = load_track_csv(spa_track_path())\nparameter_definitions = [\n    SensitivityStudyParameter(name=\"mass\", target=\"vehicle.mass\", label=\"Vehicle mass\"),\n    SensitivityStudyParameter(name=\"cg_height\", target=\"vehicle.cg_height\", label=\"Center of gravity height\"),\n    SensitivityStudyParameter(name=\"yaw_inertia\", target=\"vehicle.yaw_inertia\", label=\"Yaw inertia\"),\n    SensitivityStudyParameter(name=\"drag_coefficient\", target=\"vehicle.drag_coefficient\", label=\"Drag coefficient\"),\n]\n\nroot_output_dir = sensitivity_output_root() / \"spa_single_track\"\nquasi_output_dir = root_output_dir / \"quasi_static\"\ntransient_output_dir = root_output_dir / \"transient_pid_ad\"\n\nstudy_physics = SingleTrackPhysics(\n    max_steer_angle=0.3,\n    max_steer_rate=2.0,\n    reference_mass=example_vehicle_parameters().mass,\n)\n\nquasi_simulation_config = build_simulation_config(\n    compute_backend=\"torch\",\n    torch_device=\"cpu\",\n    torch_compile=False,\n    max_speed=115.0,\n)\n\ntransient_simulation_config = build_simulation_config(\n    compute_backend=\"torch\",\n    torch_device=\"cpu\",\n    torch_compile=False,\n    max_speed=115.0,\n    initial_speed=12.0,\n    solver_mode=\"transient_oc\",\n    transient=TransientConfig(\n        numerics=TransientNumericsConfig(max_time_step=1.0),\n        runtime=TransientRuntimeConfig(driver_model=\"pid\", verbosity=0),\n    ),\n)\n\npd.DataFrame(\n    {\n        \"parameter\": [p.name for p in parameter_definitions],\n        \"target\": [p.target for p in parameter_definitions],\n        \"variation_used\": [f\"+/-{variation_pct:.0f}%\"] * len(parameter_definitions),\n    }\n)\n</pre> variation_pct = 10.0  track = load_track_csv(spa_track_path()) parameter_definitions = [     SensitivityStudyParameter(name=\"mass\", target=\"vehicle.mass\", label=\"Vehicle mass\"),     SensitivityStudyParameter(name=\"cg_height\", target=\"vehicle.cg_height\", label=\"Center of gravity height\"),     SensitivityStudyParameter(name=\"yaw_inertia\", target=\"vehicle.yaw_inertia\", label=\"Yaw inertia\"),     SensitivityStudyParameter(name=\"drag_coefficient\", target=\"vehicle.drag_coefficient\", label=\"Drag coefficient\"), ]  root_output_dir = sensitivity_output_root() / \"spa_single_track\" quasi_output_dir = root_output_dir / \"quasi_static\" transient_output_dir = root_output_dir / \"transient_pid_ad\"  study_physics = SingleTrackPhysics(     max_steer_angle=0.3,     max_steer_rate=2.0,     reference_mass=example_vehicle_parameters().mass, )  quasi_simulation_config = build_simulation_config(     compute_backend=\"torch\",     torch_device=\"cpu\",     torch_compile=False,     max_speed=115.0, )  transient_simulation_config = build_simulation_config(     compute_backend=\"torch\",     torch_device=\"cpu\",     torch_compile=False,     max_speed=115.0,     initial_speed=12.0,     solver_mode=\"transient_oc\",     transient=TransientConfig(         numerics=TransientNumericsConfig(max_time_step=1.0),         runtime=TransientRuntimeConfig(driver_model=\"pid\", verbosity=0),     ), )  pd.DataFrame(     {         \"parameter\": [p.name for p in parameter_definitions],         \"target\": [p.target for p in parameter_definitions],         \"variation_used\": [f\"+/-{variation_pct:.0f}%\"] * len(parameter_definitions),     } )  In\u00a0[\u00a0]: Copied! <pre>quasi_long_df, quasi_pivot_df = run_single_track_sensitivity_study(\n    track=track,\n    track_label=\"Spa-Francorchamps\",\n    output_dir=quasi_output_dir,\n    simulation_config=quasi_simulation_config,\n    parameters=parameter_definitions,\n    physics=study_physics,\n)\n\nquasi_long_df[[\n    \"objective\",\n    \"parameter_label\",\n    \"sensitivity_raw\",\n    \"absolute_delta_plus\",\n    \"absolute_delta_minus\",\n]].sort_values([\"objective\", \"parameter_label\"], kind=\"stable\")\n</pre> quasi_long_df, quasi_pivot_df = run_single_track_sensitivity_study(     track=track,     track_label=\"Spa-Francorchamps\",     output_dir=quasi_output_dir,     simulation_config=quasi_simulation_config,     parameters=parameter_definitions,     physics=study_physics, )  quasi_long_df[[     \"objective\",     \"parameter_label\",     \"sensitivity_raw\",     \"absolute_delta_plus\",     \"absolute_delta_minus\", ]].sort_values([\"objective\", \"parameter_label\"], kind=\"stable\")  In\u00a0[\u00a0]: Copied! <pre>transient_long_df, transient_pivot_df = run_single_track_sensitivity_study(\n    track=track,\n    track_label=\"Spa-Francorchamps (transient PID + autodiff)\",\n    output_dir=transient_output_dir,\n    simulation_config=transient_simulation_config,\n    parameters=parameter_definitions,\n    physics=study_physics,\n)\n\ntransient_long_df[[\n    \"objective\",\n    \"parameter_label\",\n    \"sensitivity_raw\",\n    \"absolute_delta_plus\",\n    \"absolute_delta_minus\",\n]].sort_values([\"objective\", \"parameter_label\"], kind=\"stable\")\n</pre> transient_long_df, transient_pivot_df = run_single_track_sensitivity_study(     track=track,     track_label=\"Spa-Francorchamps (transient PID + autodiff)\",     output_dir=transient_output_dir,     simulation_config=transient_simulation_config,     parameters=parameter_definitions,     physics=study_physics, )  transient_long_df[[     \"objective\",     \"parameter_label\",     \"sensitivity_raw\",     \"absolute_delta_plus\",     \"absolute_delta_minus\", ]].sort_values([\"objective\", \"parameter_label\"], kind=\"stable\")  In\u00a0[\u00a0]: Copied! <pre>comparison_df = build_solver_comparison_table(\n    quasi_static_long=quasi_long_df,\n    transient_long=transient_long_df,\n)\ncomparison_df.to_csv(root_output_dir / \"solver_comparison.csv\", index=False)\n\nplot_yaw_inertia_solver_comparison(\n    comparison_table=comparison_df,\n    path=root_output_dir / \"solver_comparison_yaw_inertia.png\",\n)\n\ncomparison_df[comparison_df[\"parameter\"] == \"yaw_inertia\"][[\n    \"objective\",\n    \"sensitivity_raw_quasi_static\",\n    \"sensitivity_raw_transient_pid_ad\",\n    \"absolute_delta_plus_quasi_static\",\n    \"absolute_delta_plus_transient_pid_ad\",\n    \"sensitivity_raw_change\",\n    \"absolute_delta_plus_change\",\n]]\n</pre> comparison_df = build_solver_comparison_table(     quasi_static_long=quasi_long_df,     transient_long=transient_long_df, ) comparison_df.to_csv(root_output_dir / \"solver_comparison.csv\", index=False)  plot_yaw_inertia_solver_comparison(     comparison_table=comparison_df,     path=root_output_dir / \"solver_comparison_yaw_inertia.png\", )  comparison_df[comparison_df[\"parameter\"] == \"yaw_inertia\"][[     \"objective\",     \"sensitivity_raw_quasi_static\",     \"sensitivity_raw_transient_pid_ad\",     \"absolute_delta_plus_quasi_static\",     \"absolute_delta_plus_transient_pid_ad\",     \"sensitivity_raw_change\",     \"absolute_delta_plus_change\", ]]"},{"location":"examples/sensitivity/spa_single_track_sensitivity/#spa-single-track-sensitivity-quasi-static-vs-transient","title":"Spa Single-Track Sensitivity: Quasi-Static vs Transient\u00b6","text":"<p>This notebook demonstrates how solver choice affects local sensitivity results. We run the same parameter study twice:</p> <ol> <li>Quasi-static speed-profile solver (torch backend, autodiff default)</li> <li>Transient PID solver (torch backend, autodiff sensitivities)</li> </ol> <p>The goal is to highlight why yaw-inertia sensitivity is often near zero in quasi-static studies and becomes visible in transient analyses.</p>"},{"location":"examples/sensitivity/spa_single_track_sensitivity/#1-engineering-question","title":"1. Engineering Question\u00b6","text":"<p>For Spa-Francorchamps, how do four physical parameters affect:</p> <ol> <li>Lap time</li> <li>Energy consumption</li> </ol> <p>Parameters:</p> <ol> <li>Vehicle mass</li> <li>CoG height</li> <li>Yaw inertia</li> <li>Drag coefficient</li> </ol>"},{"location":"examples/sensitivity/spa_single_track_sensitivity/#2-local-sensitivity-method","title":"2. Local Sensitivity Method\u00b6","text":"<p>For each objective $y$ and parameter $p_i$, we use local derivatives:</p> <p>$$ S_i = \\frac{\\partial y}{\\partial p_i} $$</p> <p>For interpretation at +10% variation:</p> <p>$$ \\Delta y_{+10\\%} \\approx S_i \\cdot (0.10 \\cdot p_{i,0}) $$</p> <p>We compare these deltas between quasi-static and transient solver paths.</p>"},{"location":"examples/sensitivity/spa_single_track_sensitivity/#3-solver-assumptions-and-expected-behavior","title":"3. Solver Assumptions and Expected Behavior\u00b6","text":"<ul> <li>Quasi-static solver neglects transient state dynamics, so parameters that primarily act through yaw transients (for example, yaw inertia) can appear weak.</li> <li>Transient PID solver evolves $v_x$, $v_y$, and yaw-rate states over the lap, so yaw-inertia effects can propagate into lap time and energy.</li> </ul> <p>This is a model-path comparison at one operating point, not a global design-space claim.</p>"},{"location":"examples/sensitivity/spa_single_track_sensitivity/#4-quasi-static-baseline-torch-ad-default","title":"4. Quasi-Static Baseline (Torch + AD default)\u00b6","text":""},{"location":"examples/sensitivity/spa_single_track_sensitivity/#5-transient-study-pid-autodiff","title":"5. Transient Study (PID + Autodiff)\u00b6","text":""},{"location":"examples/sensitivity/spa_single_track_sensitivity/#6-solver-comparison-and-yaw-inertia-focus","title":"6. Solver Comparison and Yaw-Inertia Focus\u00b6","text":"<p>Now we merge both tables and compare the same local derivatives across solver paths.</p>"},{"location":"examples/sensitivity/spa_single_track_sensitivity/#7-engineering-interpretation","title":"7. Engineering Interpretation\u00b6","text":"<ol> <li>If yaw-inertia sensitivity is near zero in the quasi-static run but non-zero in transient PID, the difference reflects solver-model assumptions, not a contradiction.</li> <li>Quasi-static remains useful for fast screening and trend studies.</li> <li>Transient analyses are preferred when control-rate limits and yaw-state dynamics materially influence the performance metric.</li> <li>For design decisions, use both views together: quasi-static for broad scanning, transient for dynamic-importance confirmation.</li> </ol>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/","title":"Synthetic Single-Track","text":"In\u00a0[\u00a0]: Copied! <pre>from __future__ import annotations\n\nfrom pathlib import Path\nimport sys\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\ndef find_repo_root(start: Path) -&gt; Path:\n    for candidate in (start, *start.parents):\n        if (candidate / \"pyproject.toml\").exists() and (candidate / \"src\").exists():\n            return candidate\n    raise RuntimeError(\"Could not locate repository root from current working directory\")\n\n\nrepo_root = find_repo_root(Path.cwd())\nif str(repo_root) not in sys.path:\n    sys.path.insert(0, str(repo_root))\n\nexamples_sensitivity = repo_root / \"examples\" / \"sensitivity\"\nif str(examples_sensitivity) not in sys.path:\n    sys.path.insert(0, str(examples_sensitivity))\n\nfrom apexsim.analysis import (\n        SensitivityStudyParameter,\n    run_lap_sensitivity_study,\n)\nfrom apexsim.simulation import build_simulation_config\nfrom apexsim.tire import default_axle_tire_parameters\nfrom apexsim.track import build_circular_track\nfrom apexsim.vehicle import SingleTrackPhysics, build_single_track_model\nfrom common import example_vehicle_parameters, sensitivity_output_root\n\npd.set_option(\"display.max_columns\", 40)\npd.set_option(\"display.width\", 180)\n</pre> from __future__ import annotations  from pathlib import Path import sys  import matplotlib.pyplot as plt import pandas as pd   def find_repo_root(start: Path) -&gt; Path:     for candidate in (start, *start.parents):         if (candidate / \"pyproject.toml\").exists() and (candidate / \"src\").exists():             return candidate     raise RuntimeError(\"Could not locate repository root from current working directory\")   repo_root = find_repo_root(Path.cwd()) if str(repo_root) not in sys.path:     sys.path.insert(0, str(repo_root))  examples_sensitivity = repo_root / \"examples\" / \"sensitivity\" if str(examples_sensitivity) not in sys.path:     sys.path.insert(0, str(examples_sensitivity))  from apexsim.analysis import (         SensitivityStudyParameter,     run_lap_sensitivity_study, ) from apexsim.simulation import build_simulation_config from apexsim.tire import default_axle_tire_parameters from apexsim.track import build_circular_track from apexsim.vehicle import SingleTrackPhysics, build_single_track_model from common import example_vehicle_parameters, sensitivity_output_root  pd.set_option(\"display.max_columns\", 40) pd.set_option(\"display.width\", 180) In\u00a0[\u00a0]: Copied! <pre>variation_pct = 10.0\n\ntrack = build_circular_track(radius=50.0, sample_count=721)\nvehicle = example_vehicle_parameters()\ntires = default_axle_tire_parameters()\nphysics = SingleTrackPhysics()\n\nsimulation_config = build_simulation_config(\n    compute_backend=\"torch\",\n    torch_device=\"cpu\",\n    torch_compile=False,\n    max_speed=115.0,\n)\n\nparameter_definitions = [\n    SensitivityStudyParameter(name=\"mass\", target=\"vehicle.mass\", label=\"Vehicle mass\"),\n    SensitivityStudyParameter(name=\"cg_height\", target=\"vehicle.cg_height\", label=\"Center of gravity height\"),\n    SensitivityStudyParameter(name=\"yaw_inertia\", target=\"vehicle.yaw_inertia\", label=\"Yaw inertia\"),\n    SensitivityStudyParameter(name=\"drag_coefficient\", target=\"vehicle.drag_coefficient\", label=\"Drag coefficient\"),\n]\n\nmodel = build_single_track_model(\n    vehicle=vehicle,\n    tires=tires,\n    physics=physics,\n)\n\npd.DataFrame(\n    {\n        \"parameter\": [p.name for p in parameter_definitions],\n        \"target\": [p.target for p in parameter_definitions],\n        \"variation_used\": [f\"+/-{variation_pct:.0f}%\"] * len(parameter_definitions),\n    }\n)\n</pre> variation_pct = 10.0  track = build_circular_track(radius=50.0, sample_count=721) vehicle = example_vehicle_parameters() tires = default_axle_tire_parameters() physics = SingleTrackPhysics()  simulation_config = build_simulation_config(     compute_backend=\"torch\",     torch_device=\"cpu\",     torch_compile=False,     max_speed=115.0, )  parameter_definitions = [     SensitivityStudyParameter(name=\"mass\", target=\"vehicle.mass\", label=\"Vehicle mass\"),     SensitivityStudyParameter(name=\"cg_height\", target=\"vehicle.cg_height\", label=\"Center of gravity height\"),     SensitivityStudyParameter(name=\"yaw_inertia\", target=\"vehicle.yaw_inertia\", label=\"Yaw inertia\"),     SensitivityStudyParameter(name=\"drag_coefficient\", target=\"vehicle.drag_coefficient\", label=\"Drag coefficient\"), ]  model = build_single_track_model(     vehicle=vehicle,     tires=tires,     physics=physics, )  pd.DataFrame(     {         \"parameter\": [p.name for p in parameter_definitions],         \"target\": [p.target for p in parameter_definitions],         \"variation_used\": [f\"+/-{variation_pct:.0f}%\"] * len(parameter_definitions),     } ) In\u00a0[\u00a0]: Copied! <pre>study_result = run_lap_sensitivity_study(\n    track=track,\n    model=model,\n    simulation_config=simulation_config,\n    parameters=parameter_definitions,\n    label=\"Synthetic circle (R=50 m)\",\n)\n\nlong_df = study_result.to_dataframe().sort_values([\"objective\", \"parameter\"], kind=\"stable\")\nlong_df[\"absolute_delta_plus\"] = long_df[\"predicted_objective_plus\"] - long_df[\"objective_value\"]\nlong_df[\"absolute_delta_minus\"] = long_df[\"predicted_objective_minus\"] - long_df[\"objective_value\"]\n\nlong_df[[\n    \"objective\",\n    \"parameter_label\",\n    \"objective_value\",\n    \"sensitivity_raw\",\n    \"sensitivity_pct_per_pct\",\n    \"absolute_delta_plus\",\n    \"absolute_delta_minus\",\n]]\n</pre> study_result = run_lap_sensitivity_study(     track=track,     model=model,     simulation_config=simulation_config,     parameters=parameter_definitions,     label=\"Synthetic circle (R=50 m)\", )  long_df = study_result.to_dataframe().sort_values([\"objective\", \"parameter\"], kind=\"stable\") long_df[\"absolute_delta_plus\"] = long_df[\"predicted_objective_plus\"] - long_df[\"objective_value\"] long_df[\"absolute_delta_minus\"] = long_df[\"predicted_objective_minus\"] - long_df[\"objective_value\"]  long_df[[     \"objective\",     \"parameter_label\",     \"objective_value\",     \"sensitivity_raw\",     \"sensitivity_pct_per_pct\",     \"absolute_delta_plus\",     \"absolute_delta_minus\", ]] In\u00a0[\u00a0]: Copied! <pre>output_dir = sensitivity_output_root() / \"synthetic_circle_single_track\"\noutput_dir.mkdir(parents=True, exist_ok=True)\n\nlong_df.to_csv(output_dir / \"sensitivities_long.csv\", index=False)\nstudy_result.to_pivot().sort_index(kind=\"stable\").to_csv(output_dir / \"sensitivities_pivot.csv\")\n\nplot_df = long_df[[\"parameter_label\", \"objective\", \"absolute_delta_plus\"]].pivot(\n    index=\"parameter_label\",\n    columns=\"objective\",\n    values=\"absolute_delta_plus\",\n)\n\nfig, axes = plt.subplots(1, 2, figsize=(12.0, 4.5), constrained_layout=True)\nplot_df[\"lap_time_s\"].plot(\n    kind=\"bar\",\n    ax=axes[0],\n    color=\"#1565c0\",\n    title=f\"Lap-time delta for +{variation_pct:.0f}% parameter variation\",\n)\n(plot_df[\"energy_kwh\"] * 1000.0).plot(\n    kind=\"bar\",\n    ax=axes[1],\n    color=\"#2e7d32\",\n    title=f\"Energy delta for +{variation_pct:.0f}% parameter variation\",\n)\naxes[0].set_ylabel(\"Delta lap time [s]\")\naxes[1].set_ylabel(\"Delta energy [Wh]\")\nfor axis in axes:\n    axis.tick_params(axis=\"x\", rotation=20)\n    axis.grid(alpha=0.25, axis=\"y\")\n\nplot_path = output_dir / \"sensitivity_bars.png\"\nfig.savefig(plot_path, dpi=160)\nplt.close(fig)\n\nprint(f\"Artifacts written to: {output_dir}\")\nplot_df\n</pre> output_dir = sensitivity_output_root() / \"synthetic_circle_single_track\" output_dir.mkdir(parents=True, exist_ok=True)  long_df.to_csv(output_dir / \"sensitivities_long.csv\", index=False) study_result.to_pivot().sort_index(kind=\"stable\").to_csv(output_dir / \"sensitivities_pivot.csv\")  plot_df = long_df[[\"parameter_label\", \"objective\", \"absolute_delta_plus\"]].pivot(     index=\"parameter_label\",     columns=\"objective\",     values=\"absolute_delta_plus\", )  fig, axes = plt.subplots(1, 2, figsize=(12.0, 4.5), constrained_layout=True) plot_df[\"lap_time_s\"].plot(     kind=\"bar\",     ax=axes[0],     color=\"#1565c0\",     title=f\"Lap-time delta for +{variation_pct:.0f}% parameter variation\", ) (plot_df[\"energy_kwh\"] * 1000.0).plot(     kind=\"bar\",     ax=axes[1],     color=\"#2e7d32\",     title=f\"Energy delta for +{variation_pct:.0f}% parameter variation\", ) axes[0].set_ylabel(\"Delta lap time [s]\") axes[1].set_ylabel(\"Delta energy [Wh]\") for axis in axes:     axis.tick_params(axis=\"x\", rotation=20)     axis.grid(alpha=0.25, axis=\"y\")  plot_path = output_dir / \"sensitivity_bars.png\" fig.savefig(plot_path, dpi=160) plt.close(fig)  print(f\"Artifacts written to: {output_dir}\") plot_df In\u00a0[\u00a0]: Copied! <pre>near_zero_table = long_df[long_df[\"parameter\"].isin([\"cg_height\", \"yaw_inertia\"])][[\n    \"objective\",\n    \"parameter_label\",\n    \"sensitivity_raw\",\n    \"absolute_delta_plus\",\n    \"absolute_delta_minus\",\n]].sort_values([\"objective\", \"parameter_label\"], kind=\"stable\")\n\nnear_zero_table\n</pre> near_zero_table = long_df[long_df[\"parameter\"].isin([\"cg_height\", \"yaw_inertia\"])][[     \"objective\",     \"parameter_label\",     \"sensitivity_raw\",     \"absolute_delta_plus\",     \"absolute_delta_minus\", ]].sort_values([\"objective\", \"parameter_label\"], kind=\"stable\")  near_zero_table"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#vehicle-parameter-sensitivities-using-a-single-track-model-on-synthetic-tracks","title":"Vehicle Parameter Sensitivities using a Single Track Model on synthetic tracks\u00b6","text":"<p>This notebook is an educational engineering-style walkthrough of a local sensitivity study in ApexSim.</p> <p>We use a synthetic circular track and the single-track vehicle model to answer a practical question: which vehicle parameters matter most for lap time and energy in this specific setup?</p>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#why-start-with-a-synthetic-track","title":"Why start with a synthetic track?\u00b6","text":"<p>A synthetic track is intentionally simple. It removes many confounding effects and makes it easier to interpret cause and effect in the model.</p> <p>In this study, we vary four parameters around a baseline operating point:</p> <ul> <li>Vehicle mass</li> <li>Center-of-gravity height</li> <li>Yaw inertia</li> <li>Drag coefficient</li> </ul> <p>and evaluate two outputs:</p> <ul> <li>Lap time (<code>lap_time_s</code>)</li> <li>Energy consumption (<code>energy_kwh</code>)</li> </ul>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#method-local-sensitivities-around-a-baseline","title":"Method: local sensitivities around a baseline\u00b6","text":"<p>ApexSim computes local derivatives</p> <p>$$ S_i = \\frac{\\partial y}{\\partial p_i} $$</p> <p>for each selected parameter $p_i$ and objective $y$.</p> <p>To make this easier to interpret in engineering terms, we also use the first-order estimate for a +10% parameter change:</p> <p>$$ \\Delta y_{+10\\%} \\approx S_i \\cdot (0.10 \\cdot p_{i,0}) $$</p> <p>This gives absolute output deltas in physical units: seconds for lap time and Wh for energy.</p>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#modeling-assumptions-to-keep-in-mind","title":"Modeling assumptions to keep in mind\u00b6","text":"<p>This example uses the quasi-static speed-profile solver with the torch backend (autodiff by default).</p> <p>That means the results are local sensitivities of the active quasi-static model path. Parameters that mainly influence transient state dynamics may appear near zero in this workflow.</p>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#step-1-define-track-model-solver-and-parameter-set","title":"Step 1: define track, model, solver, and parameter set\u00b6","text":"<p>We build one baseline configuration and then request sensitivities for the four parameters via dot-path targets in the study API.</p>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#step-2-run-the-study-and-inspect-numeric-results","title":"Step 2: run the study and inspect numeric results\u00b6","text":"<p>The long-format table reports objective values, raw sensitivities, relative elasticities, and predicted KPI values for +/-10% parameter variation.</p>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#step-3-plot-absolute-kpi-deltas-for-10","title":"Step 3: plot absolute KPI deltas for +10%\u00b6","text":"<p>To align with engineering decision-making, we plot absolute KPI changes rather than normalized factors.</p>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#interpreting-near-zero-sensitivities","title":"Interpreting near-zero sensitivities\u00b6","text":"<p>Some parameters can appear close to zero in this quasi-static operating point. That indicates weak local influence under the current solver assumptions and operating condition, not universal irrelevance.</p>"},{"location":"examples/sensitivity/synthetic_single_track_sensitivity/#engineering-interpretation","title":"Engineering interpretation\u00b6","text":"<p>This synthetic-track result should be read as a local model-path sensitivity statement:</p> <ul> <li>Mass and drag are active drivers of both lap time and energy in this setup.</li> <li>CoG height and yaw inertia are near zero here and are confirmed by both AD and FD.</li> <li>This does not mean these parameters are universally irrelevant; it means their effect is not dominant in the current quasi-static objective path.</li> </ul> <p>That is exactly the value of this workflow: clear, model-consistent attribution of KPI sensitivity at a defined operating point.</p>"},{"location":"examples/spa/","title":"Spa Examples","text":"<p>Spa-Francorchamps is the first full-track study path in ApexSim. These pages combine practical script usage with theoretical context so model outputs can be interpreted consistently.</p>"},{"location":"examples/spa/#why-spa-as-tutorial-track","title":"Why Spa as tutorial track","text":"<ul> <li>It contains long straights, high-speed corners, and strong elevation changes.</li> <li>It is complex enough to expose model differences clearly.</li> <li>It is still structured enough for reproducible onboarding studies.</li> </ul>"},{"location":"examples/spa/#what-you-should-know-before-starting","title":"What you should know before starting","text":"<ol> <li>Run the Synthetic Track Walkthrough first.</li> <li>Be familiar with the 6-step workflow from How to Use.</li> <li>Use default parameters first, then tune one block at a time.</li> </ol>"},{"location":"examples/spa/#tutorial-sequence","title":"Tutorial sequence","text":"<ol> <li>Single-Track Lap</li> <li>Point-Mass Lap</li> <li>Model Comparison</li> <li>Performance Envelope</li> </ol>"},{"location":"examples/spa/#common-output-structure","title":"Common output structure","text":"<p>All Spa scripts write into <code>examples/output/spa/</code>. Subfolders are separated by script purpose (single-track, point-mass, comparison, envelope), so results stay comparable.</p>"},{"location":"examples/spa/#theoretical-context-used-across-all-spa-pages","title":"Theoretical context used across all Spa pages","text":"<ol> <li>Quasi-steady assumption:    vehicle states are solved from local equilibrium in arc-length domain,    without full transient tire-state dynamics.</li> <li>Lateral/longitudinal coupling:    available \\(a_x\\) is reduced as required \\(a_y\\) approaches the lateral limit.</li> <li>Aero coupling:    both drag and downforce scale approximately with \\(v^2\\), which changes    acceleration limits strongly at higher speeds.</li> <li>Model hierarchy:    point-mass is a reduced model; single-track adds yaw and axle-level effects.</li> </ol>"},{"location":"examples/spa/#quick-run-commands","title":"Quick run commands","text":"<pre><code>python examples/spa/spa_lap_single_track.py\npython examples/spa/spa_lap_point_mass.py\npython examples/spa/spa_model_comparison.py\npython examples/spa/spa_performance_envelope.py\n</code></pre>"},{"location":"examples/spa/#neutral-analysis-checklist","title":"Neutral analysis checklist","text":"<ol> <li>Record physical assumptions and numerical settings for each run.</li> <li>Compare both global KPIs and local trace behavior along arc length.</li> <li>Separate model-structure effects from parameter-tuning effects.</li> <li>State model limitations next to each engineering conclusion.</li> </ol>"},{"location":"examples/spa/model_comparison/","title":"Spa: Model Comparison","text":"<p>This page explains <code>examples/spa/spa_model_comparison.py</code>.</p>"},{"location":"examples/spa/model_comparison/#learning-goal","title":"Learning goal","text":"<p>Quantify the impact of model complexity in a reproducible way.</p>"},{"location":"examples/spa/model_comparison/#comparison-workflow-in-the-script","title":"Comparison workflow in the script","text":"<ol> <li>Run single-track model on Spa.</li> <li>Calibrate point-mass friction to single-track lateral envelope.</li> <li>Run calibrated point-mass model.</li> <li>Export KPI deltas and speed-trace overlay.</li> </ol>"},{"location":"examples/spa/model_comparison/#why-calibration-matters","title":"Why calibration matters","text":"<p>Without calibration, comparison can be biased by arbitrary friction settings. Calibration aligns lateral capability first, so differences are easier to attribute to model structure rather than parameter mismatch.</p>"},{"location":"examples/spa/model_comparison/#theoretical-calibration-note","title":"Theoretical calibration note","text":"<p>The calibration step fits an effective point-mass friction value so that point-mass lateral limits approximate single-track lateral limits over a speed set. Conceptually, this is a least-squares fit:</p> \\[ \\mu^\\star = \\arg\\min_{\\mu}\\sum_i\\left(\\mu\\,a_n(v_i)-a_{y,\\mathrm{lim},\\mathrm{single\\text{-}track}}(v_i)\\right)^2 \\] <p>This keeps cross-model comparison focused on structure, not arbitrary parameter offsets.</p>"},{"location":"examples/spa/model_comparison/#main-artifacts","title":"Main artifacts","text":"<ol> <li><code>examples/output/spa/comparison/comparison_kpis.json</code></li> <li><code>examples/output/spa/comparison/speed_trace_comparison.png</code></li> <li><code>examples/output/spa/comparison/single_track/kpis.json</code></li> <li><code>examples/output/spa/comparison/point_mass_calibrated/kpis.json</code></li> </ol>"},{"location":"examples/spa/model_comparison/#how-to-read-delta-metrics","title":"How to read delta metrics","text":"<ul> <li><code>lap_time_delta</code>: single-track minus point-mass lap time.</li> <li><code>mean_abs_speed_delta</code>: average absolute speed-gap over the full lap.</li> <li><code>max_abs_speed_delta</code>: largest local disagreement.</li> </ul> <p>Interpretation rule: Use local speed differences along arc length to explain global KPI deltas.</p>"},{"location":"examples/spa/model_comparison/#neutral-comparison-protocol","title":"Neutral comparison protocol","text":"<ol> <li>Keep track data and runtime config identical for both models.</li> <li>Compare lap time, mean absolute speed delta, and local peak delta together.</li> <li>Attribute observed differences to specific mechanisms:    yaw/axle dynamics, tire-model detail, or simplified envelopes.</li> <li>State clearly where point-mass is sufficient and where single-track is required.</li> </ol>"},{"location":"examples/spa/performance_envelope/","title":"Spa: Performance Envelope","text":"<p>This page explains <code>examples/spa/spa_performance_envelope.py</code>.</p>"},{"location":"examples/spa/performance_envelope/#learning-goal","title":"Learning goal","text":"<p>Generate and interpret velocity-dependent G-G envelopes for both model families.</p>"},{"location":"examples/spa/performance_envelope/#what-the-script-does","title":"What the script does","text":"<ol> <li>Builds single-track and calibrated point-mass models.</li> <li>Computes <code>compute_performance_envelope(...)</code> for both.</li> <li>Exports envelope arrays (<code>.npz</code>) and summary JSON.</li> <li>Exports a comparison plot of envelope slices across speeds.</li> <li>Optionally exports CSV when pandas is installed.</li> </ol>"},{"location":"examples/spa/performance_envelope/#why-this-is-useful","title":"Why this is useful","text":"<ul> <li>Separates vehicle capability analysis from one specific lap profile.</li> <li>Supports parameter studies and sensitivity sweeps.</li> <li>Makes speed dependence explicit in longitudinal/lateral coupling.</li> </ul>"},{"location":"examples/spa/performance_envelope/#theoretical-definition","title":"Theoretical definition","text":"<p>For each speed sample \\(v_j\\), the script evaluates a feasible acceleration set:</p> \\[ \\mathcal{E}(v_j)= \\left\\{(a_y,a_x)\\,\\middle|\\, a_y\\in\\left[-a_{y,\\mathrm{lim}}(v_j),+a_{y,\\mathrm{lim}}(v_j)\\right],\\; a_x\\in\\left[a_{x,\\min}(v_j),a_{x,\\max}(v_j)\\right] \\right\\} \\] <p>In the exported arrays, this becomes a discretized family of G-G slices indexed by speed. The point-mass and single-track models provide \\(a_{y,\\mathrm{lim}}(v)\\) and longitudinal bounds via their own physical assumptions.</p>"},{"location":"examples/spa/performance_envelope/#main-artifacts","title":"Main artifacts","text":"<ol> <li><code>examples/output/spa/performance_envelope/single_track_envelope.npz</code></li> <li><code>examples/output/spa/performance_envelope/point_mass_envelope.npz</code></li> <li><code>examples/output/spa/performance_envelope/envelope_family_comparison.png</code></li> <li><code>examples/output/spa/performance_envelope/summary.json</code></li> <li>optional CSV files (if pandas is installed)</li> </ol>"},{"location":"examples/spa/performance_envelope/#potential-learnings-from-the-data","title":"Potential learnings from the data","text":"<ol> <li>At each speed, interpret the upper/lower \\(a_x\\) bounds at equal \\(a_y\\).</li> <li>Compare drive and braking envelopes separately.</li> <li>Identify speed ranges where model disagreement is systematically largest.</li> <li>Use these ranges as focused inputs for lap-level model comparisons.</li> </ol>"},{"location":"examples/spa/performance_envelope/#common-pitfalls","title":"Common pitfalls","text":"<ol> <li>Comparing envelopes at different speed grids.</li> <li>Mixing up signed \\(a_x\\) convention (braking is negative in exported minimum trace).</li> <li>Assuming envelope superiority at one speed implies lap-time superiority everywhere.</li> </ol>"},{"location":"examples/spa/point_mass_lap/","title":"Spa: Point-Mass Lap","text":"<p>This page explains <code>examples/spa/spa_lap_point_mass.py</code>.</p>"},{"location":"examples/spa/point_mass_lap/#learning-goal","title":"Learning goal","text":"<p>Run a faster, lower-complexity baseline model and understand what is gained and lost relative to single-track.</p>"},{"location":"examples/spa/point_mass_lap/#what-changes-vs-single-track","title":"What changes vs. single-track","text":"<p>The script keeps track and vehicle setup style identical, but swaps model backend:</p> <pre><code>model = build_point_mass_model(\n    vehicle=vehicle,\n    physics=PointMassPhysics(\n        max_drive_accel=8.0,\n        max_brake_accel=16.0,\n        friction_coefficient=1.7,\n    ),\n)\n</code></pre>"},{"location":"examples/spa/point_mass_lap/#why-this-model-is-useful","title":"Why this model is useful","text":"<ul> <li>Fast parameter sweeps and sensitivity studies.</li> <li>Clean baseline for comparing model complexity.</li> <li>Lower numerical and conceptual overhead for first experiments.</li> </ul>"},{"location":"examples/spa/point_mass_lap/#what-this-model-cannot-represent","title":"What this model cannot represent","text":"<ul> <li>Yaw-state dynamics are not modeled.</li> <li>Yaw moment is zero by model structure.</li> <li>Tire behavior is represented as isotropic envelope simplification.</li> </ul>"},{"location":"examples/spa/point_mass_lap/#outputs-to-inspect-first","title":"Outputs to inspect first","text":"<ol> <li><code>examples/output/spa/point_mass/kpis.json</code></li> <li><code>examples/output/spa/point_mass/speed_trace.png</code></li> <li><code>examples/output/spa/point_mass/gg_diagram.png</code></li> </ol>"},{"location":"examples/spa/point_mass_lap/#theoretical-foundation","title":"Theoretical foundation","text":"<p>The point-mass model uses an isotropic acceleration envelope with aero coupling. Typical relations are:</p> <p>Normal-acceleration budget:</p> \\[ a_n(v) = g + \\frac{F_{\\mathrm{down}}(v)}{m} \\] <p>Lateral limit (flat road simplification):</p> \\[ a_{y,\\mathrm{lim}}(v) = \\mu \\, a_n(v) \\] <p>Friction-circle coupling:</p> \\[ a_{x,\\mathrm{avail}} = a_{x,\\max}\\sqrt{1 - \\left(\\frac{a_{y,\\mathrm{req}}}{a_{y,\\mathrm{lim}}}\\right)^2} \\] <p>This structure is intentionally compact and efficient for fast sweeps.</p>"},{"location":"examples/spa/point_mass_lap/#assumptions-and-limits","title":"Assumptions and limits","text":"<ol> <li>Yaw dynamics and axle-specific tire behavior are not represented.</li> <li>Tire behavior is condensed into scalar friction/envelope parameters.</li> <li>Model fidelity is lower, but computational throughput is high.</li> </ol>"},{"location":"examples/spa/point_mass_lap/#potential-learnings-from-the-data","title":"Potential learnings from the data","text":"<ol> <li>Use this model for baseline trends and wide parameter scans.</li> <li>Compare against single-track before drawing conclusions on yaw-sensitive effects.</li> <li>Separate differences caused by calibration (\\(\\mu\\)) from structural model differences.</li> </ol>"},{"location":"examples/spa/single_track_lap/","title":"Spa: Single-Track Lap","text":"<p>This page explains <code>examples/spa/spa_lap_single_track.py</code>.</p>"},{"location":"examples/spa/single_track_lap/#learning-goal","title":"Learning goal","text":"<p>Use the highest-fidelity quasi-steady vehicle model in the current library and interpret its outputs correctly.</p>"},{"location":"examples/spa/single_track_lap/#what-the-script-does","title":"What the script does","text":"<ol> <li>Loads Spa track data.</li> <li>Builds vehicle + tire + <code>SingleTrackModel</code>.</li> <li>Runs <code>simulate_lap(...)</code> with default runtime config.</li> <li>Exports KPI JSON and standard plots.</li> </ol>"},{"location":"examples/spa/single_track_lap/#key-code-path","title":"Key code path","text":"<pre><code>track = load_track_csv(spa_track_path())\nvehicle = example_vehicle_parameters()\ntires = default_axle_tire_parameters()\nmodel = build_single_track_model(vehicle=vehicle, tires=tires, physics=SingleTrackPhysics())\nconfig = build_simulation_config()\nresult = simulate_lap(track=track, model=model, config=config)\n</code></pre>"},{"location":"examples/spa/single_track_lap/#why-start-with-single-track","title":"Why start with single-track","text":"<ul> <li>It captures lateral tire behavior with load sensitivity.</li> <li>It provides axle-load diagnostics and supports transient yaw-residual analysis.</li> <li>It is a strong baseline before simplifying to point-mass.</li> </ul>"},{"location":"examples/spa/single_track_lap/#outputs-to-inspect-first","title":"Outputs to inspect first","text":"<ol> <li><code>examples/output/spa/single_track/kpis.json</code></li> <li><code>examples/output/spa/single_track/speed_trace.png</code></li> <li><code>examples/output/spa/single_track/gg_diagram.png</code></li> <li><code>examples/output/spa/single_track/yaw_moment_vs_ay.png</code></li> </ol>"},{"location":"examples/spa/single_track_lap/#theoretical-foundation","title":"Theoretical foundation","text":"<p>The single-track model is a reduced planar vehicle model with front/rear axle representation. In quasi-steady use, the key balances are:</p> <p>Lateral acceleration balance:</p> \\[ a_y = \\frac{F_{y,f} + F_{y,r}}{m} \\] <p>In quasi-static mode, yaw-moment output is zero by steady-state model assumption. Dynamic yaw residuals are available in transient mode.</p> <p>Path-kinematics coupling:</p> \\[ a_y = v^2 \\kappa \\] <p>Tire forces are generated from the Pacejka-style lateral model with load sensitivity. This makes axle-load distribution and aero effects directly relevant for cornering limits.</p>"},{"location":"examples/spa/single_track_lap/#assumptions-and-limits","title":"Assumptions and limits","text":"<ol> <li>Quasi-steady envelope solving does not capture full transient tire relaxation.</li> <li>The model is 3-DOF planar and omits full multibody compliance.</li> <li>Powertrain and control strategy are represented through simplified envelopes.</li> </ol>"},{"location":"examples/spa/single_track_lap/#potential-learnings-from-the-data","title":"Potential learnings from the data","text":"<ol> <li>Check lap-time and speed-trace shape together, not separately.</li> <li>Validate that high \\(|a_y|\\) regions align with curved track sectors.</li> <li>In transient runs, use yaw-residual traces as consistency diagnostics for    dynamic balance.</li> <li>If output magnitudes are implausible, re-check physical inputs before changing numerics.</li> </ol>"},{"location":"examples/transient/","title":"Transient Solver Examples","text":"<p>This section demonstrates the transient solver mode.</p> <p>Core idea:</p> <ul> <li><code>solver_mode=\"quasi_static\"</code> computes an envelope-constrained speed profile.</li> <li><code>solver_mode=\"transient_oc\"</code> solves a dynamic, control-constrained lap problem.</li> </ul> <p>In transient mode, ApexSim supports two driver models:</p> <ul> <li><code>driver_model=\"pid\"</code> (default): deterministic closed-loop driver with optional   speed-dependent gain scheduling.</li> <li><code>driver_model=\"optimal_control\"</code>: full minimum-time control optimization.</li> </ul> <p>Both enforce vehicle dynamics consistency, track-following feasibility, tire/friction feasibility, and control bounds (longitudinal command, plus steering angle/rate for <code>SingleTrackModel</code>).</p> <p>Use this section when you need dynamic states (<code>vx</code>, <code>vy</code>, <code>yaw_rate</code>, controls) and want to capture effects that are weak in quasi-static mode (for example yaw inertia in maneuver-heavy scenarios).</p>"},{"location":"examples/transient/#pages","title":"Pages","text":"<ol> <li>Point-Mass Transient Lap</li> <li>Single-Track Transient Lap</li> </ol>"},{"location":"examples/transient/#scripts","title":"Scripts","text":"<ul> <li><code>examples/transient/transient_point_mass_lap.py</code></li> <li><code>examples/transient/transient_single_track_lap.py</code></li> </ul> <p>Both scripts export standardized KPI/plot artifacts plus <code>transient_trace.csv</code> with the full time/state/control traces for external analysis. Each script also supports:</p> <ul> <li><code>--driver-model pid|optimal_control</code></li> <li><code>--pid-scheduling-mode off|physics_informed|custom</code></li> </ul>"},{"location":"examples/transient/point_mass_lap/","title":"Point-Mass Transient Lap","text":"<p>This example runs the transient solver with <code>PointMassModel</code> on a straight track and a standing start (<code>initial_speed=0.0</code>).</p> <p>Script: <code>examples/transient/transient_point_mass_lap.py</code></p>"},{"location":"examples/transient/point_mass_lap/#engineering-intent","title":"Engineering intent","text":"<p>This scenario isolates longitudinal behavior:</p> <ul> <li>no steering control,</li> <li>no lateral dynamics state evolution,</li> <li>direct visibility of launch and acceleration phases.</li> </ul> <p>It is useful for validating traction/braking bottlenecks and for checking how transient control limits affect the time trace from rest.</p>"},{"location":"examples/transient/point_mass_lap/#configuration-highlights","title":"Configuration highlights","text":"<ul> <li>solver mode: <code>transient_oc</code></li> <li>default driver model: PID (<code>driver_model=\"pid\"</code>)</li> <li>optional full optimizer: <code>driver_model=\"optimal_control\"</code></li> <li>backend: selectable (<code>numpy</code>, <code>numba</code>, <code>torch</code>)</li> <li>integration method: <code>euler</code> or <code>rk4</code></li> <li>PID scheduling mode: <code>off</code>, <code>physics_informed</code>, or <code>custom</code></li> <li>objective: minimum lap time with smoothness and lateral-feasibility penalties</li> </ul>"},{"location":"examples/transient/point_mass_lap/#run","title":"Run","text":"<pre><code>python examples/transient/transient_point_mass_lap.py --backend numpy --integration-method rk4\n</code></pre> <p>Physics-informed PID scheduling:</p> <pre><code>python examples/transient/transient_point_mass_lap.py --backend numpy --pid-scheduling-mode physics_informed\n</code></pre> <p>Full optimal-control mode:</p> <pre><code>python examples/transient/transient_point_mass_lap.py --backend numpy --driver-model optimal_control\n</code></pre>"},{"location":"examples/transient/point_mass_lap/#outputs","title":"Outputs","text":"<p>Artifacts are written to:</p> <ul> <li><code>examples/output/transient/point_mass_standing_start/</code></li> </ul> <p>Key files:</p> <ul> <li><code>kpis.json</code></li> <li>standard plots (speed/power/loads)</li> <li><code>transient_trace.csv</code></li> </ul> <p>The trace CSV contains:</p> <ul> <li>arc length and time,</li> <li>speed and accelerations,</li> <li><code>vx</code>, <code>vy</code>, <code>yaw_rate</code>,</li> <li>control signals (<code>steer_cmd</code>, <code>ax_cmd</code>).</li> </ul> <p>For point-mass transient runs, <code>vy</code>, <code>yaw_rate</code>, and <code>steer_cmd</code> remain structurally zero by model definition.</p>"},{"location":"examples/transient/single_track_lap/","title":"Single-Track Transient Lap","text":"<p>This example runs the transient solver with <code>SingleTrackModel</code> on a figure-eight track.</p> <p>Script: <code>examples/transient/transient_single_track_lap.py</code></p>"},{"location":"examples/transient/single_track_lap/#engineering-intent","title":"Engineering intent","text":"<p>The figure-eight introduces repeated left/right transient maneuvers, so the single-track dynamic states become informative:</p> <ul> <li><code>vx</code>: longitudinal body speed,</li> <li><code>vy</code>: lateral body speed,</li> <li><code>yaw_rate</code>: yaw dynamics,</li> <li><code>steer_cmd</code>: steering command trajectory,</li> <li><code>ax_cmd</code>: longitudinal command trajectory.</li> </ul> <p>Compared to quasi-static solves, this setup better exposes control-rate limits and yaw-inertia effects.</p>"},{"location":"examples/transient/single_track_lap/#configuration-highlights","title":"Configuration highlights","text":"<ul> <li>solver mode: <code>transient_oc</code></li> <li>default driver model: PID (<code>driver_model=\"pid\"</code>)</li> <li>optional full optimizer: <code>driver_model=\"optimal_control\"</code></li> <li>model-level control limits:</li> <li><code>SingleTrackPhysics.max_steer_angle</code></li> <li><code>SingleTrackPhysics.max_steer_rate</code></li> <li>backend: selectable (<code>numpy</code>, <code>numba</code>, <code>torch</code>)</li> <li>integration method: <code>euler</code> or <code>rk4</code></li> <li>PID scheduling mode: <code>off</code>, <code>physics_informed</code>, or <code>custom</code></li> </ul>"},{"location":"examples/transient/single_track_lap/#run","title":"Run","text":"<pre><code>python examples/transient/transient_single_track_lap.py --backend numpy --integration-method rk4\n</code></pre> <p>Physics-informed PID scheduling:</p> <pre><code>python examples/transient/transient_single_track_lap.py --backend numpy --pid-scheduling-mode physics_informed\n</code></pre> <p>Full optimal-control mode:</p> <pre><code>python examples/transient/transient_single_track_lap.py --backend numpy --driver-model optimal_control\n</code></pre>"},{"location":"examples/transient/single_track_lap/#outputs","title":"Outputs","text":"<p>Artifacts are written to:</p> <ul> <li><code>examples/output/transient/single_track_figure_eight/</code></li> </ul> <p>Key files:</p> <ul> <li><code>kpis.json</code></li> <li>standard plots</li> <li><code>transient_trace.csv</code></li> </ul> <p>Use <code>transient_trace.csv</code> to inspect control/state transitions and to compare backend behavior or configuration changes.</p>"},{"location":"reference/analysis/","title":"Analysis","text":""},{"location":"reference/analysis/#apexsim.analysis","title":"analysis","text":"<p>Simulation analysis tools.</p>"},{"location":"reference/analysis/#apexsim.analysis.KpiSummary","title":"KpiSummary  <code>dataclass</code>","text":"<p>Summary metrics for a lap simulation.</p> <p>Parameters:</p> Name Type Description Default <code>lap_time</code> <code>float</code> <p>Total lap time [s].</p> required <code>avg_lateral_accel_g</code> <code>float</code> <p>Mean absolute lateral acceleration (g).</p> required <code>max_lateral_accel_g</code> <code>float</code> <p>Peak absolute lateral acceleration (g).</p> required <code>avg_longitudinal_accel_g</code> <code>float</code> <p>Mean absolute longitudinal acceleration (g).</p> required <code>max_longitudinal_accel_g</code> <code>float</code> <p>Peak absolute longitudinal acceleration (g).</p> required <code>energy</code> <code>float</code> <p>Integrated positive traction energy [kWh].</p> required"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeConfig","title":"PerformanceEnvelopeConfig  <code>dataclass</code>","text":"<p>Top-level config for performance-envelope generation.</p> <p>Parameters:</p> Name Type Description Default <code>physics</code> <code>PerformanceEnvelopePhysics</code> <p>Physical operating-point definitions for the envelope.</p> <code>PerformanceEnvelopePhysics()</code> <code>numerics</code> <code>PerformanceEnvelopeNumerics</code> <p>Numerical discretization controls for the envelope sweep.</p> <code>PerformanceEnvelopeNumerics()</code> <code>runtime</code> <code>PerformanceEnvelopeRuntime</code> <p>Runtime backend controls for model evaluation.</p> <code>PerformanceEnvelopeRuntime()</code>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate combined envelope settings.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any physical, numerical, or runtime setting is invalid.</p>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeNumerics","title":"PerformanceEnvelopeNumerics  <code>dataclass</code>","text":"<p>Numerical discretization controls for envelope generation.</p> <p>Parameters:</p> Name Type Description Default <code>speed_samples</code> <code>int</code> <p>Number of speed support points used for the sweep.</p> <code>DEFAULT_ENVELOPE_SPEED_SAMPLES</code> <code>lateral_accel_samples</code> <code>int</code> <p>Number of lateral-demand support points used per speed sample.</p> <code>DEFAULT_ENVELOPE_LATERAL_ACCEL_SAMPLES</code> <code>lateral_accel_fraction_span</code> <code>float</code> <p>Symmetric lateral-demand span relative to available lateral limit. <code>1.0</code> means <code>[-ay_max, ay_max]</code>.</p> <code>DEFAULT_LATERAL_ACCEL_FRACTION_SPAN</code>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeNumerics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate numerical envelope discretization settings.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If sample counts or span values violate required bounds.</p>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopePhysics","title":"PerformanceEnvelopePhysics  <code>dataclass</code>","text":"<p>Physical operating-point definitions for envelope generation.</p> <p>Parameters:</p> Name Type Description Default <code>speed_min</code> <code>float</code> <p>Lower speed bound for the envelope sweep [m/s].</p> <code>DEFAULT_ENVELOPE_SPEED_MIN</code> <code>speed_max</code> <code>float</code> <p>Upper speed bound for the envelope sweep [m/s].</p> <code>DEFAULT_ENVELOPE_SPEED_MAX</code> <code>grade</code> <code>float</code> <p>Constant road grade used for all envelope samples <code>dz/ds</code> [-].</p> <code>DEFAULT_ENVELOPE_GRADE</code> <code>banking</code> <code>float</code> <p>Constant road banking used for all envelope samples [rad].</p> <code>DEFAULT_ENVELOPE_BANKING</code>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopePhysics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate physical operating-point definitions.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If speed bounds are invalid or non-finite values are provided.</p>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeResult","title":"PerformanceEnvelopeResult  <code>dataclass</code>","text":"<p>Computed velocity-dependent G-G envelope arrays.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>ndarray</code> <p>Speed support points [m/s], shape <code>(n_speed,)</code>.</p> required <code>lateral_accel_limit</code> <code>ndarray</code> <p>Lateral acceleration limits at each speed [m/s^2], shape <code>(n_speed,)</code>.</p> required <code>lateral_accel_fraction</code> <code>ndarray</code> <p>Normalized lateral-demand support points used for each speed sample, shape <code>(n_lateral,)</code>.</p> required <code>lateral_accel</code> <code>ndarray</code> <p>Lateral-demand matrix [m/s^2], shape <code>(n_speed, n_lateral)</code>.</p> required <code>max_longitudinal_accel</code> <code>ndarray</code> <p>Maximum net forward acceleration matrix [m/s^2], shape <code>(n_speed, n_lateral)</code>.</p> required <code>min_longitudinal_accel</code> <code>ndarray</code> <p>Minimum net longitudinal acceleration matrix (negative for braking) [m/s^2], shape <code>(n_speed, n_lateral)</code>.</p> required"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeResult.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate array shapes after initialization.</p>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeResult.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; Any\n</code></pre> <p>Return a long-form pandas representation of the envelope.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Pandas DataFrame with columns <code>speed</code>, <code>lateral_accel_limit</code>,</p> <code>Any</code> <p><code>lateral_accel_fraction</code>, <code>lateral_accel</code>,</p> <code>Any</code> <p><code>max_longitudinal_accel</code>, and <code>min_longitudinal_accel</code>.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If pandas is not installed in the active environment.</p>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeResult.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; np.ndarray\n</code></pre> <p>Return a stacked NumPy tensor representation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Tensor with shape <code>(n_speed, n_lateral, 3)</code> and channels ordered</p> <code>ndarray</code> <p>as <code>(lateral_accel, max_longitudinal_accel, min_longitudinal_accel)</code>.</p>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeRuntime","title":"PerformanceEnvelopeRuntime  <code>dataclass</code>","text":"<p>Runtime controls for envelope generation backend selection.</p> <p>Parameters:</p> Name Type Description Default <code>compute_backend</code> <code>str</code> <p>Numerical backend identifier (<code>numpy</code>, <code>numba</code>, or <code>torch</code>).</p> <code>DEFAULT_COMPUTE_BACKEND</code> <code>torch_device</code> <code>str</code> <p>Torch device identifier. For non-torch backends this must remain <code>\"cpu\"</code>.</p> <code>DEFAULT_TORCH_DEVICE</code> <code>torch_compile</code> <code>bool</code> <p>Enable <code>torch.compile</code> when backend is <code>torch</code>.</p> <code>DEFAULT_ENABLE_TORCH_COMPILE</code>"},{"location":"reference/analysis/#apexsim.analysis.PerformanceEnvelopeRuntime.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate runtime controls and backend availability.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If backend selection or backend-specific runtime settings are invalid.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityConfig","title":"SensitivityConfig  <code>dataclass</code>","text":"<p>Top-level config for scalar sensitivity computation.</p> <p>Parameters:</p> Name Type Description Default <code>numerics</code> <code>SensitivityNumerics</code> <p>Numerical controls for finite-difference perturbations.</p> <code>SensitivityNumerics()</code> <code>runtime</code> <code>SensitivityRuntime</code> <p>Runtime controls for backend-method selection.</p> <code>SensitivityRuntime()</code>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate combined sensitivity settings.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If runtime or numerical controls are inconsistent.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityNumerics","title":"SensitivityNumerics  <code>dataclass</code>","text":"<p>Numerical controls for sensitivity estimation.</p> <p>Parameters:</p> Name Type Description Default <code>finite_difference_scheme</code> <code>str</code> <p>Finite-difference scheme identifier (<code>central</code> or <code>forward</code>).</p> <code>DEFAULT_FD_SCHEME</code> <code>finite_difference_relative_step</code> <code>float</code> <p>Relative finite-difference step scale.</p> <code>DEFAULT_FD_RELATIVE_STEP</code> <code>finite_difference_absolute_step</code> <code>float</code> <p>Absolute finite-difference step floor.</p> <code>DEFAULT_FD_ABSOLUTE_STEP</code>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityNumerics.step_size","title":"step_size","text":"<pre><code>step_size(value: float) -&gt; float\n</code></pre> <p>Return finite-difference perturbation size for a scalar value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Baseline parameter value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Positive perturbation size.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityNumerics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate sensitivity numerical controls.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If scheme or step controls violate required bounds.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityParameter","title":"SensitivityParameter  <code>dataclass</code>","text":"<p>Single scalar parameter definition for sensitivity analysis.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter identifier consumed by the objective callable.</p> required <code>value</code> <code>float</code> <p>Baseline scalar parameter value.</p> required <code>kind</code> <code>str</code> <p>Conceptual parameter category. <code>physical</code> is intended for measurable real-world quantities; <code>numerical</code> for solver controls.</p> <code>'physical'</code> <code>lower_bound</code> <code>float | None</code> <p>Optional lower bound for perturbation validity.</p> <code>None</code> <code>upper_bound</code> <code>float | None</code> <p>Optional upper bound for perturbation validity.</p> <code>None</code>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityParameter.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate parameter definition.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If name, value, kind, or bounds violate required constraints.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityResult","title":"SensitivityResult  <code>dataclass</code>","text":"<p>Sensitivity result for a scalar objective around a baseline point.</p> <p>Parameters:</p> Name Type Description Default <code>objective_value</code> <code>float</code> <p>Baseline objective value at provided parameters.</p> required <code>sensitivities</code> <code>dict[str, float]</code> <p>Mapping from parameter name to local scalar sensitivity.</p> required <code>method</code> <code>str</code> <p>Backend method used for the returned sensitivities.</p> required <code>parameter_values</code> <code>dict[str, float]</code> <p>Baseline scalar values used for each parameter.</p> required <code>parameter_kinds</code> <code>dict[str, str]</code> <p>Parameter category map (<code>physical</code>/<code>numerical</code>).</p> required"},{"location":"reference/analysis/#apexsim.analysis.SensitivityResult.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate result payload consistency.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If keys are mismatched or unsupported method/category identifiers are provided.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityRuntime","title":"SensitivityRuntime  <code>dataclass</code>","text":"<p>Runtime controls for selecting the sensitivity backend method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Sensitivity backend (<code>autodiff</code> or <code>finite_difference</code>).</p> <code>DEFAULT_SENSITIVITY_METHOD</code> <code>torch_device</code> <code>str</code> <p>Torch device used for autodiff parameter tensors.</p> <code>DEFAULT_TORCH_DEVICE</code> <code>autodiff_fallback_to_finite_difference</code> <code>bool</code> <p>Whether autodiff backend errors should fall back to finite-difference evaluation.</p> <code>DEFAULT_AUTODIFF_FALLBACK_TO_FD</code>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityRuntime.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate sensitivity runtime controls.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If method/device selection is invalid or unavailable.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityStudyParameter","title":"SensitivityStudyParameter  <code>dataclass</code>","text":"<p>Parameter specification for high-level lap sensitivity studies.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Parameter identifier used in exported sensitivity tables.</p> required <code>target</code> <code>str</code> <p>Dot-path in the reconstructed model input mapping to the scalar value to be perturbed (for example <code>vehicle.mass</code>).</p> required <code>label</code> <code>str | None</code> <p>Optional human-readable label for plots/tables.</p> <code>None</code> <code>kind</code> <code>str</code> <p>Conceptual parameter category (<code>physical</code> or <code>numerical</code>).</p> <code>'physical'</code> <code>relative_variation</code> <code>float</code> <p>Relative variation used for local +/- prediction columns in tabular outputs.</p> <code>DEFAULT_SENSITIVITY_STUDY_RELATIVE_VARIATION</code> <code>lower_bound</code> <code>float | None</code> <p>Optional lower bound applied to local perturbations.</p> <code>None</code> <code>upper_bound</code> <code>float | None</code> <p>Optional upper bound applied to local perturbations.</p> <code>None</code>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityStudyParameter.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate study-parameter definition.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If target format, parameter category, bounds, or relative variation are invalid.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityStudyResult","title":"SensitivityStudyResult  <code>dataclass</code>","text":"<p>Aggregated lap sensitivity outputs for multiple objectives.</p> <p>Parameters:</p> Name Type Description Default <code>study_label</code> <code>str | None</code> <p>Optional study label propagated into tabular exports.</p> required <code>objective_order</code> <code>tuple[str, ...]</code> <p>Objective identifier order used for outputs.</p> required <code>objective_units</code> <code>dict[str, str]</code> <p>Objective-unit mapping.</p> required <code>parameters</code> <code>tuple[SensitivityStudyParameter, ...]</code> <p>Ordered study parameters used in the run.</p> required <code>sensitivity_results</code> <code>dict[str, SensitivityResult]</code> <p>Per-objective scalar sensitivity outputs.</p> required"},{"location":"reference/analysis/#apexsim.analysis.SensitivityStudyResult.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate structural consistency of study outputs.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If objective or parameter mappings are inconsistent.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityStudyResult.to_dataframe","title":"to_dataframe","text":"<pre><code>to_dataframe() -&gt; Any\n</code></pre> <p>Return long-form tabular sensitivity output.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Pandas DataFrame containing one row per</p> <code>Any</code> <p><code>(objective, parameter)</code> pair.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If pandas is not installed in the active environment.</p>"},{"location":"reference/analysis/#apexsim.analysis.SensitivityStudyResult.to_pivot","title":"to_pivot","text":"<pre><code>to_pivot(value_column: str = 'sensitivity_pct_per_pct') -&gt; Any\n</code></pre> <p>Return compact <code>parameter x objective</code> sensitivity table.</p> <p>Parameters:</p> Name Type Description Default <code>value_column</code> <code>str</code> <p>DataFrame value column used for the pivot table.</p> <code>'sensitivity_pct_per_pct'</code> <p>Returns:</p> Type Description <code>Any</code> <p>Pandas DataFrame with parameters as rows and objectives as columns.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If <code>value_column</code> is not present in the long-form table.</p>"},{"location":"reference/analysis/#apexsim.analysis.build_performance_envelope_config","title":"build_performance_envelope_config","text":"<pre><code>build_performance_envelope_config(physics: PerformanceEnvelopePhysics | None = None, numerics: PerformanceEnvelopeNumerics | None = None, runtime: PerformanceEnvelopeRuntime | None = None) -&gt; PerformanceEnvelopeConfig\n</code></pre> <p>Build a validated performance-envelope config.</p> <p>Parameters:</p> Name Type Description Default <code>physics</code> <code>PerformanceEnvelopePhysics | None</code> <p>Optional physical operating-point definitions.</p> <code>None</code> <code>numerics</code> <code>PerformanceEnvelopeNumerics | None</code> <p>Optional numerical discretization controls.</p> <code>None</code> <code>runtime</code> <code>PerformanceEnvelopeRuntime | None</code> <p>Optional runtime backend controls.</p> <code>None</code> <p>Returns:</p> Type Description <code>PerformanceEnvelopeConfig</code> <p>Fully validated performance-envelope configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If assembled settings are inconsistent.</p>"},{"location":"reference/analysis/#apexsim.analysis.build_sensitivity_config","title":"build_sensitivity_config","text":"<pre><code>build_sensitivity_config(numerics: SensitivityNumerics | None = None, runtime: SensitivityRuntime | None = None) -&gt; SensitivityConfig\n</code></pre> <p>Build a validated sensitivity configuration.</p> <p>Parameters:</p> Name Type Description Default <code>numerics</code> <code>SensitivityNumerics | None</code> <p>Optional numerical controls.</p> <code>None</code> <code>runtime</code> <code>SensitivityRuntime | None</code> <p>Optional runtime controls.</p> <code>None</code> <p>Returns:</p> Type Description <code>SensitivityConfig</code> <p>Validated sensitivity config.</p>"},{"location":"reference/analysis/#apexsim.analysis.compute_kpis","title":"compute_kpis","text":"<pre><code>compute_kpis(result: LapResult) -&gt; KpiSummary\n</code></pre> <p>Compute mandatory and energy KPIs from simulation output.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>LapResult</code> <p>Full lap simulation output arrays and integrated metrics.</p> required <p>Returns:</p> Type Description <code>KpiSummary</code> <p>Aggregated KPI summary containing lap time, acceleration metrics, and</p> <code>KpiSummary</code> <p>electrical-equivalent traction energy [kWh].</p>"},{"location":"reference/analysis/#apexsim.analysis.compute_performance_envelope","title":"compute_performance_envelope","text":"<pre><code>compute_performance_envelope(model: VehicleModel, config: PerformanceEnvelopeConfig | None = None, *, physics: PerformanceEnvelopePhysics | None = None, numerics: PerformanceEnvelopeNumerics | None = None, runtime: PerformanceEnvelopeRuntime | None = None) -&gt; PerformanceEnvelopeResult\n</code></pre> <p>Compute a velocity-dependent G-G performance envelope for a vehicle model.</p> <p>Either provide a full <code>config</code> object, or provide <code>physics</code>, <code>numerics</code>, and/or <code>runtime</code> components directly.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VehicleModel</code> <p>Vehicle model backend implementing <code>VehicleModel</code>.</p> required <code>config</code> <code>PerformanceEnvelopeConfig | None</code> <p>Optional pre-built performance-envelope configuration.</p> <code>None</code> <code>physics</code> <code>PerformanceEnvelopePhysics | None</code> <p>Optional physical operating-point settings (only used when <code>config</code> is not provided).</p> <code>None</code> <code>numerics</code> <code>PerformanceEnvelopeNumerics | None</code> <p>Optional numerical envelope discretization controls (only used when <code>config</code> is not provided).</p> <code>None</code> <code>runtime</code> <code>PerformanceEnvelopeRuntime | None</code> <p>Optional backend runtime controls (only used when <code>config</code> is not provided).</p> <code>None</code> <p>Returns:</p> Type Description <code>PerformanceEnvelopeResult</code> <p>Computed performance-envelope result containing speed support, lateral</p> <code>PerformanceEnvelopeResult</code> <p>limits, and longitudinal accel/decel limits over the sampled G-G domain.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If configuration is invalid, incompatible options are provided, or backend-specific model API requirements are not met.</p>"},{"location":"reference/analysis/#apexsim.analysis.compute_sensitivities","title":"compute_sensitivities","text":"<pre><code>compute_sensitivities(objective: SensitivityObjective, parameters: Sequence[SensitivityParameter] | Mapping[str, float], config: SensitivityConfig | None = None, *, numerics: SensitivityNumerics | None = None, runtime: SensitivityRuntime | None = None) -&gt; SensitivityResult\n</code></pre> <p>Compute scalar-objective sensitivities for selected input parameters.</p> <p>Either provide a full <code>config</code> object, or provide <code>numerics</code> and/or <code>runtime</code> components directly.</p> <p>Parameters:</p> Name Type Description Default <code>objective</code> <code>SensitivityObjective</code> <p>Objective function returning a scalar KPI value.</p> required <code>parameters</code> <code>Sequence[SensitivityParameter] | Mapping[str, float]</code> <p>Parameter definitions or a <code>name -&gt; value</code> mapping.</p> required <code>config</code> <code>SensitivityConfig | None</code> <p>Optional validated sensitivity config.</p> <code>None</code> <code>numerics</code> <code>SensitivityNumerics | None</code> <p>Optional numerical controls (used only if <code>config</code> is not provided).</p> <code>None</code> <code>runtime</code> <code>SensitivityRuntime | None</code> <p>Optional runtime controls (used only if <code>config</code> is not provided).</p> <code>None</code> <p>Returns:</p> Type Description <code>SensitivityResult</code> <p>Baseline scalar objective and local sensitivities per parameter.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If configuration or parameter definitions are invalid, or if objective outputs violate scalar/autodiff requirements.</p>"},{"location":"reference/analysis/#apexsim.analysis.export_standard_plots","title":"export_standard_plots","text":"<pre><code>export_standard_plots(result: LapResult, output_dir: str | Path) -&gt; None\n</code></pre> <p>Export all standard analysis plots in PNG and PDF format.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>LapResult</code> <p>Simulation result used as plotting input.</p> required <code>output_dir</code> <code>str | Path</code> <p>Destination directory for all generated plots.</p> required"},{"location":"reference/analysis/#apexsim.analysis.register_sensitivity_model_adapter","title":"register_sensitivity_model_adapter","text":"<pre><code>register_sensitivity_model_adapter(*, model_type: type[Any], model_factory: SensitivityModelFactory, model_inputs_getter: SensitivityModelInputsGetter) -&gt; None\n</code></pre> <p>Register model reconstruction adapter for lap sensitivity studies.</p> <p>Registered adapters enable :func:<code>run_lap_sensitivity_study</code> to rebuild a model for each parameter perturbation without mutating the passed model.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>type[Any]</code> <p>Model class handled by the adapter.</p> required <code>model_factory</code> <code>SensitivityModelFactory</code> <p>Callable rebuilding model instances from keyword inputs.</p> required <code>model_inputs_getter</code> <code>SensitivityModelInputsGetter</code> <p>Callable extracting reconstructable baseline model inputs from an existing model instance.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If adapter inputs are malformed.</p>"},{"location":"reference/analysis/#apexsim.analysis.run_lap_sensitivity_study","title":"run_lap_sensitivity_study","text":"<pre><code>run_lap_sensitivity_study(*, track: TrackData, model: Any, simulation_config: SimulationConfig, parameters: Sequence[SensitivityStudyParameter], objectives: Sequence[str] = DEFAULT_LAP_SENSITIVITY_OBJECTIVES, label: str | None = None, config: SensitivityConfig | None = None, numerics: SensitivityNumerics | None = None, runtime: SensitivityRuntime | None = None) -&gt; SensitivityStudyResult\n</code></pre> <p>Run a local lap-KPI sensitivity study over selected scalar parameters.</p> <p>The study API is model-agnostic. The model is rebuilt from the provided model instance for each parameter perturbation and objective evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track used for speed-profile evaluation.</p> required <code>model</code> <code>Any</code> <p>Baseline model instance used for adapter-based reconstruction.</p> required <code>simulation_config</code> <code>SimulationConfig</code> <p>Simulation setup. Must use <code>compute_backend='torch'</code>.</p> required <code>parameters</code> <code>Sequence[SensitivityStudyParameter]</code> <p>Parameter definitions with dot-path targets into the model input map reconstructed by the registered adapter.</p> required <code>objectives</code> <code>Sequence[str]</code> <p>Objective identifiers. Supported values are <code>lap_time_s</code> and <code>energy_kwh</code>.</p> <code>DEFAULT_LAP_SENSITIVITY_OBJECTIVES</code> <code>label</code> <code>str | None</code> <p>Optional study label used in exported tabular outputs.</p> <code>None</code> <code>config</code> <code>SensitivityConfig | None</code> <p>Optional full sensitivity config.</p> <code>None</code> <code>numerics</code> <code>SensitivityNumerics | None</code> <p>Optional sensitivity numerics (used if <code>config</code> is omitted).</p> <code>None</code> <code>runtime</code> <code>SensitivityRuntime | None</code> <p>Optional sensitivity runtime (used if <code>config</code> is omitted).</p> <code>None</code> <p>Returns:</p> Type Description <code>SensitivityStudyResult</code> <p>Multi-objective sensitivity-study result with tabular conversion helpers.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If objective names are unsupported, parameter targets are invalid, or backend requirements are not satisfied.</p>"},{"location":"reference/apexsim/","title":"Package","text":""},{"location":"reference/apexsim/#apexsim","title":"apexsim","text":"<p>Lap time simulation package.</p>"},{"location":"reference/apexsim/#apexsim.KpiSummary","title":"KpiSummary  <code>dataclass</code>","text":"<p>Summary metrics for a lap simulation.</p> <p>Parameters:</p> Name Type Description Default <code>lap_time</code> <code>float</code> <p>Total lap time [s].</p> required <code>avg_lateral_accel_g</code> <code>float</code> <p>Mean absolute lateral acceleration (g).</p> required <code>max_lateral_accel_g</code> <code>float</code> <p>Peak absolute lateral acceleration (g).</p> required <code>avg_longitudinal_accel_g</code> <code>float</code> <p>Mean absolute longitudinal acceleration (g).</p> required <code>max_longitudinal_accel_g</code> <code>float</code> <p>Peak absolute longitudinal acceleration (g).</p> required <code>energy</code> <code>float</code> <p>Integrated positive traction energy [kWh].</p> required"},{"location":"reference/apexsim/#apexsim.LapResult","title":"LapResult  <code>dataclass</code>","text":"<p>Simulation output arrays and integrated metrics.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track geometry used for the simulation.</p> required <code>speed</code> <code>ndarray</code> <p>Converged speed trace along arc length [m/s].</p> required <code>longitudinal_accel</code> <code>ndarray</code> <p>Net longitudinal acceleration trace [m/s^2].</p> required <code>lateral_accel</code> <code>ndarray</code> <p>Lateral acceleration trace [m/s^2].</p> required <code>yaw_moment</code> <code>ndarray</code> <p>Yaw-moment trace [N*m]. In quasi-static mode this is zero by model assumption. In transient mode this is reported as the dynamic yaw residual <code>I_z * dr/dt</code>.</p> required <code>front_axle_load</code> <code>ndarray</code> <p>Front-axle normal load trace [N].</p> required <code>rear_axle_load</code> <code>ndarray</code> <p>Rear-axle normal load trace [N].</p> required <code>power</code> <code>ndarray</code> <p>Tractive power trace [W].</p> required <code>energy</code> <code>float</code> <p>Integrated positive tractive energy [J].</p> required <code>lap_time</code> <code>float</code> <p>Integrated lap time [s].</p> required <code>solver_mode</code> <code>str</code> <p>Solver mode used for this lap result.</p> <code>'quasi_static'</code> <code>time</code> <code>ndarray | None</code> <p>Optional cumulative time trace [s] for transient solver mode.</p> <code>None</code> <code>vx</code> <code>ndarray | None</code> <p>Optional body-frame longitudinal speed trace [m/s].</p> <code>None</code> <code>vy</code> <code>ndarray | None</code> <p>Optional body-frame lateral speed trace [m/s].</p> <code>None</code> <code>yaw_rate</code> <code>ndarray | None</code> <p>Optional yaw-rate trace [rad/s].</p> <code>None</code> <code>steer_cmd</code> <code>ndarray | None</code> <p>Optional steering command trace [rad].</p> <code>None</code> <code>ax_cmd</code> <code>ndarray | None</code> <p>Optional longitudinal acceleration command trace [m/s^2].</p> <code>None</code>"},{"location":"reference/apexsim/#apexsim.compute_kpis","title":"compute_kpis","text":"<pre><code>compute_kpis(result: LapResult) -&gt; KpiSummary\n</code></pre> <p>Compute mandatory and energy KPIs from simulation output.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>LapResult</code> <p>Full lap simulation output arrays and integrated metrics.</p> required <p>Returns:</p> Type Description <code>KpiSummary</code> <p>Aggregated KPI summary containing lap time, acceleration metrics, and</p> <code>KpiSummary</code> <p>electrical-equivalent traction energy [kWh].</p>"},{"location":"reference/apexsim/#apexsim.simulate_lap","title":"simulate_lap","text":"<pre><code>simulate_lap(track: TrackData, model: VehicleModel, config: SimulationConfig) -&gt; LapResult\n</code></pre> <p>Run lap simulation against a vehicle-model API backend.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track geometry and derived arc-length-domain quantities.</p> required <code>model</code> <code>VehicleModel</code> <p>Vehicle-model backend implementing <code>VehicleModel</code>.</p> required <code>config</code> <code>SimulationConfig</code> <p>Solver configuration containing runtime and numerical controls.</p> required <p>Returns:</p> Type Description <code>LapResult</code> <p>Full lap simulation result including profile arrays, diagnostics,</p> <code>LapResult</code> <p>and (for transient mode) time/state/control traces.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If track data is invalid.</p> <code>ConfigurationError</code> <p>If model or solver configuration is invalid.</p>"},{"location":"reference/simulation/","title":"Simulation","text":""},{"location":"reference/simulation/#apexsim.simulation","title":"simulation","text":"<p>Simulation solvers and runners.</p>"},{"location":"reference/simulation/#apexsim.simulation.LapResult","title":"LapResult  <code>dataclass</code>","text":"<p>Simulation output arrays and integrated metrics.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track geometry used for the simulation.</p> required <code>speed</code> <code>ndarray</code> <p>Converged speed trace along arc length [m/s].</p> required <code>longitudinal_accel</code> <code>ndarray</code> <p>Net longitudinal acceleration trace [m/s^2].</p> required <code>lateral_accel</code> <code>ndarray</code> <p>Lateral acceleration trace [m/s^2].</p> required <code>yaw_moment</code> <code>ndarray</code> <p>Yaw-moment trace [N*m]. In quasi-static mode this is zero by model assumption. In transient mode this is reported as the dynamic yaw residual <code>I_z * dr/dt</code>.</p> required <code>front_axle_load</code> <code>ndarray</code> <p>Front-axle normal load trace [N].</p> required <code>rear_axle_load</code> <code>ndarray</code> <p>Rear-axle normal load trace [N].</p> required <code>power</code> <code>ndarray</code> <p>Tractive power trace [W].</p> required <code>energy</code> <code>float</code> <p>Integrated positive tractive energy [J].</p> required <code>lap_time</code> <code>float</code> <p>Integrated lap time [s].</p> required <code>solver_mode</code> <code>str</code> <p>Solver mode used for this lap result.</p> <code>'quasi_static'</code> <code>time</code> <code>ndarray | None</code> <p>Optional cumulative time trace [s] for transient solver mode.</p> <code>None</code> <code>vx</code> <code>ndarray | None</code> <p>Optional body-frame longitudinal speed trace [m/s].</p> <code>None</code> <code>vy</code> <code>ndarray | None</code> <p>Optional body-frame lateral speed trace [m/s].</p> <code>None</code> <code>yaw_rate</code> <code>ndarray | None</code> <p>Optional yaw-rate trace [rad/s].</p> <code>None</code> <code>steer_cmd</code> <code>ndarray | None</code> <p>Optional steering command trace [rad].</p> <code>None</code> <code>ax_cmd</code> <code>ndarray | None</code> <p>Optional longitudinal acceleration command trace [m/s^2].</p> <code>None</code>"},{"location":"reference/simulation/#apexsim.simulation.ModelDiagnostics","title":"ModelDiagnostics  <code>dataclass</code>","text":"<p>Per-track-point diagnostics exposed by a vehicle model.</p> <p>Parameters:</p> Name Type Description Default <code>yaw_moment</code> <code>float</code> <p>Net yaw moment at the operating point [N*m].</p> required <code>front_axle_load</code> <code>float</code> <p>Front-axle normal load [N].</p> required <code>rear_axle_load</code> <code>float</code> <p>Rear-axle normal load [N].</p> required <code>power</code> <code>float</code> <p>Instantaneous tractive power [W].</p> required"},{"location":"reference/simulation/#apexsim.simulation.NumericsConfig","title":"NumericsConfig  <code>dataclass</code>","text":"<p>Numerical controls for the lap-time solver.</p> <p>Parameters:</p> Name Type Description Default <code>min_speed</code> <code>float</code> <p>Numerical floor for speed to avoid singular divisions [m/s].</p> <code>DEFAULT_MIN_SPEED</code> <code>lateral_envelope_max_iterations</code> <code>int</code> <p>Maximum fixed-point iterations for the lateral-speed envelope solver.</p> <code>DEFAULT_LATERAL_ENVELOPE_MAX_ITERATIONS</code> <code>lateral_envelope_convergence_tolerance</code> <code>float</code> <p>Early-stop threshold for the lateral envelope fixed-point update (<code>max |v_k - v_{k-1}|</code>) [m/s].</p> <code>DEFAULT_LATERAL_ENVELOPE_CONVERGENCE_TOLERANCE</code> <code>transient_step</code> <code>float</code> <p>Integration step for optional transient refinement [s].</p> <code>DEFAULT_TRANSIENT_STEP</code>"},{"location":"reference/simulation/#apexsim.simulation.NumericsConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate numerical solver settings.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any solver configuration value violates its bound.</p>"},{"location":"reference/simulation/#apexsim.simulation.PidSpeedSchedule","title":"PidSpeedSchedule  <code>dataclass</code>","text":"<p>Piecewise-linear speed-dependent gain schedule.</p> <p>Parameters:</p> Name Type Description Default <code>speed_nodes_mps</code> <code>tuple[float, ...]</code> <p>Monotonic speed nodes [m/s].</p> required <code>values</code> <code>tuple[float, ...]</code> <p>Gain values at <code>speed_nodes_mps</code>.</p> required"},{"location":"reference/simulation/#apexsim.simulation.PidSpeedSchedule.evaluate","title":"evaluate","text":"<pre><code>evaluate(speed_mps: float) -&gt; float\n</code></pre> <p>Evaluate schedule at one speed by linear interpolation with clamping.</p> <p>Parameters:</p> Name Type Description Default <code>speed_mps</code> <code>float</code> <p>Evaluation speed [m/s].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Interpolated schedule value.</p>"},{"location":"reference/simulation/#apexsim.simulation.PidSpeedSchedule.evaluate_many","title":"evaluate_many","text":"<pre><code>evaluate_many(speeds_mps: ndarray) -&gt; np.ndarray\n</code></pre> <p>Evaluate schedule at multiple speeds.</p> <p>Parameters:</p> Name Type Description Default <code>speeds_mps</code> <code>ndarray</code> <p>Evaluation speeds [m/s].</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Interpolated values for each input speed.</p>"},{"location":"reference/simulation/#apexsim.simulation.PidSpeedSchedule.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate PWL node/value vectors.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If nodes or values are inconsistent.</p>"},{"location":"reference/simulation/#apexsim.simulation.RuntimeConfig","title":"RuntimeConfig  <code>dataclass</code>","text":"<p>Runtime controls that define simulation scenario boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>max_speed</code> <code>float</code> <p>Hard speed cap used by the quasi-steady profile solver [m/s].</p> required <code>initial_speed</code> <code>float | None</code> <p>Optional initial speed at the first track sample [m/s]. If <code>None</code>, the solver keeps the legacy behavior and initializes from lateral/global speed limits.</p> <code>DEFAULT_INITIAL_SPEED</code> <code>enable_transient_refinement</code> <code>bool</code> <p>Deprecated transient enable flag retained for one compatibility cycle.</p> <code>DEFAULT_ENABLE_TRANSIENT_REFINEMENT</code> <code>solver_mode</code> <code>str</code> <p>Solver mode identifier (<code>\"quasi_static\"</code> or <code>\"transient_oc\"</code>).</p> <code>DEFAULT_SOLVER_MODE</code> <code>compute_backend</code> <code>str</code> <p>Numerical backend identifier (<code>numpy</code>, <code>numba</code>, or <code>torch</code>).</p> <code>DEFAULT_COMPUTE_BACKEND</code> <code>torch_device</code> <code>str</code> <p>Torch device identifier. <code>numpy</code> and <code>numba</code> are CPU-only backends and therefore require <code>torch_device='cpu'</code>.</p> <code>DEFAULT_TORCH_DEVICE</code> <code>torch_compile</code> <code>bool</code> <p>Reserved flag for future compile support in the <code>torch</code> backend. Must currently remain <code>False</code>.</p> <code>DEFAULT_ENABLE_TORCH_COMPILE</code>"},{"location":"reference/simulation/#apexsim.simulation.RuntimeConfig.validate","title":"validate","text":"<pre><code>validate(numerics: NumericsConfig) -&gt; None\n</code></pre> <p>Validate runtime controls against solver numerics.</p> <p>Parameters:</p> Name Type Description Default <code>numerics</code> <code>NumericsConfig</code> <p>Numerical parameter set used by the solver.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If runtime controls are inconsistent with solver numerics or backend requirements.</p>"},{"location":"reference/simulation/#apexsim.simulation.SimulationConfig","title":"SimulationConfig  <code>dataclass</code>","text":"<p>Top-level solver config composed of runtime and numerics.</p> <p>Parameters:</p> Name Type Description Default <code>runtime</code> <code>RuntimeConfig</code> <p>Scenario and runtime controls, independent of physical car data.</p> required <code>numerics</code> <code>NumericsConfig</code> <p>Discretization and convergence controls for numerical solving.</p> required <code>transient</code> <code>TransientConfig</code> <p>Transient-solver numerical and runtime controls.</p> <code>TransientConfig()</code>"},{"location":"reference/simulation/#apexsim.simulation.SimulationConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate combined simulation settings.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If runtime or numerical configuration values violate their bounds.</p>"},{"location":"reference/simulation/#apexsim.simulation.TorchSpeedProfileResult","title":"TorchSpeedProfileResult  <code>dataclass</code>","text":"<p>Differentiable torch speed-profile output tensors.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>Any</code> <p>Converged speed trace along track arc length [m/s].</p> required <code>longitudinal_accel</code> <code>Any</code> <p>Net longitudinal acceleration trace [m/s^2].</p> required <code>lateral_accel</code> <code>Any</code> <p>Lateral acceleration trace [m/s^2].</p> required <code>lateral_envelope_iterations</code> <code>int</code> <p>Number of fixed-point iterations used for lateral envelope convergence.</p> required <code>lap_time</code> <code>Any</code> <p>Integrated lap time over one track traversal [s].</p> required"},{"location":"reference/simulation/#apexsim.simulation.TorchSpeedProfileResult.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; SpeedProfileResult\n</code></pre> <p>Convert torch tensor result to <code>SpeedProfileResult</code>.</p> <p>Returns:</p> Type Description <code>SpeedProfileResult</code> <p>NumPy-based speed-profile result detached from autograd graph.</p>"},{"location":"reference/simulation/#apexsim.simulation.TorchTransientProfileResult","title":"TorchTransientProfileResult  <code>dataclass</code>","text":"<p>Differentiable torch transient-lap result tensors.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>Any</code> <p>Total speed trace [m/s].</p> required <code>longitudinal_accel</code> <code>Any</code> <p>Net longitudinal acceleration trace [m/s^2].</p> required <code>lateral_accel</code> <code>Any</code> <p>Lateral acceleration trace [m/s^2].</p> required <code>lap_time</code> <code>Any</code> <p>Integrated lap time [s].</p> required <code>time</code> <code>Any</code> <p>Cumulative time trace [s].</p> required <code>vx</code> <code>Any</code> <p>Body-frame longitudinal speed trace [m/s].</p> required <code>vy</code> <code>Any</code> <p>Body-frame lateral speed trace [m/s].</p> required <code>yaw_rate</code> <code>Any</code> <p>Yaw-rate trace [rad/s].</p> required <code>steer_cmd</code> <code>Any</code> <p>Steering command trace [rad].</p> required <code>ax_cmd</code> <code>Any</code> <p>Longitudinal acceleration command trace [m/s^2].</p> required <code>objective_value</code> <code>Any</code> <p>Final OC objective value.</p> required"},{"location":"reference/simulation/#apexsim.simulation.TorchTransientProfileResult.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy() -&gt; TransientProfileResult\n</code></pre> <p>Convert differentiable tensors to NumPy arrays.</p> <p>Returns:</p> Type Description <code>TransientProfileResult</code> <p>NumPy transient profile result detached from autograd graph.</p>"},{"location":"reference/simulation/#apexsim.simulation.TransientConfig","title":"TransientConfig  <code>dataclass</code>","text":"<p>Top-level transient OC configuration container.</p> <p>Parameters:</p> Name Type Description Default <code>numerics</code> <code>TransientNumericsConfig</code> <p>Transient numerical controls.</p> <code>TransientNumericsConfig()</code> <code>runtime</code> <code>TransientRuntimeConfig</code> <p>Transient runtime controls.</p> <code>TransientRuntimeConfig()</code>"},{"location":"reference/simulation/#apexsim.simulation.TransientConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate transient configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If transient settings are inconsistent.</p>"},{"location":"reference/simulation/#apexsim.simulation.TransientNumericsConfig","title":"TransientNumericsConfig  <code>dataclass</code>","text":"<p>Numerical controls for the transient OC lap-time solver.</p> <p>Parameters:</p> Name Type Description Default <code>integration_method</code> <code>str</code> <p>Integration method used in state propagation (<code>\"euler\"</code> or <code>\"rk4\"</code>).</p> <code>DEFAULT_TRANSIENT_INTEGRATION_METHOD</code> <code>max_iterations</code> <code>int</code> <p>Maximum optimization iterations.</p> <code>DEFAULT_TRANSIENT_MAX_ITERATIONS</code> <code>tolerance</code> <code>float</code> <p>Optimization convergence tolerance.</p> <code>DEFAULT_TRANSIENT_TOLERANCE</code> <code>min_time_step</code> <code>float</code> <p>Minimum integration step used during arc-length to time conversion [s].</p> <code>DEFAULT_TRANSIENT_MIN_TIME_STEP</code> <code>max_time_step</code> <code>float</code> <p>Maximum integration step used during arc-length to time conversion [s].</p> <code>DEFAULT_TRANSIENT_MAX_TIME_STEP</code> <code>lateral_constraint_weight</code> <code>float</code> <p>Penalty weight for lateral feasibility violations.</p> <code>DEFAULT_TRANSIENT_LATERAL_CONSTRAINT_WEIGHT</code> <code>tracking_weight</code> <code>float</code> <p>Penalty weight for transient path-tracking terms.</p> <code>DEFAULT_TRANSIENT_TRACKING_WEIGHT</code> <code>control_smoothness_weight</code> <code>float</code> <p>Penalty weight for control variation between neighboring samples.</p> <code>DEFAULT_TRANSIENT_CONTROL_SMOOTHNESS_WEIGHT</code> <code>control_interval</code> <code>int</code> <p>Arc-length sample interval used for optimization controls before interpolation to full track resolution.</p> <code>DEFAULT_TRANSIENT_CONTROL_INTERVAL</code> <code>optimizer_learning_rate</code> <code>float</code> <p>Initial optimizer learning rate.</p> <code>DEFAULT_TRANSIENT_OPTIMIZER_LEARNING_RATE</code> <code>optimizer_lbfgs_max_iter</code> <code>int</code> <p>Maximum iterations for one LBFGS step.</p> <code>DEFAULT_TRANSIENT_OPTIMIZER_LBFGS_MAX_ITER</code> <code>optimizer_adam_steps</code> <code>int</code> <p>Number of Adam fallback steps.</p> <code>DEFAULT_TRANSIENT_OPTIMIZER_ADAM_STEPS</code> <code>pid_longitudinal_kp</code> <code>float</code> <p>Proportional gain for longitudinal speed tracking.</p> <code>DEFAULT_TRANSIENT_PID_LONGITUDINAL_KP</code> <code>pid_longitudinal_ki</code> <code>float</code> <p>Integral gain for longitudinal speed tracking.</p> <code>DEFAULT_TRANSIENT_PID_LONGITUDINAL_KI</code> <code>pid_longitudinal_kd</code> <code>float</code> <p>Derivative gain for longitudinal speed tracking.</p> <code>DEFAULT_TRANSIENT_PID_LONGITUDINAL_KD</code> <code>pid_steer_kp</code> <code>float</code> <p>Proportional gain for yaw-rate steering feedback.</p> <code>DEFAULT_TRANSIENT_PID_STEER_KP</code> <code>pid_steer_ki</code> <code>float</code> <p>Integral gain for yaw-rate steering feedback.</p> <code>DEFAULT_TRANSIENT_PID_STEER_KI</code> <code>pid_steer_kd</code> <code>float</code> <p>Derivative gain for yaw-rate steering feedback.</p> <code>DEFAULT_TRANSIENT_PID_STEER_KD</code> <code>pid_steer_vy_damping</code> <code>float</code> <p>Damping term on lateral velocity for steering stabilization.</p> <code>DEFAULT_TRANSIENT_PID_STEER_VY_DAMPING</code> <code>pid_longitudinal_integral_limit</code> <code>float</code> <p>Absolute clamp for longitudinal PID integrator state.</p> <code>DEFAULT_TRANSIENT_PID_LONGITUDINAL_INTEGRAL_LIMIT</code> <code>pid_steer_integral_limit</code> <code>float</code> <p>Absolute clamp for steering PID integrator state.</p> <code>DEFAULT_TRANSIENT_PID_STEER_INTEGRAL_LIMIT</code> <code>pid_gain_scheduling_mode</code> <code>str</code> <p>PID gain scheduling mode: <code>\"off\"</code>, <code>\"physics_informed\"</code>, or <code>\"custom\"</code>.</p> <code>DEFAULT_TRANSIENT_PID_GAIN_SCHEDULING_MODE</code> <code>pid_gain_scheduling</code> <code>TransientPidGainSchedulingConfig | None</code> <p>Optional custom schedule table set used when <code>pid_gain_scheduling_mode=\"custom\"</code>.</p> <code>None</code>"},{"location":"reference/simulation/#apexsim.simulation.TransientNumericsConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate transient numerical controls.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If numerical controls violate required bounds.</p>"},{"location":"reference/simulation/#apexsim.simulation.TransientPidGainSchedulingConfig","title":"TransientPidGainSchedulingConfig  <code>dataclass</code>","text":"<p>Speed-dependent PID gain schedules.</p> <p>Longitudinal schedules are used by point-mass and single-track PID drivers. Steering schedules are used by single-track PID drivers.</p>"},{"location":"reference/simulation/#apexsim.simulation.TransientPidGainSchedulingConfig.has_longitudinal_schedules","title":"has_longitudinal_schedules","text":"<pre><code>has_longitudinal_schedules() -&gt; bool\n</code></pre> <p>Return whether all longitudinal schedules are present.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> when longitudinal <code>kp</code>, <code>ki</code>, and <code>kd</code> schedules are</p> <code>bool</code> <p>all configured.</p>"},{"location":"reference/simulation/#apexsim.simulation.TransientPidGainSchedulingConfig.has_steering_schedules","title":"has_steering_schedules","text":"<pre><code>has_steering_schedules() -&gt; bool\n</code></pre> <p>Return whether all steering schedules are present.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> when steering <code>kp</code>, <code>ki</code>, <code>kd</code>, and lateral-velocity</p> <code>bool</code> <p>damping schedules are all configured.</p>"},{"location":"reference/simulation/#apexsim.simulation.TransientPidGainSchedulingConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate scheduling config and node-grid consistency.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If schedules are inconsistent.</p>"},{"location":"reference/simulation/#apexsim.simulation.TransientProfileResult","title":"TransientProfileResult  <code>dataclass</code>","text":"<p>Transient speed-profile and state traces in arc-length sample order.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>ndarray</code> <p>Total speed trace [m/s].</p> required <code>longitudinal_accel</code> <code>ndarray</code> <p>Net longitudinal acceleration trace [m/s^2].</p> required <code>lateral_accel</code> <code>ndarray</code> <p>Lateral acceleration trace [m/s^2].</p> required <code>lap_time</code> <code>float</code> <p>Integrated lap time [s].</p> required <code>time</code> <code>ndarray</code> <p>Cumulative time trace [s].</p> required <code>vx</code> <code>ndarray</code> <p>Body-frame longitudinal speed trace [m/s].</p> required <code>vy</code> <code>ndarray</code> <p>Body-frame lateral speed trace [m/s].</p> required <code>yaw_rate</code> <code>ndarray</code> <p>Yaw-rate trace [rad/s].</p> required <code>steer_cmd</code> <code>ndarray</code> <p>Steering command trace [rad].</p> required <code>ax_cmd</code> <code>ndarray</code> <p>Longitudinal acceleration command trace [m/s^2].</p> required <code>objective_value</code> <code>float</code> <p>Final OC objective value.</p> required"},{"location":"reference/simulation/#apexsim.simulation.TransientRuntimeConfig","title":"TransientRuntimeConfig  <code>dataclass</code>","text":"<p>Runtime controls for transient OC solve behavior.</p> <p>Parameters:</p> Name Type Description Default <code>ode_backend_policy</code> <code>str</code> <p>ODE-backend selection policy.</p> <code>DEFAULT_TRANSIENT_ODE_BACKEND_POLICY</code> <code>optimizer_backend_policy</code> <code>str</code> <p>Optimizer-backend selection policy.</p> <code>DEFAULT_TRANSIENT_OPTIMIZER_BACKEND_POLICY</code> <code>driver_model</code> <code>str</code> <p>Driver/control strategy used inside the transient solver. <code>\"pid\"</code> applies deterministic closed-loop PID control. <code>\"optimal_control\"</code> runs full control optimization.</p> <code>DEFAULT_TRANSIENT_DRIVER_MODEL</code> <code>deterministic_seed</code> <code>int | None</code> <p>Optional deterministic seed used by stochastic optimizer fallbacks.</p> <code>None</code> <code>verbosity</code> <code>int</code> <p>Verbosity level for transient solver logging.</p> <code>DEFAULT_TRANSIENT_OPTIMIZER_VERBOSE</code>"},{"location":"reference/simulation/#apexsim.simulation.TransientRuntimeConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate transient runtime controls.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If runtime controls violate required bounds.</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModel","title":"VehicleModel","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol required by the quasi-steady lap-time solver.</p> <p>Any vehicle model (single-track, point-mass, twin-track, ...) can be used by the simulation pipeline as long as it implements this interface.</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModel.diagnostics","title":"diagnostics","text":"<pre><code>diagnostics(speed: float, longitudinal_accel: float, lateral_accel: float, curvature: float) -&gt; ModelDiagnostics\n</code></pre> <p>Return diagnostic quantities used by analysis and plotting.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>longitudinal_accel</code> <code>float</code> <p>Net longitudinal acceleration along path tangent [m/s^2].</p> required <code>lateral_accel</code> <code>float</code> <p>Lateral acceleration [m/s^2].</p> required <code>curvature</code> <code>float</code> <p>Signed track curvature at the sample point [1/m].</p> required <p>Returns:</p> Type Description <code>ModelDiagnostics</code> <p>Diagnostic signals for post-processing and visualization.</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModel.lateral_accel_limit","title":"lateral_accel_limit","text":"<pre><code>lateral_accel_limit(speed: float, banking: float) -&gt; float\n</code></pre> <p>Return lateral acceleration capability at the given operating point.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed at the queried operating point [m/s].</p> required <code>banking</code> <code>float</code> <p>Track banking angle at the queried point [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum quasi-steady lateral acceleration magnitude [m/s^2].</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModel.max_longitudinal_accel","title":"max_longitudinal_accel","text":"<pre><code>max_longitudinal_accel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return net forward acceleration limit along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum net acceleration along the path tangent [m/s^2].</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModel.max_longitudinal_decel","title":"max_longitudinal_decel","text":"<pre><code>max_longitudinal_decel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return available deceleration magnitude along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum non-negative deceleration magnitude along path tangent [m/s^2].</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModel.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate model parameters and configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If model parameters violate required physical or numerical constraints.</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModelBase","title":"VehicleModelBase","text":"<p>               Bases: <code>ABC</code></p> <p>Nominal OOP base class for solver-compatible vehicle models.</p> <p>The solver continues to depend on :class:<code>VehicleModel</code> (Protocol) for structural flexibility. Concrete library backends can additionally subclass this abstract base class to make inheritance-based contracts and code sharing explicit.</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModelBase.diagnostics","title":"diagnostics  <code>abstractmethod</code>","text":"<pre><code>diagnostics(speed: float, longitudinal_accel: float, lateral_accel: float, curvature: float) -&gt; ModelDiagnostics\n</code></pre> <p>Return diagnostic quantities used by analysis and plotting.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>longitudinal_accel</code> <code>float</code> <p>Net longitudinal acceleration along path tangent [m/s^2].</p> required <code>lateral_accel</code> <code>float</code> <p>Lateral acceleration [m/s^2].</p> required <code>curvature</code> <code>float</code> <p>Signed track curvature at the sample point [1/m].</p> required <p>Returns:</p> Type Description <code>ModelDiagnostics</code> <p>Diagnostic signals for post-processing and visualization.</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModelBase.lateral_accel_limit","title":"lateral_accel_limit  <code>abstractmethod</code>","text":"<pre><code>lateral_accel_limit(speed: float, banking: float) -&gt; float\n</code></pre> <p>Return lateral acceleration capability at the given operating point.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed at the queried operating point [m/s].</p> required <code>banking</code> <code>float</code> <p>Track banking angle at the queried point [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum quasi-steady lateral acceleration magnitude [m/s^2].</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModelBase.max_longitudinal_accel","title":"max_longitudinal_accel  <code>abstractmethod</code>","text":"<pre><code>max_longitudinal_accel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return net forward acceleration limit along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum net acceleration along the path tangent [m/s^2].</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModelBase.max_longitudinal_decel","title":"max_longitudinal_decel  <code>abstractmethod</code>","text":"<pre><code>max_longitudinal_decel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return available deceleration magnitude along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum non-negative deceleration magnitude along path tangent [m/s^2].</p>"},{"location":"reference/simulation/#apexsim.simulation.VehicleModelBase.validate","title":"validate  <code>abstractmethod</code>","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate model parameters and configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If model parameters violate required physical or numerical constraints.</p>"},{"location":"reference/simulation/#apexsim.simulation.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Resolve lazily imported symbols for public package exports.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name requested from the package namespace.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Exported class or function matching <code>name</code>.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>name</code> is not part of the public export surface.</p>"},{"location":"reference/simulation/#apexsim.simulation.build_simulation_config","title":"build_simulation_config","text":"<pre><code>build_simulation_config(max_speed: float = DEFAULT_MAX_SPEED, initial_speed: float | None = DEFAULT_INITIAL_SPEED, numerics: NumericsConfig | None = None, enable_transient_refinement: bool = DEFAULT_ENABLE_TRANSIENT_REFINEMENT, solver_mode: str | None = None, transient: TransientConfig | None = None, compute_backend: str = DEFAULT_COMPUTE_BACKEND, torch_device: str = DEFAULT_TORCH_DEVICE, torch_compile: bool = DEFAULT_ENABLE_TORCH_COMPILE) -&gt; SimulationConfig\n</code></pre> <p>Build a validated simulation config with sensible numerical defaults.</p> <p>Parameters:</p> Name Type Description Default <code>max_speed</code> <code>float</code> <p>Runtime speed cap for the quasi-steady profile solver [m/s].</p> <code>DEFAULT_MAX_SPEED</code> <code>initial_speed</code> <code>float | None</code> <p>Optional initial speed at the first track sample [m/s]. If <code>None</code>, the solver keeps the legacy behavior and initializes from lateral/global speed limits.</p> <code>DEFAULT_INITIAL_SPEED</code> <code>numerics</code> <code>NumericsConfig | None</code> <p>Optional numerical settings. Defaults to :class:<code>NumericsConfig</code>.</p> <code>None</code> <code>enable_transient_refinement</code> <code>bool</code> <p>Deprecated transient enable flag retained for one compatibility cycle.</p> <code>DEFAULT_ENABLE_TRANSIENT_REFINEMENT</code> <code>solver_mode</code> <code>str | None</code> <p>Optional solver mode identifier. When omitted, defaults to <code>\"quasi_static\"</code>. Allowed values are <code>\"quasi_static\"</code> and <code>\"transient_oc\"</code>.</p> <code>None</code> <code>transient</code> <code>TransientConfig | None</code> <p>Optional transient solver settings.</p> <code>None</code> <code>compute_backend</code> <code>str</code> <p>Numerical backend identifier (<code>numpy</code>, <code>numba</code>, or <code>torch</code>).</p> <code>DEFAULT_COMPUTE_BACKEND</code> <code>torch_device</code> <code>str</code> <p>Torch device identifier. <code>numpy</code> and <code>numba</code> are CPU-only backends and therefore require <code>torch_device='cpu'</code>.</p> <code>DEFAULT_TORCH_DEVICE</code> <code>torch_compile</code> <code>bool</code> <p>Reserved flag for future compile support in the <code>torch</code> backend. Must currently remain <code>False</code>.</p> <code>DEFAULT_ENABLE_TORCH_COMPILE</code> <p>Returns:</p> Type Description <code>SimulationConfig</code> <p>Fully validated simulation configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If assembled runtime or numerical settings are inconsistent.</p>"},{"location":"reference/tire/","title":"Tire","text":""},{"location":"reference/tire/#apexsim.tire","title":"tire","text":"<p>Tire models and utilities.</p>"},{"location":"reference/tire/#apexsim.tire.AxleTireParameters","title":"AxleTireParameters  <code>dataclass</code>","text":"<p>Separate tire coefficients for front and rear axle.</p> <p>Parameters:</p> Name Type Description Default <code>front</code> <code>PacejkaParameters</code> <p>Front-axle Pacejka coefficients.</p> required <code>rear</code> <code>PacejkaParameters</code> <p>Rear-axle Pacejka coefficients.</p> required"},{"location":"reference/tire/#apexsim.tire.AxleTireParameters.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate both axle parameter sets.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If front or rear coefficient sets are invalid.</p>"},{"location":"reference/tire/#apexsim.tire.PacejkaParameters","title":"PacejkaParameters  <code>dataclass</code>","text":"<p>Pacejka lateral model coefficients and load-sensitivity behavior.</p> <p>The lateral force model uses coefficients <code>B</code>, <code>C</code>, <code>D</code>, <code>E</code> in the Pacejka Magic Formula.  <code>D</code> is the peak lateral force at the reference normal load <code>Fz0</code> [N].  The load-sensitive force is</p> <p>.. math::</p> <pre><code>F_y = D \\\\cdot \\\\frac{F_z}{F_{z0}} \\\\cdot \\\\mu_{\\\\text{scale}} \\\\cdot\n      \\\\sin\\\\!\\\\left(C \\\\arctan\\\\!\\\\left(B\\\\alpha - E(B\\\\alpha -\n      \\\\arctan(B\\\\alpha))\\\\right)\\\\right)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>float</code> <p>Pacejka stiffness factor (-).</p> required <code>C</code> <code>float</code> <p>Pacejka shape factor (-).</p> required <code>D</code> <code>float</code> <p>Peak lateral force at reference normal load <code>reference_load</code> [N].</p> required <code>E</code> <code>float</code> <p>Pacejka curvature factor (-).</p> required <code>reference_load</code> <code>float</code> <p>Reference normal load <code>Fz0</code> [N].</p> required <code>load_sensitivity</code> <code>float</code> <p>Linear scaling of effective friction with load deviation from reference (-/N).</p> required <code>min_mu_scale</code> <code>float</code> <p>Lower bound for load-scaled friction multiplier (-).</p> required"},{"location":"reference/tire/#apexsim.tire.PacejkaParameters.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate physical and numerical constraints for coefficients.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any coefficient violates required bounds.</p>"},{"location":"reference/tire/#apexsim.tire.axle_lateral_forces","title":"axle_lateral_forces","text":"<pre><code>axle_lateral_forces(front_slip_angle: float, rear_slip_angle: float, front_axle_load: float, rear_axle_load: float, axle_params: AxleTireParameters) -&gt; tuple[float, float]\n</code></pre> <p>Compute total front/rear axle lateral force for single_track-equivalent tires.</p> <p>Parameters:</p> Name Type Description Default <code>front_slip_angle</code> <code>float</code> <p>Front axle equivalent slip angle [rad].</p> required <code>rear_slip_angle</code> <code>float</code> <p>Rear axle equivalent slip angle [rad].</p> required <code>front_axle_load</code> <code>float</code> <p>Total front axle normal load [N].</p> required <code>rear_axle_load</code> <code>float</code> <p>Total rear axle normal load [N].</p> required <code>axle_params</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka parameter sets.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple <code>(Fy_front, Fy_rear)</code> with axle lateral forces [N].</p>"},{"location":"reference/tire/#apexsim.tire.default_axle_tire_parameters","title":"default_axle_tire_parameters","text":"<pre><code>default_axle_tire_parameters() -&gt; AxleTireParameters\n</code></pre> <p>Create a default high-downforce race-car tire parameterization.</p> <p>Returns:</p> Type Description <code>AxleTireParameters</code> <p>Front and rear Pacejka parameter sets tuned for a high-downforce car.</p>"},{"location":"reference/tire/#apexsim.tire.magic_formula_lateral","title":"magic_formula_lateral","text":"<pre><code>magic_formula_lateral(slip_angle: float | FloatArray, normal_load: float | FloatArray, params: PacejkaParameters) -&gt; float | FloatArray\n</code></pre> <p>Evaluate lateral tire force with load-sensitive Pacejka coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>slip_angle</code> <code>float | FloatArray</code> <p>Tire slip angle [rad].</p> required <code>normal_load</code> <code>float | FloatArray</code> <p>Tire normal load [N].</p> required <code>params</code> <code>PacejkaParameters</code> <p>Pacejka coefficient set.</p> required <p>Returns:</p> Type Description <code>float | FloatArray</code> <p>Lateral force [N]. Sign follows slip-angle sign.</p>"},{"location":"reference/track/","title":"Track","text":""},{"location":"reference/track/#apexsim.track","title":"track","text":"<p>Track loading, synthetic layout generation, and geometry processing.</p>"},{"location":"reference/track/#apexsim.track.TrackData","title":"TrackData  <code>dataclass</code>","text":"<p>Processed track representation in arc-length domain.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Global x-coordinate samples along the centerline [m].</p> required <code>y</code> <code>ndarray</code> <p>Global y-coordinate samples along the centerline [m].</p> required <code>elevation</code> <code>ndarray</code> <p>Elevation samples along the centerline [m].</p> required <code>banking</code> <code>ndarray</code> <p>Banking angle samples [rad].</p> required <code>arc_length</code> <code>ndarray</code> <p>Monotonic arc-length coordinate [m].</p> required <code>heading</code> <code>ndarray</code> <p>Centerline heading angle [rad].</p> required <code>curvature</code> <code>ndarray</code> <p>Signed curvature along arc length [1/m].</p> required <code>grade</code> <code>ndarray</code> <p>Longitudinal grade <code>dz/ds</code> (-).</p> required"},{"location":"reference/track/#apexsim.track.TrackData.length","title":"length  <code>property</code>","text":"<pre><code>length: float\n</code></pre> <p>Track length [m].</p> <p>Returns:</p> Type Description <code>float</code> <p>Final arc-length value of the discretized track [m].</p>"},{"location":"reference/track/#apexsim.track.TrackData.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate consistency of all track arrays.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If array lengths, arc length monotonicity, or numeric validity checks fail.</p>"},{"location":"reference/track/#apexsim.track.build_circular_track","title":"build_circular_track","text":"<pre><code>build_circular_track(radius: float = DEFAULT_CIRCLE_RADIUS, sample_count: int = DEFAULT_CIRCLE_SAMPLE_COUNT, clockwise: bool = False, elevation: float = 0.0, banking: float = 0.0) -&gt; TrackData\n</code></pre> <p>Build a circular closed-loop track with approximately constant curvature.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Circle radius [m].</p> <code>DEFAULT_CIRCLE_RADIUS</code> <code>sample_count</code> <code>int</code> <p>Number of unique samples around the circle.</p> <code>DEFAULT_CIRCLE_SAMPLE_COUNT</code> <code>clockwise</code> <code>bool</code> <p>Whether to traverse the circle clockwise.</p> <code>False</code> <code>elevation</code> <code>float</code> <p>Constant elevation value along the track [m].</p> <code>0.0</code> <code>banking</code> <code>float</code> <p>Constant banking angle along the track [rad].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrackData</code> <p>Validated circular <code>TrackData</code> representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If geometric input values are outside valid bounds.</p>"},{"location":"reference/track/#apexsim.track.build_figure_eight_track","title":"build_figure_eight_track","text":"<pre><code>build_figure_eight_track(lobe_radius: float = DEFAULT_FIGURE_EIGHT_RADIUS, sample_count: int = DEFAULT_FIGURE_EIGHT_SAMPLE_COUNT, elevation: float = 0.0, banking: float = 0.0) -&gt; TrackData\n</code></pre> <p>Build a closed figure-eight track using a Gerono lemniscate centerline.</p> <p>Parameters:</p> Name Type Description Default <code>lobe_radius</code> <code>float</code> <p>Characteristic lobe radius scaling the layout [m].</p> <code>DEFAULT_FIGURE_EIGHT_RADIUS</code> <code>sample_count</code> <code>int</code> <p>Number of unique samples along the centerline.</p> <code>DEFAULT_FIGURE_EIGHT_SAMPLE_COUNT</code> <code>elevation</code> <code>float</code> <p>Constant elevation value along the track [m].</p> <code>0.0</code> <code>banking</code> <code>float</code> <p>Constant banking angle along the track [rad].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrackData</code> <p>Validated figure-eight <code>TrackData</code> representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If geometric input values are outside valid bounds.</p>"},{"location":"reference/track/#apexsim.track.build_straight_track","title":"build_straight_track","text":"<pre><code>build_straight_track(length: float = DEFAULT_STRAIGHT_LENGTH, sample_count: int = DEFAULT_STRAIGHT_SAMPLE_COUNT, elevation: float = 0.0, banking: float = 0.0) -&gt; TrackData\n</code></pre> <p>Build a straight track centerline with constant elevation and banking.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>Total straight-line track length [m].</p> <code>DEFAULT_STRAIGHT_LENGTH</code> <code>sample_count</code> <code>int</code> <p>Number of centerline samples.</p> <code>DEFAULT_STRAIGHT_SAMPLE_COUNT</code> <code>elevation</code> <code>float</code> <p>Constant elevation value along the track [m].</p> <code>0.0</code> <code>banking</code> <code>float</code> <p>Constant banking angle along the track [rad].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrackData</code> <p>Validated straight <code>TrackData</code> representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If geometric input values are outside valid bounds.</p>"},{"location":"reference/track/#apexsim.track.load_track_csv","title":"load_track_csv","text":"<pre><code>load_track_csv(path: str | Path) -&gt; TrackData\n</code></pre> <p>Load a track CSV into <code>TrackData</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to a CSV containing <code>x</code>, <code>y</code>, <code>elevation</code>, and <code>banking</code>.</p> required <p>Returns:</p> Type Description <code>TrackData</code> <p>Parsed and validated track representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If the file does not exist, has an invalid schema, or contains too few rows.</p>"},{"location":"reference/vehicle/","title":"Vehicle","text":""},{"location":"reference/vehicle/#apexsim.vehicle","title":"vehicle","text":"<p>Vehicle models and parameters.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.ControlInput","title":"ControlInput  <code>dataclass</code>","text":"<p>Control inputs for the single-track model.</p> <p>Parameters:</p> Name Type Description Default <code>steer</code> <code>float</code> <p>Front-wheel steering angle [rad].</p> required <code>longitudinal_accel_cmd</code> <code>float</code> <p>Commanded longitudinal acceleration [m/s^2].</p> required"},{"location":"reference/vehicle/#apexsim.vehicle.ForceBalance","title":"ForceBalance  <code>dataclass</code>","text":"<p>Force-balance quantities used for analysis and integration.</p> <p>Parameters:</p> Name Type Description Default <code>front_slip_angle</code> <code>float</code> <p>Front equivalent slip angle [rad].</p> required <code>rear_slip_angle</code> <code>float</code> <p>Rear equivalent slip angle [rad].</p> required <code>front_lateral_force</code> <code>float</code> <p>Front-axle lateral tire force [N].</p> required <code>rear_lateral_force</code> <code>float</code> <p>Rear-axle lateral tire force [N].</p> required <code>yaw_moment</code> <code>float</code> <p>Net yaw moment about center of gravity [N*m].</p> required"},{"location":"reference/vehicle/#apexsim.vehicle.PointMassCalibrationResult","title":"PointMassCalibrationResult  <code>dataclass</code>","text":"<p>Calibration outputs for matching point-mass lateral limits to single_track behavior.</p> <p>Parameters:</p> Name Type Description Default <code>friction_coefficient</code> <code>float</code> <p>Identified isotropic friction coefficient (-).</p> required <code>speed_samples</code> <code>ndarray</code> <p>Calibration speed samples used by the identification [m/s].</p> required <code>single_track_lateral_limit</code> <code>ndarray</code> <p>SingleTrack-model lateral limit evaluated at <code>speed_samples</code> [m/s^2].</p> required <code>normal_accel_limit</code> <code>ndarray</code> <p>Point-mass normal acceleration budget evaluated at <code>speed_samples</code> [m/s^2].</p> required <code>mu_samples</code> <code>ndarray</code> <p>Per-sample effective friction ratios computed as <code>single_track_lateral_limit / normal_accel_limit</code> (-).</p> required"},{"location":"reference/vehicle/#apexsim.vehicle.PointMassModel","title":"PointMassModel","text":"<p>               Bases: <code>PointMassTorchBackendMixin</code>, <code>PointMassNumbaBackendMixin</code>, <code>PointMassPhysicalMixin</code>, <code>EnvelopeVehicleModel</code></p> <p>Vehicle-model API implementation for a point-mass backend.</p> <p>The class is intentionally composed from separate OOP layers:</p> <ul> <li><code>PointMassPhysicalMixin</code> for backend-agnostic physics,</li> <li><code>PointMassNumbaBackendMixin</code> for numba-specific solver adapter API,</li> <li><code>PointMassTorchBackendMixin</code> for torch-specific solver adapter API.</li> </ul>"},{"location":"reference/vehicle/#apexsim.vehicle.PointMassModel.__init__","title":"__init__","text":"<pre><code>__init__(vehicle: VehicleParameters, physics: PointMassPhysics) -&gt; None\n</code></pre> <p>Initialize point-mass solver backend.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for mass, aero, and axle split.</p> required <code>physics</code> <code>PointMassPhysics</code> <p>Point-mass physical model settings.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any provided parameter set is invalid.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.PointMassPhysics","title":"PointMassPhysics  <code>dataclass</code>","text":"<p>Physical inputs for the point-mass lap-time model.</p> <p>Parameters:</p> Name Type Description Default <code>max_drive_accel</code> <code>float</code> <p>Maximum forward tire acceleration on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>8.0</code> <code>max_brake_accel</code> <code>float</code> <p>Maximum braking deceleration magnitude on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>16.0</code> <code>reference_mass</code> <code>float | None</code> <p>Optional reference mass [kg] used to keep acceleration limits force-equivalent under vehicle-mass variation.</p> <code>None</code> <code>friction_coefficient</code> <code>float</code> <p>Isotropic tire-road friction coefficient used for lateral limit and friction-circle coupling (-).</p> <code>1.7</code>"},{"location":"reference/vehicle/#apexsim.vehicle.PointMassPhysics.envelope","title":"envelope  <code>property</code>","text":"<pre><code>envelope: EnvelopePhysics\n</code></pre> <p>Return shared longitudinal envelope limits.</p> <p>Returns:</p> Type Description <code>EnvelopePhysics</code> <p>Internal shared envelope-limit representation used by multiple</p> <code>EnvelopePhysics</code> <p>solver model families.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.PointMassPhysics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate physical model parameters.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If limits or friction settings violate required bounds.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel","title":"SingleTrackDynamicsModel","text":"<p>3-DOF single-track dynamics model using lateral Pacejka tire forces.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel.__init__","title":"__init__","text":"<pre><code>__init__(vehicle: VehicleParameters, tires: AxleTireParameters) -&gt; None\n</code></pre> <p>Initialize the single-track model with validated parameters.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle and chassis parameterization.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka parameter sets.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If vehicle or tire parameters are invalid.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel.derivatives","title":"derivatives","text":"<pre><code>derivatives(state: VehicleState, control: ControlInput) -&gt; VehicleState\n</code></pre> <p>Compute time derivatives for state integration.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state <code>(vx, vy, yaw_rate)</code>.</p> required <code>control</code> <code>ControlInput</code> <p>Steering and longitudinal acceleration command.</p> required <p>Returns:</p> Type Description <code>VehicleState</code> <p>Time derivatives <code>(dvx/dt, dvy/dt, dr/dt)</code> in SI units.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel.force_balance","title":"force_balance","text":"<pre><code>force_balance(state: VehicleState, control: ControlInput) -&gt; ForceBalance\n</code></pre> <p>Evaluate lateral forces and yaw moment for the current state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state <code>(vx, vy, yaw_rate)</code>.</p> required <code>control</code> <code>ControlInput</code> <p>Steering and longitudinal acceleration command.</p> required <p>Returns:</p> Type Description <code>ForceBalance</code> <p>Force-balance terms including slip angles, tire forces, and yaw moment.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel.from_array","title":"from_array  <code>staticmethod</code>","text":"<pre><code>from_array(values: ndarray) -&gt; VehicleState\n</code></pre> <p>Convert ndarray to state dataclass.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>State vector with at least three elements.</p> required <p>Returns:</p> Type Description <code>VehicleState</code> <p>Parsed vehicle state dataclass.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel.sanitize_speed","title":"sanitize_speed  <code>staticmethod</code>","text":"<pre><code>sanitize_speed(speed: float) -&gt; float\n</code></pre> <p>Apply a numerical lower bound to speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Raw speed [m/s].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Speed clamped to a positive lower bound for numerical stability.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel.slip_angles","title":"slip_angles","text":"<pre><code>slip_angles(state: VehicleState, steer: float) -&gt; tuple[float, float]\n</code></pre> <p>Compute front and rear axle slip angles.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state <code>(vx, vy, yaw_rate)</code>.</p> required <code>steer</code> <code>float</code> <p>Front-wheel steering angle [rad].</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple <code>(front_slip_angle, rear_slip_angle)</code>.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackDynamicsModel.to_array","title":"to_array  <code>staticmethod</code>","text":"<pre><code>to_array(state: VehicleState) -&gt; np.ndarray\n</code></pre> <p>Convert state dataclass to ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state dataclass.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector <code>[vx, vy, yaw_rate]</code>.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackModel","title":"SingleTrackModel","text":"<p>               Bases: <code>SingleTrackTorchBackendMixin</code>, <code>SingleTrackNumbaBackendMixin</code>, <code>SingleTrackPhysicalMixin</code>, <code>EnvelopeVehicleModel</code></p> <p>Vehicle-model API implementation for the single-track dynamics backend.</p> <p>The class is intentionally composed from separate OOP layers:</p> <ul> <li><code>SingleTrackPhysicalMixin</code> for backend-agnostic single-track physics,</li> <li><code>SingleTrackNumbaBackendMixin</code> for numba-specific solver adapter API,</li> <li><code>SingleTrackTorchBackendMixin</code> for torch-specific solver adapter API.</li> </ul>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackModel.__init__","title":"__init__","text":"<pre><code>__init__(vehicle: VehicleParameters, tires: AxleTireParameters, physics: SingleTrackPhysics, numerics: SingleTrackNumerics) -&gt; None\n</code></pre> <p>Initialize single-track-backed solver adapter.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for dynamics and aero.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka tire coefficients.</p> required <code>physics</code> <code>SingleTrackPhysics</code> <p>Physical model inputs for the adapter.</p> required <code>numerics</code> <code>SingleTrackNumerics</code> <p>Numerical controls for iterative envelope solving.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any provided parameter set is invalid.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackNumerics","title":"SingleTrackNumerics  <code>dataclass</code>","text":"<p>Numerical controls for the single-track solver model.</p> <p>Parameters:</p> Name Type Description Default <code>min_lateral_accel_limit</code> <code>float</code> <p>Lower bound for lateral-acceleration iteration to avoid degenerate starts [m/s^2].</p> <code>DEFAULT_MIN_LATERAL_ACCEL_LIMIT</code> <code>lateral_limit_max_iterations</code> <code>int</code> <p>Maximum fixed-point iterations for lateral acceleration limit estimation.</p> <code>DEFAULT_LATERAL_LIMIT_MAX_ITERATIONS</code> <code>lateral_limit_convergence_tolerance</code> <code>float</code> <p>Convergence threshold for lateral acceleration fixed-point updates [m/s^2].</p> <code>DEFAULT_LATERAL_LIMIT_CONVERGENCE_TOLERANCE</code>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackNumerics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate numerical settings for the adapter.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If numerical values violate bounds needed for robust convergence.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackPhysics","title":"SingleTrackPhysics  <code>dataclass</code>","text":"<p>Physical and model-level inputs for the single-track solver model.</p> <p>Parameters:</p> Name Type Description Default <code>max_drive_accel</code> <code>float</code> <p>Maximum forward tire acceleration on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>8.0</code> <code>max_brake_accel</code> <code>float</code> <p>Maximum braking deceleration magnitude on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>16.0</code> <code>reference_mass</code> <code>float | None</code> <p>Optional reference mass [kg] used to keep acceleration limits force-equivalent under vehicle-mass variation.</p> <code>None</code> <code>peak_slip_angle</code> <code>float</code> <p>Quasi-steady peak slip angle used to evaluate tire lateral force capability in the envelope iteration [rad].</p> <code>0.12</code> <code>max_steer_angle</code> <code>float</code> <p>Maximum absolute steering angle used in transient control optimization [rad].</p> <code>0.6</code> <code>max_steer_rate</code> <code>float</code> <p>Maximum absolute steering-rate magnitude used in transient control optimization [rad/s].</p> <code>4.0</code>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackPhysics.envelope","title":"envelope  <code>property</code>","text":"<pre><code>envelope: EnvelopePhysics\n</code></pre> <p>Return shared longitudinal envelope limits.</p> <p>Returns:</p> Type Description <code>EnvelopePhysics</code> <p>Internal shared envelope-limit representation used by multiple</p> <code>EnvelopePhysics</code> <p>solver model families.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackPhysics.single_track_lateral","title":"single_track_lateral  <code>property</code>","text":"<pre><code>single_track_lateral: _SingleTrackLateralPhysics\n</code></pre> <p>Return single-track-specific lateral approximation inputs.</p> <p>Returns:</p> Type Description <code>_SingleTrackLateralPhysics</code> <p>Internal single-track-specific lateral-envelope representation.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.SingleTrackPhysics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate physical adapter parameters.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If limits are not strictly positive.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.VehicleParameters","title":"VehicleParameters  <code>dataclass</code>","text":"<p>Vehicle and chassis parameters for lap-time simulation.</p> <p>Parameters:</p> Name Type Description Default <code>mass</code> <code>float</code> <p>Vehicle mass [kg].</p> required <code>yaw_inertia</code> <code>float</code> <p>Yaw moment of inertia [kg*m^2].</p> required <code>cg_height</code> <code>float</code> <p>Center-of-gravity height above ground [m].</p> required <code>wheelbase</code> <code>float</code> <p>Wheelbase [m].</p> required <code>front_track</code> <code>float</code> <p>Front track width [m].</p> required <code>rear_track</code> <code>float</code> <p>Rear track width [m].</p> required <code>front_weight_fraction</code> <code>float</code> <p>Static front axle weight fraction in [0, 1].</p> required <code>cop_position</code> <code>float</code> <p>Center-of-pressure position relative to CoG [m].</p> required <code>lift_coefficient</code> <code>float</code> <p>Aerodynamic lift/downforce coefficient.</p> required <code>drag_coefficient</code> <code>float</code> <p>Aerodynamic drag coefficient.</p> required <code>frontal_area</code> <code>float</code> <p>Frontal reference area [m^2].</p> required <code>roll_rate</code> <code>float</code> <p>Roll rate [N*m/deg].</p> required <code>front_spring_rate</code> <code>float</code> <p>Front spring rate [N/m].</p> required <code>rear_spring_rate</code> <code>float</code> <p>Rear spring rate [N/m].</p> required <code>front_arb_distribution</code> <code>float</code> <p>Front anti-roll-bar distribution in [0, 1].</p> required <code>arb_roll_stiffness_fraction</code> <code>float</code> <p>Fraction of total roll stiffness contributed by anti-roll bars in [0, 1].</p> required <code>front_ride_height</code> <code>float</code> <p>Front ride height [m].</p> required <code>rear_ride_height</code> <code>float</code> <p>Rear ride height [m].</p> required <code>air_density</code> <code>float</code> <p>Air density [kg/m^3].</p> required"},{"location":"reference/vehicle/#apexsim.vehicle.VehicleParameters.cg_to_front_axle","title":"cg_to_front_axle  <code>property</code>","text":"<pre><code>cg_to_front_axle: float\n</code></pre> <p>Distance from center of gravity to front axle.</p> <p>Returns:</p> Type Description <code>float</code> <p>Front axle distance from center of gravity [m].</p>"},{"location":"reference/vehicle/#apexsim.vehicle.VehicleParameters.cg_to_rear_axle","title":"cg_to_rear_axle  <code>property</code>","text":"<pre><code>cg_to_rear_axle: float\n</code></pre> <p>Distance from center of gravity to rear axle.</p> <p>Returns:</p> Type Description <code>float</code> <p>Rear axle distance from center of gravity [m].</p>"},{"location":"reference/vehicle/#apexsim.vehicle.VehicleParameters.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate configuration values before simulation.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any parameter violates its defined bound.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.VehicleState","title":"VehicleState  <code>dataclass</code>","text":"<p>Vehicle state for the single-track model.</p> <p>Parameters:</p> Name Type Description Default <code>vx</code> <code>float</code> <p>Longitudinal velocity in body frame [m/s].</p> required <code>vy</code> <code>float</code> <p>Lateral velocity in body frame [m/s].</p> required <code>yaw_rate</code> <code>float</code> <p>Yaw rate [rad/s].</p> required"},{"location":"reference/vehicle/#apexsim.vehicle.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Resolve lazily imported symbols for public package exports.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name requested from the package namespace.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Exported class or function matching <code>name</code>.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>name</code> is not part of the public export surface.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.build_point_mass_model","title":"build_point_mass_model","text":"<pre><code>build_point_mass_model(vehicle: VehicleParameters, physics: PointMassPhysics | None = None) -&gt; PointMassModel\n</code></pre> <p>Build a point-mass solver model with sensible defaults.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for mass, aero, and axle split.</p> required <code>physics</code> <code>PointMassPhysics | None</code> <p>Optional physical model settings. Defaults to :class:<code>PointMassPhysics</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointMassModel</code> <p>Fully validated solver-facing point-mass model.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.build_single_track_model","title":"build_single_track_model","text":"<pre><code>build_single_track_model(vehicle: VehicleParameters, tires: AxleTireParameters, physics: SingleTrackPhysics | None = None, numerics: SingleTrackNumerics | None = None) -&gt; SingleTrackModel\n</code></pre> <p>Build a single-track solver model with sensible numerical defaults.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for dynamics and aero.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka tire coefficients.</p> required <code>physics</code> <code>SingleTrackPhysics | None</code> <p>Optional physical model inputs for longitudinal and lateral limits. Defaults to :class:<code>SingleTrackPhysics</code>.</p> <code>None</code> <code>numerics</code> <code>SingleTrackNumerics | None</code> <p>Optional numerical controls. Defaults to :class:<code>SingleTrackNumerics</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>SingleTrackModel</code> <p>Fully validated solver-facing single-track model.</p>"},{"location":"reference/vehicle/#apexsim.vehicle.calibrate_point_mass_friction_to_single_track","title":"calibrate_point_mass_friction_to_single_track","text":"<pre><code>calibrate_point_mass_friction_to_single_track(vehicle: VehicleParameters, tires: AxleTireParameters, single_track_physics: SingleTrackPhysics | None = None, single_track_numerics: SingleTrackNumerics | None = None, speed_samples: ndarray | None = None) -&gt; PointMassCalibrationResult\n</code></pre> <p>Calibrate point-mass friction coefficient to single_track lateral capability.</p> <p>The calibration matches the point-mass isotropic lateral limit <code>mu * (g + F_down(v)/m)</code> to the single_track model's quasi-steady lateral limit in a least-squares sense over provided speed samples.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization shared by both models.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Tire parameters used by the single_track model.</p> required <code>single_track_physics</code> <code>SingleTrackPhysics | None</code> <p>Optional single_track-physics settings for calibration. Defaults to :class:<code>apexsim.vehicle.SingleTrackPhysics</code>.</p> <code>None</code> <code>single_track_numerics</code> <code>SingleTrackNumerics | None</code> <p>Optional single_track numerical settings for calibration. Defaults to :class:<code>apexsim.vehicle.SingleTrackNumerics</code>.</p> <code>None</code> <code>speed_samples</code> <code>ndarray | None</code> <p>Optional calibration speeds [m/s]. If omitted, a linear sweep from 10 to 90 m/s is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointMassCalibrationResult</code> <p>Calibration result with identified friction coefficient and</p> <code>PointMassCalibrationResult</code> <p>intermediate traces.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If provided speed samples are empty or contain non-positive entries.</p>"}]}