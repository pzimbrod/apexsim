{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyLapSim Documentation","text":"<p>PyLapSim is a modular lap-time simulation library for race cars with interchangeable vehicle models.</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Guides: onboarding, solver derivation, assumptions, development notes.</li> <li>Examples: step-by-step script walkthroughs (synthetic tracks first, then Spa).</li> <li>API Reference: auto-generated reference from Python docstrings.</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>How to Use</li> <li>API Overview</li> <li>Examples Overview</li> <li>Synthetic Track Walkthrough</li> <li>Spa Walkthrough</li> <li>Solver Derivation</li> <li>Bicycle Model</li> <li>Point-Mass Model</li> <li>Assumptions</li> </ul>"},{"location":"API/","title":"API Overview","text":"<p>This page maps the public API to the engineering workflow.</p> <p>If you are new to the package, start with How to Use.</p>"},{"location":"API/#1-track-inputs","title":"1. Track inputs","text":""},{"location":"API/#load-measuredreal-track-data","title":"Load measured/real track data","text":"<ul> <li><code>pylapsim.track.load_track_csv(path) -&gt; TrackData</code></li> </ul> <p>Required CSV columns:</p> <ul> <li><code>x</code></li> <li><code>y</code></li> <li><code>elevation</code></li> <li><code>banking</code></li> </ul>"},{"location":"API/#generate-synthetic-validation-tracks","title":"Generate synthetic validation tracks","text":"<ul> <li><code>pylapsim.track.build_straight_track(...) -&gt; TrackData</code></li> <li><code>pylapsim.track.build_circular_track(...) -&gt; TrackData</code></li> <li><code>pylapsim.track.build_figure_eight_track(...) -&gt; TrackData</code></li> </ul>"},{"location":"API/#2-vehicle-and-tire-models","title":"2. Vehicle and tire models","text":""},{"location":"API/#shared-physical-vehicle-parameters","title":"Shared physical vehicle parameters","text":"<ul> <li><code>pylapsim.vehicle.VehicleParameters</code></li> </ul>"},{"location":"API/#tire-parameters","title":"Tire parameters","text":"<ul> <li><code>pylapsim.tire.default_axle_tire_parameters() -&gt; AxleTireParameters</code></li> </ul>"},{"location":"API/#bicycle-backend","title":"Bicycle backend","text":"<ul> <li><code>pylapsim.vehicle.BicycleModel(vehicle, tires, physics, numerics)</code></li> <li><code>pylapsim.vehicle.BicyclePhysics</code></li> <li><code>pylapsim.vehicle.BicycleNumerics</code></li> <li><code>pylapsim.vehicle.build_bicycle_model(vehicle, tires, physics=None, numerics=None)</code></li> </ul>"},{"location":"API/#point-mass-backend","title":"Point-mass backend","text":"<ul> <li><code>pylapsim.vehicle.PointMassModel(vehicle, physics)</code></li> <li><code>pylapsim.vehicle.PointMassPhysics</code></li> <li><code>pylapsim.vehicle.build_point_mass_model(vehicle, physics=None)</code></li> <li><code>pylapsim.vehicle.calibrate_point_mass_friction_to_bicycle(vehicle, tires, ...)</code></li> </ul>"},{"location":"API/#3-simulation-setup-and-run","title":"3. Simulation setup and run","text":"<ul> <li><code>pylapsim.simulation.RuntimeConfig</code></li> <li><code>pylapsim.simulation.NumericsConfig</code></li> <li><code>pylapsim.simulation.SimulationConfig</code></li> <li><code>pylapsim.simulation.build_simulation_config(...)</code></li> <li><code>pylapsim.simulation.simulate_lap(track, model, config) -&gt; LapResult</code></li> </ul> <p>Vehicle-model solver contract:</p> <ul> <li><code>validate()</code></li> <li><code>lateral_accel_limit(speed, banking)</code></li> <li><code>max_longitudinal_accel(speed, lateral_accel_required, grade, banking)</code></li> <li><code>max_longitudinal_decel(speed, lateral_accel_required, grade, banking)</code></li> <li><code>diagnostics(speed, longitudinal_accel, lateral_accel, curvature)</code></li> </ul>"},{"location":"API/#4-postprocessing","title":"4. Postprocessing","text":"<ul> <li><code>pylapsim.analysis.compute_kpis(result) -&gt; KpiSummary</code></li> <li><code>pylapsim.analysis.export_standard_plots(result, output_dir)</code></li> <li><code>pylapsim.analysis.export.export_kpi_json(kpis, path)</code></li> </ul> <p><code>LapResult</code> provides:</p> <ul> <li>lap time</li> <li>speed / longitudinal acceleration / lateral acceleration traces</li> <li>yaw moment</li> <li>front/rear axle loads</li> <li>power and energy</li> </ul>"},{"location":"API/#5-minimal-usage-pattern","title":"5. Minimal usage pattern","text":"<pre><code>track = load_track_csv(\"data/spa_francorchamps.csv\")\nmodel = build_bicycle_model(vehicle=vehicle, tires=tires, physics=BicyclePhysics())\nconfig = build_simulation_config(max_speed=115.0)\nresult = simulate_lap(track=track, model=model, config=config)\nkpis = compute_kpis(result)\n</code></pre>"},{"location":"API/#6-related-guides","title":"6. Related guides","text":"<ul> <li>How to Use</li> <li>Examples Overview</li> <li>Solver</li> <li>Bicycle Model</li> <li>Point-Mass Model</li> </ul>"},{"location":"ASSUMPTIONS/","title":"Assumptions and Limitations","text":"<ul> <li>Base vehicle dynamics are 3-DOF (<code>vx</code>, <code>vy</code>, <code>yaw_rate</code>) with bicycle abstraction.</li> <li>Point-mass backend is available as an alternative model and assumes zero yaw moment   in diagnostics by construction.</li> <li>Tire model implements Pacejka-style lateral force only in this phase.</li> <li>Longitudinal force limits are represented by configurable accel/brake envelopes.</li> <li>Point-mass backend uses an isotropic friction-circle with speed-dependent normal   load from aerodynamic downforce.</li> <li>Lateral speed envelope is solved as a fixed-point iteration with configurable   tolerance and iteration cap in <code>SimulationConfig</code>.</li> <li>Aero model uses constant coefficients (<code>c_l</code>, <code>c_d</code>) and rigid ride height.</li> <li>The lap-time solver is decoupled from specific vehicle equations and only   depends on the <code>VehicleModel</code> API contract.</li> <li>Track data expects closed-loop CSV with columns: <code>x</code>, <code>y</code>, <code>elevation</code>, <code>banking</code>.</li> <li>Current Spa import uses real centerline coordinates, while <code>elevation</code> and <code>banking</code> are   set to <code>0.0</code> until higher-fidelity telemetry/map layers are integrated.</li> </ul> <p>These simplifications are intentional to keep the architecture extensible for future modules: full vehicle, powertrain, and energy management.</p>"},{"location":"BICYCLE_MODEL/","title":"Bicycle Model","text":"<p>This document defines the implemented bicycle backend in <code>src/pylapsim/vehicle/bicycle_model.py</code>.</p>"},{"location":"BICYCLE_MODEL/#1-scope","title":"1. Scope","text":"<p>The bicycle model keeps the solver API contract and adds axle-level lateral tire force modeling, quasi-static load transfer, and yaw-moment diagnostics.</p> <p>State assumptions in the lap-time solver context:</p> <ul> <li>quasi-steady envelope evaluation (no transient tire relaxation in profile solve),</li> <li>lateral force from load-sensitive Pacejka at front and rear axle,</li> <li>friction-circle coupling between lateral demand and longitudinal capability,</li> <li>net along-track acceleration after drag and grade corrections.</li> </ul>"},{"location":"BICYCLE_MODEL/#2-lateral-limit","title":"2. Lateral Limit","text":"<p>At speed \\(v\\) and banking angle \\(\\beta\\), the model solves lateral capacity by a fixed-point iteration because normal load and lateral force depend on the lateral-acceleration estimate itself.</p> <p>Given current iterate \\(a_y^{(k)}\\):</p> <ol> <li>Estimate axle loads from quasi-static vertical balance and load transfer.</li> <li>Evaluate axle lateral forces at representative peak slip angle    \\(\\alpha_\\text{peak}\\).</li> <li>Update the lateral limit with banking contribution. The dependence on the    previous iterate is carried by the axle normal loads used in tire-force    evaluation:</li> </ol> \\[ a_y^{(k+1)} = \\max\\left( a_{y,\\min}, \\frac{2F_y\\!\\left(\\alpha_\\text{peak}, F_{z,f}\\!\\left(a_y^{(k)}\\right)/2\\right) + 2F_y\\!\\left(\\alpha_\\text{peak}, F_{z,r}\\!\\left(a_y^{(k)}\\right)/2\\right)}{m} + g\\sin\\beta \\right). \\] <p>Equivalently, writing axle-level lateral forces explicitly as \\(F_{y,f}^{(k)}\\) and \\(F_{y,r}^{(k)}\\):</p> \\[ a_y^{(k+1)} = \\max\\left(a_{y,\\min}, \\frac{F_{y,f}^{(k)} + F_{y,r}^{(k)}}{m} + g\\sin\\beta\\right), \\] <p>with \\(F_{y,f}^{(k)}, F_{y,r}^{(k)}\\) computed from \\(F_{z,f}(a_y^{(k)})\\) and \\(F_{z,r}(a_y^{(k)})\\).</p> <p>Stop criterion:</p> \\[ \\left|a_y^{(k+1)} - a_y^{(k)}\\right| \\le \\text{tol}_y \\] <p>or max iteration count.</p>"},{"location":"BICYCLE_MODEL/#3-lateral-tire-force-model-pacejka","title":"3. Lateral Tire Force Model (Pacejka)","text":"<p>Each axle force is the sum of two equivalent tires:</p> \\[ F_{y,f} = 2\\,F_y(\\alpha_f, F_{z,f}/2), \\quad F_{y,r} = 2\\,F_y(\\alpha_r, F_{z,r}/2). \\] <p>Per-tire Pacejka-style lateral force:</p> \\[ F_y = D\\,\\mu_\\text{scale}(F_z)\\,F_z\\,\\sin\\left(C\\,\\arctan\\left(\\xi\\right)\\right), \\] \\[ \\xi = B\\alpha - E\\left(B\\alpha - \\arctan(B\\alpha)\\right), \\] <p>with load sensitivity factor:</p> \\[ \\mu_\\text{scale}(F_z) = \\max\\left(1 + s\\,\\frac{F_z - F_{z,\\text{ref}}}{F_{z,\\text{ref}}},\\ \\mu_{\\min}\\right). \\]"},{"location":"BICYCLE_MODEL/#4-quasi-static-normal-loads","title":"4. Quasi-Static Normal Loads","text":"<p>Total vertical load:</p> \\[ F_{z,\\text{tot}} = mg + F_\\text{down}(v), \\quad F_\\text{down}(v)=\\tfrac{1}{2}\\rho C_L A v^2. \\] <p>Front axle raw load with longitudinal transfer:</p> \\[ F_{z,f}^\\text{raw} = mg\\,\\phi_f + F_{\\text{down},f} - \\frac{m a_x h}{L}. \\] <p>Rear axle load follows from equilibrium:</p> \\[ F_{z,r} = F_{z,\\text{tot}} - F_{z,f}. \\] <p>Lateral transfer is distributed by effective front roll-stiffness share and split to left/right wheel loads while preserving axle totals.</p>"},{"location":"BICYCLE_MODEL/#5-longitudinal-limits-with-friction-circle","title":"5. Longitudinal Limits with Friction Circle","text":"<p>For required lateral acceleration magnitude \\(|a_{y,\\text{req}}|\\):</p> \\[ \\lambda = \\sqrt{\\max\\left(0,\\ 1 - \\left(\\frac{|a_{y,\\text{req}}|}{a_{y,\\text{lim}}}\\right)^2\\right)}. \\] <p>Drive and brake envelopes:</p> \\[ a_{x,\\text{drive}} = a_{x,\\text{drive,max}}\\,\\lambda,\\quad a_{x,\\text{brake}} = a_{x,\\text{brake,max}}\\,\\lambda. \\] <p>Net along-track acceleration:</p> \\[ a_{x,\\text{net}} = a_{x,\\text{drive}} - \\frac{D(v)}{m} - g\\gamma, \\] <p>available deceleration magnitude:</p> \\[ a_{x,\\text{decel,avail}} = \\max\\left(a_{x,\\text{brake}} + \\frac{D(v)}{m} + g\\gamma,\\ 0\\right), \\] <p>with</p> \\[ D(v)=\\tfrac{1}{2}\\rho C_D A v^2. \\]"},{"location":"BICYCLE_MODEL/#6-diagnostics","title":"6. Diagnostics","text":"<p>The backend reports at each operating point:</p> <ul> <li>yaw moment from 3-DOF bicycle force balance,</li> <li>front and rear axle normal loads,</li> <li>tractive power:</li> </ul> \\[ P = \\left(m a_x + D(v)\\right)v. \\] <p>The solver uses quasi-steady envelopes for speed profile generation; the 3-DOF bicycle dynamics model is used primarily for physically meaningful analysis diagnostics (e.g., yaw-moment traces).</p>"},{"location":"BICYCLE_MODEL/#7-equation-to-code-mapping","title":"7. Equation-to-Code Mapping","text":"<ul> <li>lateral limit fixed-point:   <code>BicycleModel.lateral_accel_limit(...)</code></li> <li>Pacejka lateral force:   <code>magic_formula_lateral(...)</code></li> <li>normal-load estimation:   <code>estimate_normal_loads(...)</code></li> <li>friction-circle scaling:   <code>EnvelopeVehicleModel._friction_circle_scale(...)</code></li> <li>longitudinal accel/decel:   <code>BicycleModel.max_longitudinal_accel(...)</code>,   <code>BicycleModel.max_longitudinal_decel(...)</code></li> <li>diagnostics:   <code>BicycleModel.diagnostics(...)</code>, <code>BicycleDynamicsModel.force_balance(...)</code></li> </ul>"},{"location":"BICYCLE_MODEL/#8-example","title":"8. Example","text":"<ul> <li>Bicycle standalone usage:   <code>examples/spa_lap.py</code></li> <li>Side-by-side comparison against point-mass model:   <code>examples/spa_model_comparison.py</code></li> </ul>"},{"location":"DEVELOPMENT/","title":"Development","text":""},{"location":"DEVELOPMENT/#environment","title":"Environment","text":"<p>A local virtual environment is expected at <code>.venv</code>.</p> <pre><code>python3 -m venv --system-site-packages .venv\nsource .venv/bin/activate\npip install -e '.[dev]'\n</code></pre>"},{"location":"DEVELOPMENT/#test-commands","title":"Test Commands","text":"<p>Because this environment may run offline, tests can be executed via <code>unittest</code> directly:</p> <pre><code>source .venv/bin/activate\nPYTHONPATH=src python -m unittest discover -s tests -v\n</code></pre> <p>Coverage:</p> <pre><code>source .venv/bin/activate\nPYTHONPATH=src python -m coverage run -m unittest discover -s tests\npython -m coverage report -m\n</code></pre> <p>Coverage policy:</p> <ul> <li>Keep overall coverage at or above <code>95%</code>.</li> </ul> <p>If <code>pytest</code> is available:</p> <pre><code>source .venv/bin/activate\nPYTHONPATH=src pytest\n</code></pre>"},{"location":"DEVELOPMENT/#docstring-policy","title":"Docstring Policy","text":"<p>This repository enforces Google-style docstrings through <code>ruff</code> (<code>D</code> rules with <code>pydocstyle</code> convention <code>google</code>) and an AST contract test.</p> <p>Rules:</p> <ul> <li>Public classes, functions, and interfaces must include full Google docstrings.</li> <li>Private/technical helpers must always include a summary line.</li> <li>If a callable has parameters other than <code>self</code>/<code>cls</code>, include an <code>Args:</code> section.</li> <li>If a callable returns a non-<code>None</code> value, include a <code>Returns:</code> section.</li> <li>If a callable intentionally raises domain/validation errors, include <code>Raises:</code>.</li> <li>Keep units explicit for physics-facing values (<code>m/s</code>, <code>m/s^2</code>, <code>1/m</code>, <code>rad</code>, <code>W</code>).</li> </ul> <p>Example:</p> <pre><code>def lateral_speed_limit(curvature: float, lateral_accel_limit: float, max_speed: float) -&gt; float:\n    \"\"\"Compute speed limit from curvature and lateral acceleration capability.\n\n    Args:\n        curvature: Signed path curvature [1/m].\n        lateral_accel_limit: Available lateral acceleration magnitude [m/s^2].\n        max_speed: Global hard speed cap [m/s].\n\n    Returns:\n        Maximum feasible speed [m/s] under curvature and lateral limits.\n    \"\"\"\n</code></pre>"},{"location":"DEVELOPMENT/#parameter-layering","title":"Parameter Layering","text":"<p>Keep parameter domains separate:</p> <ul> <li>Physical model inputs:</li> <li><code>VehicleParameters</code></li> <li><code>PacejkaParameters</code> / <code>AxleTireParameters</code></li> <li><code>BicyclePhysics</code></li> <li>Numerical/discretization controls:</li> <li><code>NumericsConfig</code></li> <li><code>BicycleNumerics</code></li> <li>Simulation runtime controls (non-physical scenario bounds):</li> <li><code>RuntimeConfig</code></li> </ul> <p>Avoid mixing fixed-point tolerances, iteration limits, and numerical floors into physical parameter dataclasses.</p> <p>Defaulting guidance:</p> <ul> <li>Numerical controls may include stable defaults to keep quick-start simulations   robust (<code>NumericsConfig</code>, <code>BicycleNumerics</code>).</li> <li>Physical parameter classes should stay explicit and scenario-specific.</li> </ul>"},{"location":"DEVELOPMENT/#vehicle-model-architecture","title":"Vehicle Model Architecture","text":"<p>The solver contract is represented at two levels:</p> <ul> <li><code>VehicleModel</code> (Protocol) in <code>src/pylapsim/simulation/model_api.py</code>   keeps the simulation pipeline structurally open for external backends.</li> <li><code>VehicleModelBase</code> plus   <code>EnvelopeVehicleModel</code> in <code>src/pylapsim/vehicle/_model_base.py</code>   provides inheritance-based code organization for built-in backends.</li> </ul> <p>Built-in models (<code>BicycleModel</code>, <code>PointMassModel</code>) inherit the same base class to share validation layering, friction-circle scaling, and net drag/grade-corrected longitudinal limits.</p>"},{"location":"DEVELOPMENT/#refreshing-spa-data","title":"Refreshing Spa Data","text":"<pre><code>source .venv/bin/activate\npython scripts/import_spa_from_tumftm.py\n</code></pre>"},{"location":"EXAMPLES/","title":"Examples","text":"<p>This section is the tutorial path through the example scripts. It is designed for race engineers and Students who want practical onboarding.</p>"},{"location":"EXAMPLES/#what-you-will-learn-from-the-examples","title":"What you will learn from the examples","text":"<p>After finishing all example pages, you should be able to:</p> <ul> <li>set up a complete lap-time run from scratch,</li> <li>choose between point-mass and bicycle model for a study goal,</li> <li>interpret key plots and KPI outputs correctly,</li> <li>understand where model assumptions limit interpretation.</li> </ul>"},{"location":"EXAMPLES/#recommended-tutorial-sequence","title":"Recommended tutorial sequence","text":"<ol> <li>Synthetic Track Walkthrough</li> <li>Spa Walkthrough</li> </ol> <p>Reason:</p> <ul> <li>Synthetic tracks isolate single effects and simplify debugging.</li> <li>Spa introduces full-track interactions and realistic complexity.</li> </ul>"},{"location":"EXAMPLES/#mapping-scripts-to-engineering-questions","title":"Mapping scripts to engineering questions","text":"<ul> <li><code>examples/synthetic_track_scenarios.py</code></li> <li>\"Is my model setup physically consistent on canonical test geometries?\"</li> <li><code>examples/spa_lap.py</code></li> <li>\"What does the bicycle model predict on a realistic circuit?\"</li> <li><code>examples/spa_lap_point_mass.py</code></li> <li>\"What is the low-complexity baseline on the same circuit?\"</li> <li><code>examples/spa_model_comparison.py</code></li> <li>\"What do I gain from additional model fidelity?\"</li> </ul>"},{"location":"EXAMPLES/#what-the-example-suite-covers-well","title":"What the example suite covers well","text":"<ul> <li>End-to-end solver use on real and synthetic tracks.</li> <li>KPI and plot export workflows.</li> <li>Direct model-complexity comparison.</li> <li>Practical interpretation of speed/acceleration/yaw diagnostics.</li> </ul>"},{"location":"EXAMPLES/#what-the-example-suite-does-not-claim","title":"What the example suite does not claim","text":"<ul> <li>It is not a final validation against fully instrumented race telemetry.</li> <li>It does not include a full transient driver + powertrain control stack.</li> <li>It does not replace model-calibration work on real vehicle data.</li> </ul>"},{"location":"EXAMPLES/#output-structure","title":"Output structure","text":"<p>All scripts export into <code>examples/output/</code> with consistent folder logic. Typical artifacts:</p> <ul> <li><code>kpis.json</code></li> <li>speed traces</li> <li>G-G diagram</li> <li>yaw moment vs. lateral acceleration</li> <li>tire-load and power traces</li> </ul> <p>Because output format is standardized, comparisons across scripts are straightforward.</p>"},{"location":"EXAMPLES/#before-applying-results-to-decisions","title":"Before applying results to decisions","text":"<p>Use this quick quality gate:</p> <ol> <li>Check whether the selected model can represent your target effect.</li> <li>Confirm basic sanity checks on synthetic tracks.</li> <li>Check if KPI magnitudes are plausible for your vehicle class.</li> <li>Document assumptions used in the run.</li> </ol>"},{"location":"EXAMPLES_SPA/","title":"Spa Walkthrough","text":"<p>This tutorial explains the Spa example scripts in execution order and in practical engineering language.</p> <p>Use this after the synthetic-track tutorial.</p>"},{"location":"EXAMPLES_SPA/#what-this-tutorial-helps-you-do","title":"What this tutorial helps you do","text":"<ul> <li>Run realistic full-lap simulations on Spa.</li> <li>Understand the difference between bicycle and point-mass outputs.</li> <li>Build a reproducible model-comparison workflow.</li> <li>Interpret outputs within the limits of a quasi-steady solver.</li> </ul>"},{"location":"EXAMPLES_SPA/#1-shared-workflow-across-all-spa-scripts","title":"1. Shared workflow across all Spa scripts","text":"<p>Each script follows the same structure:</p> <ol> <li>Load Spa track CSV.</li> <li>Create vehicle/model inputs.</li> <li>Configure runtime/numerics.</li> <li>Run <code>simulate_lap(...)</code>.</li> <li>Export plots and KPI JSON.</li> </ol> <p>Only the vehicle-model backend differs.</p>"},{"location":"EXAMPLES_SPA/#2-examplesspa_lappy-bicycle-baseline","title":"2. <code>examples/spa_lap.py</code> (bicycle baseline)","text":""},{"location":"EXAMPLES_SPA/#21-why-start-here","title":"2.1 Why start here?","text":"<p>This is the highest-fidelity backend currently available in the library\u2019s standard pipeline.</p>"},{"location":"EXAMPLES_SPA/#22-code-flow","title":"2.2 Code flow","text":"<ul> <li>Load track:</li> </ul> <pre><code>track = load_track_csv(project_root / \"data\" / \"spa_francorchamps.csv\")\n</code></pre> <ul> <li>Build inputs:</li> </ul> <pre><code>vehicle = _example_vehicle_parameters()\ntires = default_axle_tire_parameters()\nmodel = build_bicycle_model(vehicle=vehicle, tires=tires, physics=BicyclePhysics())\n</code></pre> <ul> <li>Configure and run:</li> </ul> <pre><code>config = build_simulation_config()\nresult = simulate_lap(track=track, model=model, config=config)\n</code></pre> <ul> <li>Export:</li> </ul> <pre><code>kpis = compute_kpis(result)\nexport_standard_plots(result, output_dir)\nexport_kpi_json(kpis, output_dir / \"kpis.json\")\n</code></pre>"},{"location":"EXAMPLES_SPA/#23-what-this-script-captures-well","title":"2.3 What this script captures well","text":"<ul> <li>lateral-force-limited behavior with load sensitivity,</li> <li>drag/downforce interaction,</li> <li>axle-load diagnostics,</li> <li>yaw-moment diagnostics.</li> </ul>"},{"location":"EXAMPLES_SPA/#24-what-it-still-does-not-capture-fully","title":"2.4 What it still does not capture fully","text":"<ul> <li>full transient driver/steering control effects,</li> <li>advanced powertrain/energy strategy effects,</li> <li>full multi-body suspension compliance.</li> </ul>"},{"location":"EXAMPLES_SPA/#3-examplesspa_lap_point_masspy-fast-baseline","title":"3. <code>examples/spa_lap_point_mass.py</code> (fast baseline)","text":""},{"location":"EXAMPLES_SPA/#31-purpose","title":"3.1 Purpose","text":"<p>Use this for rapid studies, initial sweeps, and baseline checks.</p>"},{"location":"EXAMPLES_SPA/#32-core-code-difference","title":"3.2 Core code difference","text":"<p>Only model backend changes:</p> <pre><code>model = build_point_mass_model(\n    vehicle=vehicle,\n    physics=PointMassPhysics(\n        max_drive_accel=8.0,\n        max_brake_accel=16.0,\n        friction_coefficient=1.7,\n    ),\n)\n</code></pre>"},{"location":"EXAMPLES_SPA/#33-interpretation","title":"3.3 Interpretation","text":"<ul> <li>faster and simpler than bicycle,</li> <li>no yaw-state dynamics,</li> <li>yaw moment reported as zero by construction.</li> </ul>"},{"location":"EXAMPLES_SPA/#4-examplesspa_model_comparisonpy-tradeoff-study","title":"4. <code>examples/spa_model_comparison.py</code> (tradeoff study)","text":""},{"location":"EXAMPLES_SPA/#41-why-this-script-matters","title":"4.1 Why this script matters","text":"<p>It demonstrates how to quantify value added by model complexity, not just compare lap times.</p>"},{"location":"EXAMPLES_SPA/#42-sequence","title":"4.2 Sequence","text":"<ol> <li>Run bicycle model.</li> <li>Calibrate point-mass friction to bicycle lateral envelope.</li> <li>Run calibrated point-mass model.</li> <li>Export KPI deltas and speed overlay.</li> </ol>"},{"location":"EXAMPLES_SPA/#43-key-outputs-to-inspect","title":"4.3 Key outputs to inspect","text":"<ul> <li><code>comparison_kpis.json</code></li> <li><code>speed_trace_comparison.png</code></li> <li>per-model KPI JSON and plots under comparison folders.</li> </ul>"},{"location":"EXAMPLES_SPA/#5-parameter-tuning-order-for-a-new-vehicle","title":"5. Parameter tuning order for a new vehicle","text":"<p>Recommended order:</p> <ol> <li>Vehicle mass and aero parameters.</li> <li>Tire parameters.</li> <li>Model physics limits (<code>BicyclePhysics</code> / <code>PointMassPhysics</code>).</li> <li>Numerical solver settings (only if required for convergence robustness).</li> </ol> <p>This minimizes risk of hiding physical mis-modeling behind numerical tuning.</p>"},{"location":"EXAMPLES_SPA/#6-how-to-read-spa-results-correctly","title":"6. How to read Spa results correctly","text":"<ol> <li>Lap time alone is not enough; inspect speed trace shape and acceleration envelopes.</li> <li>Compare where models differ along track distance, not only global KPIs.</li> <li>Treat yaw-moment plots only as meaningful for models that represent yaw dynamics.</li> <li>Validate magnitude ranges against known class-level expectations.</li> </ol>"},{"location":"EXAMPLES_SPA/#7-practical-limitations-to-keep-in-mind","title":"7. Practical limitations to keep in mind","text":"<p>Even with bicycle model, this remains a quasi-steady solver workflow. Use caution when drawing conclusions about:</p> <ul> <li>highly transient driver actions,</li> <li>fine control-system behavior,</li> <li>sub-second event details.</li> </ul>"},{"location":"EXAMPLES_SPA/#8-suggested-study-workflow","title":"8. Suggested study workflow","text":"<ol> <li>Start from <code>spa_lap.py</code>.</li> <li>Run <code>spa_lap_point_mass.py</code>.</li> <li>Run <code>spa_model_comparison.py</code>.</li> <li>Calibrate/adjust parameters and rerun all three for consistency.</li> </ol>"},{"location":"EXAMPLES_SPA/#run-commands","title":"Run commands","text":"<pre><code>python examples/spa_lap.py\npython examples/spa_lap_point_mass.py\npython examples/spa_model_comparison.py\n</code></pre>"},{"location":"EXAMPLES_SYNTHETIC/","title":"Synthetic Track Walkthrough","text":"<p>This tutorial walks through <code>examples/synthetic_track_scenarios.py</code> in code order.</p> <p>Goal: build intuition for solver behavior on controlled geometries before moving to real circuits.</p>"},{"location":"EXAMPLES_SYNTHETIC/#why-this-tutorial-is-important","title":"Why this tutorial is important","text":"<p>Synthetic tracks are your first physical consistency filter. If behavior is implausible here, Spa results are likely hard to trust.</p>"},{"location":"EXAMPLES_SYNTHETIC/#1-imports-map-code-to-engineering-blocks","title":"1. Imports: map code to engineering blocks","text":"<p>The script imports:</p> <ul> <li><code>analysis</code>: KPI and figure export,</li> <li><code>simulation</code>: lap solver,</li> <li><code>track</code>: synthetic layout generators,</li> <li><code>vehicle</code>: point-mass model and its physics settings,</li> <li><code>utils</code>: logging and constants.</li> </ul> <p>If you are new to Python: imports are simply selecting the tools you need.</p>"},{"location":"EXAMPLES_SYNTHETIC/#2-define-vehicle-and-model","title":"2. Define vehicle and model","text":""},{"location":"EXAMPLES_SYNTHETIC/#21-vehicle-parameter-block","title":"2.1 Vehicle parameter block","text":"<p><code>_example_vehicle_parameters()</code> provides a complete car definition.</p> <p>Most influential fields for this tutorial:</p> <ul> <li><code>mass</code>, <code>lift_coefficient</code>, <code>drag_coefficient</code>, <code>frontal_area</code></li> <li>govern acceleration/drag balance and high-speed behavior,</li> <li><code>front_weight_fraction</code></li> <li>influences axle-load diagnostics,</li> <li>remaining vehicle parameters</li> <li>keep cross-model compatibility.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#22-model-choice-point-mass","title":"2.2 Model choice: point-mass","text":"<pre><code>model = build_point_mass_model(vehicle=vehicle, physics=PointMassPhysics())\n</code></pre> <p>Interpretation:</p> <ul> <li>very fast and stable for benchmark scenarios,</li> <li>no explicit yaw state,</li> <li>yaw moment output is structurally zero by design.</li> </ul> <p>If your study requires yaw-moment dynamics, switch to bicycle model.</p>"},{"location":"EXAMPLES_SYNTHETIC/#23-solver-setup","title":"2.3 Solver setup","text":"<pre><code>config = build_simulation_config(max_speed=115.0)\n</code></pre> <p><code>max_speed</code> is a runtime cap, not a guarantee that the car can sustain this speed. Actual speed comes from force balance and constraints.</p>"},{"location":"EXAMPLES_SYNTHETIC/#3-build-three-benchmark-tracks","title":"3. Build three benchmark tracks","text":"<pre><code>tracks = {\n    \"straight_1km\": build_straight_track(length=STRAIGHT_LENGTH),\n    \"circle_r50\": build_circular_track(radius=CIRCLE_RADIUS),\n    \"figure_eight\": build_figure_eight_track(lobe_radius=FIGURE_EIGHT_RADIUS),\n}\n</code></pre>"},{"location":"EXAMPLES_SYNTHETIC/#31-straight-1-km","title":"3.1 Straight (1 km)","text":"<p>Tests pure longitudinal behavior with no curvature demand.</p>"},{"location":"EXAMPLES_SYNTHETIC/#32-circle-50-m-radius","title":"3.2 Circle (50 m radius)","text":"<p>Tests quasi-steady cornering with near-constant curvature.</p>"},{"location":"EXAMPLES_SYNTHETIC/#33-figure-eight","title":"3.3 Figure-eight","text":"<p>Tests left/right transition dynamics and sign changes in lateral acceleration.</p>"},{"location":"EXAMPLES_SYNTHETIC/#4-run-simulation-loop","title":"4. Run simulation loop","text":"<p>Per scenario:</p> <pre><code>result = simulate_lap(track=track, model=model, config=config)\nkpis = compute_kpis(result)\nexport_standard_plots(result, scenario_dir)\nexport_kpi_json(kpis, scenario_dir / \"kpis.json\")\n</code></pre> <p>This is the canonical PyLapSim pattern and can be reused for custom studies.</p>"},{"location":"EXAMPLES_SYNTHETIC/#5-cross-scenario-comparison-output","title":"5. Cross-scenario comparison output","text":"<p>After scenario runs, script generates:</p> <ul> <li><code>speed_trace_comparison.png</code></li> <li><code>scenario_summary.json</code></li> </ul> <p>These files support quick A/B/C interpretation across geometries.</p>"},{"location":"EXAMPLES_SYNTHETIC/#6-how-to-interpret-each-scenario","title":"6. How to interpret each scenario","text":""},{"location":"EXAMPLES_SYNTHETIC/#straight-straight_1km","title":"Straight (<code>straight_1km</code>)","text":"<p>Expected:</p> <ul> <li>lateral acceleration near zero,</li> <li>curvature near zero,</li> <li>speed governed by net longitudinal balance.</li> </ul> <p>Important nuance:</p> <ul> <li>speed can decrease if drag at current speed exceeds available drive acceleration.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#circle-circle_r50","title":"Circle (<code>circle_r50</code>)","text":"<p>Expected:</p> <ul> <li>interior speed close to steady value,</li> <li>interior longitudinal acceleration near zero,</li> <li>positive lateral acceleration around loop.</li> </ul> <p>Practical tip:</p> <ul> <li>ignore seam-adjacent points for steady-state assessment.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#figure-eight-figure_eight","title":"Figure-eight (<code>figure_eight</code>)","text":"<p>Expected:</p> <ul> <li>lateral acceleration changes sign,</li> <li>acceleration and braking phases near transitions,</li> <li>stronger speed variation than constant-radius cornering.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#7-what-this-tutorial-validates-well","title":"7. What this tutorial validates well","text":"<ul> <li>solver stability,</li> <li>unit consistency and sign conventions,</li> <li>gross physical plausibility,</li> <li>basic model-behavior sanity.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#8-what-this-tutorial-does-not-validate-alone","title":"8. What this tutorial does not validate alone","text":"<ul> <li>absolute lap-time fidelity on a real circuit,</li> <li>transient steering/yaw control quality,</li> <li>powertrain energy strategy realism.</li> </ul>"},{"location":"EXAMPLES_SYNTHETIC/#9-common-mistakes-and-fixes","title":"9. Common mistakes and fixes","text":"<ol> <li>Expecting nonzero yaw moment with point-mass model.</li> <li>Use bicycle model if yaw diagnostics are required.</li> <li>Treating seam points as steady-state evidence.</li> <li>trim boundary points before concluding.</li> <li>Assuming <code>max_speed</code> is always reached.</li> <li>check drag and available drive force first.</li> </ol>"},{"location":"EXAMPLES_SYNTHETIC/#10-suggested-next-step","title":"10. Suggested next step","text":"<p>After this tutorial, continue with Spa Walkthrough.</p>"},{"location":"EXAMPLES_SYNTHETIC/#run-command","title":"Run command","text":"<pre><code>python examples/synthetic_track_scenarios.py\n</code></pre>"},{"location":"HOW_TO_USE/","title":"How to Use PyLapSim","text":"<p>This guide is a practical, engineer-oriented walkthrough of the complete workflow. It is written for race engineers and Students who may have strong dynamics knowledge but limited software background.</p>"},{"location":"HOW_TO_USE/#what-pylapsim-is-designed-to-do","title":"What PyLapSim is designed to do","text":"<p>PyLapSim is optimized for fast, physically grounded lap-time studies with modular vehicle models.</p> <p>Main strengths:</p> <ul> <li>Quasi-steady lap-time simulation on arbitrary track centerlines.</li> <li>Interchangeable vehicle models behind one solver API.</li> <li>Clear separation between physical inputs and numerical solver settings.</li> <li>Reproducible engineering outputs (KPIs + standardized plots).</li> <li>Fast iteration loops for setup changes and what-if studies.</li> </ul>"},{"location":"HOW_TO_USE/#what-pylapsim-does-not-do-yet","title":"What PyLapSim does not do (yet)","text":"<p>Current model boundaries are important for correct interpretation:</p> <ul> <li>No full transient lap solver in production path yet.</li> <li>No driver model or closed-loop control strategy model.</li> <li>No detailed powertrain/energy management model yet.</li> <li>No full multi-body chassis compliance model.</li> <li>No direct tire thermal/wear state evolution.</li> </ul> <p>Interpretation rule:</p> <ul> <li>Use PyLapSim for comparative setup studies and first-order lap-time sensitivity,   not as final truth for every transient detail.</li> </ul>"},{"location":"HOW_TO_USE/#the-6-step-workflow-always-the-same","title":"The 6-step workflow (always the same)","text":"<ol> <li>Import modules.</li> <li>Define physical model inputs.</li> <li>Load or generate a track.</li> <li>Configure numerics and runtime bounds.</li> <li>Run the simulation.</li> <li>Postprocess and review outputs.</li> </ol> <p>This pattern is identical across all examples.</p>"},{"location":"HOW_TO_USE/#step-1-imports","title":"Step 1: Imports","text":"<pre><code>from pathlib import Path\n\nfrom pylapsim.analysis import compute_kpis, export_standard_plots\nfrom pylapsim.analysis.export import export_kpi_json\nfrom pylapsim.simulation import build_simulation_config, simulate_lap\nfrom pylapsim.tire import default_axle_tire_parameters\nfrom pylapsim.track import load_track_csv\nfrom pylapsim.utils.constants import STANDARD_AIR_DENSITY\nfrom pylapsim.vehicle import BicyclePhysics, VehicleParameters, build_bicycle_model\n</code></pre> <p>How to read these imports as an engineer:</p> <ul> <li><code>track</code>: geometry and road profile.</li> <li><code>vehicle</code> + <code>tire</code>: physical car model.</li> <li><code>simulation</code>: numerical solver and runtime bounds.</li> <li><code>analysis</code>: KPI and visualization outputs.</li> </ul>"},{"location":"HOW_TO_USE/#step-2-define-physical-model-inputs","title":"Step 2: Define physical model inputs","text":""},{"location":"HOW_TO_USE/#21-vehicle-parameters-real-system-inputs","title":"2.1 Vehicle parameters (real-system inputs)","text":"<pre><code>vehicle = VehicleParameters(\n    mass=798.0,\n    yaw_inertia=1120.0,\n    cg_height=0.31,\n    wheelbase=3.60,\n    front_track=1.60,\n    rear_track=1.55,\n    front_weight_fraction=0.46,\n    cop_position=0.10,\n    lift_coefficient=3.20,\n    drag_coefficient=0.90,\n    frontal_area=1.50,\n    roll_rate=4200.0,\n    front_spring_rate=180000.0,\n    rear_spring_rate=165000.0,\n    front_arb_distribution=0.55,\n    front_ride_height=0.030,\n    rear_ride_height=0.050,\n    air_density=STANDARD_AIR_DENSITY,\n)\n</code></pre> <p>This block should reflect the best available engineering estimate of the real car.</p>"},{"location":"HOW_TO_USE/#22-tire-data","title":"2.2 Tire data","text":"<pre><code>tires = default_axle_tire_parameters()\n</code></pre> <p>Recommendation:</p> <ul> <li>Start with defaults for initial integration.</li> <li>Replace with identified tire parameters for decision-quality studies.</li> </ul>"},{"location":"HOW_TO_USE/#23-choose-model-complexity","title":"2.3 Choose model complexity","text":"<p>Bicycle model:</p> <pre><code>model = build_bicycle_model(\n    vehicle=vehicle,\n    tires=tires,\n    physics=BicyclePhysics(),\n)\n</code></pre> <p>Point-mass model:</p> <pre><code>from pylapsim.vehicle import PointMassPhysics, build_point_mass_model\n\nmodel = build_point_mass_model(\n    vehicle=vehicle,\n    physics=PointMassPhysics(),\n)\n</code></pre> <p>When to use which:</p> <ul> <li>Bicycle: better diagnostics (yaw moment, axle-load dynamics), better cornering interpretation.</li> <li>Point-mass: fast baseline and sensitivity sweeps.</li> </ul>"},{"location":"HOW_TO_USE/#step-3-load-or-generate-track","title":"Step 3: Load or generate track","text":""},{"location":"HOW_TO_USE/#option-a-real-track-from-csv","title":"Option A: Real track from CSV","text":"<pre><code>project_root = Path(__file__).resolve().parents[1]\ntrack = load_track_csv(project_root / \"data\" / \"spa_francorchamps.csv\")\n</code></pre> <p>Required columns:</p> <ul> <li><code>x</code></li> <li><code>y</code></li> <li><code>elevation</code></li> <li><code>banking</code></li> </ul> <p>Internally, PyLapSim derives arc length, heading, curvature, and grade.</p>"},{"location":"HOW_TO_USE/#option-b-synthetic-validation-tracks","title":"Option B: Synthetic validation tracks","text":"<pre><code>from pylapsim.track import build_straight_track, build_circular_track, build_figure_eight_track\n\nstraight = build_straight_track(length=1000.0)\ncircle = build_circular_track(radius=50.0)\nfigure_eight = build_figure_eight_track(lobe_radius=80.0)\n</code></pre> <p>Why synthetic tracks matter:</p> <ul> <li>You can verify single effects in isolation.</li> <li>Debugging is easier than on a full GP circuit.</li> </ul>"},{"location":"HOW_TO_USE/#step-4-configure-runtime-and-numerics","title":"Step 4: Configure runtime and numerics","text":"<p>Simple setup:</p> <pre><code>config = build_simulation_config(max_speed=115.0)\n</code></pre> <p>Explicit setup:</p> <pre><code>from pylapsim.simulation import NumericsConfig, RuntimeConfig, SimulationConfig\n\nconfig = SimulationConfig(\n    runtime=RuntimeConfig(max_speed=115.0),\n    numerics=NumericsConfig(\n        min_speed=8.0,\n        lateral_envelope_max_iterations=20,\n        lateral_envelope_convergence_tolerance=0.1,\n        transient_step=0.01,\n    ),\n)\n</code></pre> <p>Critical distinction:</p> <ul> <li>Physical parameters represent the car/track reality.</li> <li>Numerical parameters control solver stability and convergence.</li> </ul> <p>Do not compensate wrong physics by over-tuning numerics.</p>"},{"location":"HOW_TO_USE/#step-5-run-the-lap-simulation","title":"Step 5: Run the lap simulation","text":"<pre><code>result = simulate_lap(track=track, model=model, config=config)\n</code></pre> <p><code>result</code> includes:</p> <ul> <li>lap time</li> <li>speed trace</li> <li>longitudinal/lateral accelerations</li> <li>yaw moment</li> <li>axle loads</li> <li>power trace</li> <li>integrated energy</li> </ul>"},{"location":"HOW_TO_USE/#step-6-postprocess-and-export","title":"Step 6: Postprocess and export","text":"<pre><code>kpis = compute_kpis(result)\n\noutput_dir = project_root / \"examples\" / \"output\"\nexport_standard_plots(result, output_dir)\nexport_kpi_json(kpis, output_dir / \"kpis.json\")\n</code></pre> <p>Minimum review set:</p> <ul> <li>lap time</li> <li>max lateral acceleration</li> <li>max longitudinal acceleration/deceleration</li> <li>speed trace shape vs track layout</li> </ul>"},{"location":"HOW_TO_USE/#engineering-interpretation-checklist","title":"Engineering interpretation checklist","text":"<p>Before using results for decisions:</p> <ol> <li>Straight track check: near-zero lateral acceleration.</li> <li>Constant-radius check: quasi-steady cornering in interior segments.</li> <li>Figure-eight check: lateral acceleration sign change and entry/exit transitions.</li> <li>Magnitude check: compare against realistic bounds for your car class.</li> <li>Model check: verify whether selected model complexity can represent the effect you study.</li> </ol>"},{"location":"HOW_TO_USE/#typical-pitfalls-and-fixes","title":"Typical pitfalls (and fixes)","text":"<ol> <li>\"The solver should always accelerate to max speed.\"</li> <li>Not necessarily. At high speed, drag can exceed available drive force.</li> <li>\"Yaw moment should always be visible.\"</li> <li>Not with point-mass model (yaw moment is structurally zero).</li> <li>\"Changing numerics changed physics dramatically.\"</li> <li>Re-check physical parameters first; numerics should refine stability, not redefine behavior.</li> <li>\"My results jump near lap closure.\"</li> <li>For closed loops, inspect interior segments and avoid over-interpreting seam points.</li> </ol>"},{"location":"HOW_TO_USE/#recommended-onboarding-path","title":"Recommended onboarding path","text":"<ol> <li>Read Synthetic Track Walkthrough.</li> <li>Run Spa Walkthrough.</li> <li>Compare model complexity with <code>examples/spa_model_comparison.py</code>.</li> <li>Move from default tire/model settings to identified vehicle data.</li> </ol>"},{"location":"POINT_MASS_MODEL/","title":"Point-Mass Model","text":"<p>This document defines the implemented point-mass backend in <code>src/pylapsim/vehicle/point_mass_model.py</code>.</p>"},{"location":"POINT_MASS_MODEL/#1-scope","title":"1. Scope","text":"<p>The point-mass model keeps the solver API contract but replaces detailed chassis/yaw dynamics with a scalar acceleration envelope.</p> <p>State assumptions at each track point:</p> <ul> <li>no resolved yaw dynamics in diagnostics (\\(M_z = 0\\)),</li> <li>isotropic tire friction-circle coupling,</li> <li>normal load from gravity plus aerodynamic downforce.</li> </ul>"},{"location":"POINT_MASS_MODEL/#2-tire-normal-acceleration-budget","title":"2. Tire Normal-Acceleration Budget","text":"<p>At speed \\(v\\):</p> \\[ a_n(v) = g + \\frac{F_\\text{down}(v)}{m}, \\] <p>with</p> \\[ F_\\text{down}(v) = \\frac{1}{2}\\rho C_L A v^2. \\] <p>The model applies a lower bound \\(a_n(v)\\ge\\varepsilon\\) for numerical robustness.</p>"},{"location":"POINT_MASS_MODEL/#3-lateral-limit","title":"3. Lateral Limit","text":"<p>With isotropic friction coefficient \\(\\mu\\):</p> \\[ a_{y,\\text{tire}}(v) = \\mu a_n(v). \\] <p>Including banking contribution:</p> \\[ a_{y,\\text{lim}}(v,\\beta) = \\max\\left(a_{y,\\text{tire}}(v) + g\\sin\\beta,\\ \\varepsilon\\right). \\]"},{"location":"POINT_MASS_MODEL/#4-friction-circle-coupling","title":"4. Friction-Circle Coupling","text":"<p>For required lateral acceleration magnitude \\(|a_{y,\\text{req}}|\\):</p> \\[ \\lambda = \\sqrt{\\max\\left(0,\\ 1 - \\left(\\frac{|a_{y,\\text{req}}|}{a_{y,\\text{lim}}}\\right)^2\\right)}. \\]"},{"location":"POINT_MASS_MODEL/#5-longitudinal-limits","title":"5. Longitudinal Limits","text":"<p>Tire-limited longitudinal acceleration magnitude:</p> \\[ a_{x,\\text{tire,lim}}(v) = \\mu a_n(v). \\] <p>Drive envelope:</p> \\[ a_{x,\\text{drive}}(v) = \\min\\left(a_{x,\\text{drive,max}},\\ a_{x,\\text{tire,lim}}(v)\\right)\\lambda. \\] <p>Brake envelope:</p> \\[ a_{x,\\text{brake}}(v) = \\min\\left(a_{x,\\text{brake,max}},\\ a_{x,\\text{tire,lim}}(v)\\right)\\lambda. \\] <p>Net along-track acceleration:</p> \\[ a_{x,\\text{net}} = a_{x,\\text{drive}} - \\frac{D(v)}{m} - g\\,\\gamma, \\] <p>available deceleration magnitude:</p> \\[ a_{x,\\text{decel,avail}} = \\max\\left(a_{x,\\text{brake}} + \\frac{D(v)}{m} + g\\,\\gamma,\\ 0\\right), \\] <p>with</p> \\[ D(v)=\\frac{1}{2}\\rho C_D A v^2. \\]"},{"location":"POINT_MASS_MODEL/#6-diagnostics","title":"6. Diagnostics","text":"<p>The backend reports:</p> <ul> <li>yaw moment: \\(0\\),</li> <li>axle loads from static split plus aero split:</li> <li>\\(F_{z,f} = mg\\phi_f + F_{\\text{down},f}\\),</li> <li>\\(F_{z,r} = mg(1-\\phi_f) + F_{\\text{down},r}\\),</li> <li>tractive power:   $$   P = \\left(m a_x + D(v)\\right)v.   $$</li> </ul>"},{"location":"POINT_MASS_MODEL/#7-equation-to-code-mapping","title":"7. Equation-to-Code Mapping","text":"<ul> <li>normal-acceleration budget:   <code>PointMassModel._normal_accel_limit(...)</code></li> <li>lateral limit:   <code>PointMassModel.lateral_accel_limit(...)</code></li> <li>friction-circle scaling:   <code>PointMassModel._friction_circle_scale(...)</code></li> <li>longitudinal accel/decel limits:   <code>PointMassModel.max_longitudinal_accel(...)</code>,   <code>PointMassModel.max_longitudinal_decel(...)</code></li> <li>diagnostics:   <code>PointMassModel.diagnostics(...)</code></li> </ul>"},{"location":"POINT_MASS_MODEL/#8-cross-model-calibration","title":"8. Cross-Model Calibration","text":"<p>To align the point-mass model with the bicycle model's lateral envelope, the library provides:</p> <ul> <li><code>calibrate_point_mass_friction_to_bicycle(vehicle, tires, ...)</code></li> </ul> <p>This identifies an effective isotropic \\(\\mu\\) by least-squares fitting:</p> \\[ \\mu^\\star = \\arg\\min_\\mu \\sum_i \\left(\\mu a_n(v_i) - a_{y,\\text{lim,bicycle}}(v_i)\\right)^2. \\] <p>The comparison example uses this calibration before running the point-mass model.</p>"},{"location":"POINT_MASS_MODEL/#9-example","title":"9. Example","text":"<ul> <li>Point-mass standalone usage:   <code>examples/spa_lap_point_mass.py</code></li> <li>Side-by-side comparison against bicycle model:   <code>examples/spa_model_comparison.py</code></li> </ul>"},{"location":"SOLVER/","title":"Solver Mathematics","text":"<p>This document explains how lap time is computed in the current quasi-steady solver implementation (<code>src/pylapsim/simulation/profile.py</code>).</p>"},{"location":"SOLVER/#1-discretization-and-state","title":"1. Discretization and State","text":"<p>The track is represented in arc-length domain by points \\(i = 0,\\dots,N-1\\) with:</p> <ul> <li>position \\((s_i)\\) [m]</li> <li>curvature \\(\\kappa_i\\) [1/m]</li> <li>grade \\(\\gamma_i = dz/ds\\) [-]</li> <li>banking angle \\(\\beta_i\\) [rad]</li> </ul> <p>Segment length: $$ \\Delta s_i = s_{i+1} - s_i, \\quad i=0,\\dots,N-2. $$</p> <p>The solver computes a speed profile \\(v_i\\) [m/s], then derives:</p> <ul> <li>longitudinal acceleration \\(a_{x,i}\\) [m/s\u00b2]</li> <li>lateral acceleration \\(a_{y,i}\\) [m/s\u00b2]</li> <li>lap time \\(T\\) [s]</li> </ul>"},{"location":"SOLVER/#2-lateral-envelope-cornering-limit","title":"2. Lateral Envelope (Cornering Limit)","text":"<p>A lateral speed limit \\(v_{\\text{lat},i}\\) is computed at each point. Core relation: $$ |a_{y,i}| = v_i^2 |\\kappa_i|. $$</p> <p>Given lateral acceleration capacity \\(a_{y,\\text{lim},i}\\): $$ v_{\\text{lat},i} = \\begin{cases} \\sqrt{a_{y,\\text{lim},i}/|\\kappa_i|}, &amp; |\\kappa_i| &gt; \\varepsilon \\ v_{\\max}, &amp; |\\kappa_i| \\le \\varepsilon \\end{cases} $$ with clipping to \\([v_{\\min}, v_{\\max}]\\).</p>"},{"location":"SOLVER/#21-lateral-acceleration-capacity","title":"2.1 Lateral Acceleration Capacity","text":"<p><code>BicycleModel.lateral_accel_limit(...)</code> solves a fixed-point problem because tire force capacity depends on normal load, and normal load depends on lateral acceleration through load transfer.</p> <p>For fixed speed \\(v\\):</p> <ol> <li>Estimate axle loads from quasi-static vertical balance using current \\(a_y\\) guess.</li> <li>Compute front/rear lateral tire forces at a representative peak slip angle    (Pacejka Magic Formula).</li> <li>Update lateral limit: $$ a_{y,\\text{next}} = \\max\\left(a_{y,\\min}, \\frac{F_{y,f}+F_{y,r}}{m} + g\\sin\\beta\\right). $$</li> <li>Repeat until \\(|a_{y,\\text{next}}-a_{y,\\text{current}}|\\le\\text{tol}\\) or max iterations.</li> </ol>"},{"location":"SOLVER/#3-longitudinal-coupling-via-friction-circle","title":"3. Longitudinal Coupling via Friction Circle","text":"<p>Available longitudinal capability is reduced by lateral usage: $$ \\lambda_i = \\sqrt{\\max\\left(0, 1 - \\left(\\frac{|a_{y,\\text{req},i}|}{a_{y,\\text{lim},i}}\\right)^2\\right)}, \\quad |a_{y,\\text{req},i}| = v_i^2 |\\kappa_i|. $$</p> <ul> <li>Drive limit: \\(a_{x,\\text{drive},i} = a_{x,\\text{drive,max}}\\,\\lambda_i\\)</li> <li>Brake limit: \\(a_{x,\\text{brake},i} = a_{x,\\text{brake,max}}\\,\\lambda_i\\)</li> </ul> <p>This is a simplified isotropic friction-circle approximation.</p>"},{"location":"SOLVER/#4-forward-pass-acceleration-limited","title":"4. Forward Pass (Acceleration-Limited)","text":"<p>Starting from \\(v_0\\), propagate forward with kinematic relation: $$ v_{i+1}^2 = v_i^2 + 2 a_{x,\\text{net},i} \\Delta s_i. $$</p> <p>Net acceleration model: $$ a_{x,\\text{net},i} = a_{x,\\text{drive},i} - \\frac{D(v_i)}{m} - g\\,\\gamma_i, $$ where drag force is $$ D(v) = \\tfrac{1}{2}\\rho c_d A v^2. $$</p> <p>Then enforce bounds: $$ v_{i+1} \\leftarrow \\min(v_{i+1}, v_{\\text{lat},i+1}, v_{\\max}), \\quad v_{i+1} \\ge v_{\\min}. $$</p>"},{"location":"SOLVER/#5-backward-pass-braking-limited","title":"5. Backward Pass (Braking-Limited)","text":"<p>From the end of the lap backwards, enforce braking feasibility: $$ v_i^2 = v_{i+1}^2 + 2 a_{x,\\text{decel,avail},i} \\Delta s_i, $$ with $$ a_{x,\\text{decel,avail},i} = a_{x,\\text{brake},i} + \\frac{D(v_{i+1})}{m} + g\\,\\gamma_{i+1}. $$</p> <p>Again clamp by lateral and global speed bounds.</p>"},{"location":"SOLVER/#6-final-accelerations-and-lap-time","title":"6. Final Accelerations and Lap Time","text":"<p>After forward/backward constraints, the final profile is \\(v_i\\). Longitudinal acceleration is reconstructed by finite differences: $$ a_{x,i} = \\frac{v_{i+1}^2 - v_i^2}{2\\Delta s_i}, \\quad i=0,\\dots,N-2. $$</p> <p>Lateral acceleration: $$ a_{y,i} = v_i^2\\kappa_i. $$</p> <p>Segment time is approximated with average segment speed: $$ \\Delta t_i = \\frac{\\Delta s_i}{\\max\\left(\\tfrac{v_i+v_{i+1}}{2}, \\varepsilon_v\\right)}. $$</p> <p>Total lap time: $$ T = \\sum_{i=0}^{N-2} \\Delta t_i. $$</p>"},{"location":"SOLVER/#7-numerical-convergence-controls","title":"7. Numerical Convergence Controls","text":"<p>Lateral envelope convergence in <code>solve_speed_profile(...)</code> is configurable via <code>SimulationConfig.numerics</code>:</p> <ul> <li><code>lateral_envelope_max_iterations</code></li> <li><code>lateral_envelope_convergence_tolerance</code></li> </ul> <p>Stop criterion: $$ \\max_i |v^{(k)}{\\text{lat},i} - v^{(k-1)}{\\text{lat},i}| \\le \\text{tol}_v. $$</p> <p>The actual number of iterations used is reported as <code>SpeedProfileResult.lateral_envelope_iterations</code>.</p>"},{"location":"SOLVER/#8-physical-scope-and-limitations","title":"8. Physical Scope and Limitations","text":"<p>Current solver is intentionally quasi-steady:</p> <ul> <li>No transient tire relaxation dynamics.</li> <li>No explicit driver/controller model in the speed-profile pass.</li> <li>Longitudinal limits are envelope-based constants (drive/brake maxima).</li> <li>Tire model uses fixed representative peak slip-angle for envelope estimation.</li> </ul> <p>These simplifications keep the solver fast and stable, while preserving core constraints for lap-time studies.</p> <p>The same solver routine can be used with different backends implementing <code>VehicleModel</code>, including the bicycle and point-mass models.</p>"},{"location":"SOLVER/#9-equation-to-code-mapping","title":"9. Equation-to-Code Mapping","text":"<ul> <li>\\(a_{y,i} = v_i^2\\kappa_i\\):</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>solve_speed_profile</code>, <code>ay = ...</code>)</li> <li>\\(v_{\\text{lat},i} = \\sqrt{a_{y,\\text{lim},i}/|\\kappa_i|}\\) (with clipping):</li> <li><code>src/pylapsim/simulation/envelope.py</code> (<code>lateral_speed_limit</code>)</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>solve_speed_profile</code>, <code>v_lat[idx] = ...</code>)</li> <li>Friction-circle scaling \\(\\lambda_i\\) (vehicle-model dependent):</li> <li><code>src/pylapsim/vehicle/bicycle_model.py</code> (<code>_friction_circle_scale</code>)</li> <li>Forward pass \\(v_{i+1}^2 = v_i^2 + 2a\\Delta s\\):</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>solve_speed_profile</code>, <code>next_speed_sq = ...</code>)</li> <li>Backward pass braking feasibility:</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>solve_speed_profile</code>, <code>entry_speed_sq = ...</code>)</li> <li>Lap-time accumulation \\(T = \\sum \\Delta t_i\\):</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>lap_time += _segment_dt(...)</code>)</li> <li>Segment time model \\(\\Delta t_i = \\Delta s_i / \\bar v_i\\):</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>_segment_dt</code>)</li> <li>Lateral limit fixed-point update:</li> <li><code>src/pylapsim/vehicle/bicycle_model.py</code> (<code>lateral_accel_limit</code>)</li> <li>Lateral envelope fixed-point convergence in speed domain:</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>for iteration_idx ...</code>, <code>max_delta_speed ...</code>)</li> <li>Vehicle-model API contract consumed by the solver:</li> <li><code>src/pylapsim/simulation/model_api.py</code> (<code>VehicleModel</code>)</li> <li><code>src/pylapsim/simulation/profile.py</code> (<code>solve_speed_profile</code>, calls on <code>model</code>)</li> </ul>"},{"location":"reference/analysis/","title":"Analysis","text":""},{"location":"reference/analysis/#pylapsim.analysis","title":"analysis","text":"<p>Simulation analysis tools.</p>"},{"location":"reference/analysis/#pylapsim.analysis.KpiSummary","title":"KpiSummary  <code>dataclass</code>","text":"<p>Summary metrics for a lap simulation.</p> <p>Parameters:</p> Name Type Description Default <code>lap_time</code> <code>float</code> <p>Total lap time [s].</p> required <code>avg_lateral_accel_g</code> <code>float</code> <p>Mean absolute lateral acceleration (g).</p> required <code>max_lateral_accel_g</code> <code>float</code> <p>Peak absolute lateral acceleration (g).</p> required <code>avg_longitudinal_accel_g</code> <code>float</code> <p>Mean absolute longitudinal acceleration (g).</p> required <code>max_longitudinal_accel_g</code> <code>float</code> <p>Peak absolute longitudinal acceleration (g).</p> required <code>energy</code> <code>float</code> <p>Integrated positive traction energy [kWh].</p> required"},{"location":"reference/analysis/#pylapsim.analysis.compute_kpis","title":"compute_kpis","text":"<pre><code>compute_kpis(result: LapResult) -&gt; KpiSummary\n</code></pre> <p>Compute mandatory and energy KPIs from simulation output.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>LapResult</code> <p>Full lap simulation output arrays and integrated metrics.</p> required <p>Returns:</p> Type Description <code>KpiSummary</code> <p>Aggregated KPI summary containing lap time, acceleration metrics, and</p> <code>KpiSummary</code> <p>electrical-equivalent traction energy [kWh].</p>"},{"location":"reference/analysis/#pylapsim.analysis.export_standard_plots","title":"export_standard_plots","text":"<pre><code>export_standard_plots(result: LapResult, output_dir: str | Path) -&gt; None\n</code></pre> <p>Export all standard analysis plots in PNG and PDF format.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>LapResult</code> <p>Simulation result used as plotting input.</p> required <code>output_dir</code> <code>str | Path</code> <p>Destination directory for all generated plots.</p> required"},{"location":"reference/pylapsim/","title":"Package","text":""},{"location":"reference/pylapsim/#pylapsim","title":"pylapsim","text":"<p>Lap time simulation package.</p>"},{"location":"reference/pylapsim/#pylapsim.KpiSummary","title":"KpiSummary  <code>dataclass</code>","text":"<p>Summary metrics for a lap simulation.</p> <p>Parameters:</p> Name Type Description Default <code>lap_time</code> <code>float</code> <p>Total lap time [s].</p> required <code>avg_lateral_accel_g</code> <code>float</code> <p>Mean absolute lateral acceleration (g).</p> required <code>max_lateral_accel_g</code> <code>float</code> <p>Peak absolute lateral acceleration (g).</p> required <code>avg_longitudinal_accel_g</code> <code>float</code> <p>Mean absolute longitudinal acceleration (g).</p> required <code>max_longitudinal_accel_g</code> <code>float</code> <p>Peak absolute longitudinal acceleration (g).</p> required <code>energy</code> <code>float</code> <p>Integrated positive traction energy [kWh].</p> required"},{"location":"reference/pylapsim/#pylapsim.LapResult","title":"LapResult  <code>dataclass</code>","text":"<p>Simulation output arrays and integrated metrics.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track geometry used for the simulation.</p> required <code>speed</code> <code>ndarray</code> <p>Converged speed trace along arc length [m/s].</p> required <code>longitudinal_accel</code> <code>ndarray</code> <p>Net longitudinal acceleration trace [m/s^2].</p> required <code>lateral_accel</code> <code>ndarray</code> <p>Lateral acceleration trace [m/s^2].</p> required <code>yaw_moment</code> <code>ndarray</code> <p>Yaw moment trace from model diagnostics [N*m].</p> required <code>front_axle_load</code> <code>ndarray</code> <p>Front-axle normal load trace [N].</p> required <code>rear_axle_load</code> <code>ndarray</code> <p>Rear-axle normal load trace [N].</p> required <code>power</code> <code>ndarray</code> <p>Tractive power trace [W].</p> required <code>energy</code> <code>float</code> <p>Integrated positive tractive energy [J].</p> required <code>lap_time</code> <code>float</code> <p>Integrated lap time [s].</p> required"},{"location":"reference/pylapsim/#pylapsim.compute_kpis","title":"compute_kpis","text":"<pre><code>compute_kpis(result: LapResult) -&gt; KpiSummary\n</code></pre> <p>Compute mandatory and energy KPIs from simulation output.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>LapResult</code> <p>Full lap simulation output arrays and integrated metrics.</p> required <p>Returns:</p> Type Description <code>KpiSummary</code> <p>Aggregated KPI summary containing lap time, acceleration metrics, and</p> <code>KpiSummary</code> <p>electrical-equivalent traction energy [kWh].</p>"},{"location":"reference/pylapsim/#pylapsim.simulate_lap","title":"simulate_lap","text":"<pre><code>simulate_lap(track: TrackData, model: VehicleModel, config: SimulationConfig) -&gt; LapResult\n</code></pre> <p>Run quasi-steady lap simulation against a vehicle-model API backend.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track geometry and derived arc-length-domain quantities.</p> required <code>model</code> <code>VehicleModel</code> <p>Vehicle-model backend implementing <code>VehicleModel</code>.</p> required <code>config</code> <code>SimulationConfig</code> <p>Solver configuration containing runtime and numerical controls.</p> required <p>Returns:</p> Type Description <code>LapResult</code> <p>Full lap simulation result including profile arrays and diagnostics.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If track data is invalid.</p> <code>ConfigurationError</code> <p>If model or solver configuration is invalid.</p>"},{"location":"reference/simulation/","title":"Simulation","text":""},{"location":"reference/simulation/#pylapsim.simulation","title":"simulation","text":"<p>Simulation solvers and runners.</p>"},{"location":"reference/simulation/#pylapsim.simulation.LapResult","title":"LapResult  <code>dataclass</code>","text":"<p>Simulation output arrays and integrated metrics.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackData</code> <p>Track geometry used for the simulation.</p> required <code>speed</code> <code>ndarray</code> <p>Converged speed trace along arc length [m/s].</p> required <code>longitudinal_accel</code> <code>ndarray</code> <p>Net longitudinal acceleration trace [m/s^2].</p> required <code>lateral_accel</code> <code>ndarray</code> <p>Lateral acceleration trace [m/s^2].</p> required <code>yaw_moment</code> <code>ndarray</code> <p>Yaw moment trace from model diagnostics [N*m].</p> required <code>front_axle_load</code> <code>ndarray</code> <p>Front-axle normal load trace [N].</p> required <code>rear_axle_load</code> <code>ndarray</code> <p>Rear-axle normal load trace [N].</p> required <code>power</code> <code>ndarray</code> <p>Tractive power trace [W].</p> required <code>energy</code> <code>float</code> <p>Integrated positive tractive energy [J].</p> required <code>lap_time</code> <code>float</code> <p>Integrated lap time [s].</p> required"},{"location":"reference/simulation/#pylapsim.simulation.ModelDiagnostics","title":"ModelDiagnostics  <code>dataclass</code>","text":"<p>Per-track-point diagnostics exposed by a vehicle model.</p> <p>Parameters:</p> Name Type Description Default <code>yaw_moment</code> <code>float</code> <p>Net yaw moment at the operating point [N*m].</p> required <code>front_axle_load</code> <code>float</code> <p>Front-axle normal load [N].</p> required <code>rear_axle_load</code> <code>float</code> <p>Rear-axle normal load [N].</p> required <code>power</code> <code>float</code> <p>Instantaneous tractive power [W].</p> required"},{"location":"reference/simulation/#pylapsim.simulation.NumericsConfig","title":"NumericsConfig  <code>dataclass</code>","text":"<p>Numerical controls for the lap-time solver.</p> <p>Parameters:</p> Name Type Description Default <code>min_speed</code> <code>float</code> <p>Numerical floor for speed to avoid singular divisions [m/s].</p> <code>DEFAULT_MIN_SPEED</code> <code>lateral_envelope_max_iterations</code> <code>int</code> <p>Maximum fixed-point iterations for the lateral-speed envelope solver.</p> <code>DEFAULT_LATERAL_ENVELOPE_MAX_ITERATIONS</code> <code>lateral_envelope_convergence_tolerance</code> <code>float</code> <p>Early-stop threshold for the lateral envelope fixed-point update (<code>max |v_k - v_{k-1}|</code>) [m/s].</p> <code>DEFAULT_LATERAL_ENVELOPE_CONVERGENCE_TOLERANCE</code> <code>transient_step</code> <code>float</code> <p>Integration step for optional transient refinement [s].</p> <code>DEFAULT_TRANSIENT_STEP</code>"},{"location":"reference/simulation/#pylapsim.simulation.NumericsConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate numerical solver settings.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any solver configuration value violates its bound.</p>"},{"location":"reference/simulation/#pylapsim.simulation.RuntimeConfig","title":"RuntimeConfig  <code>dataclass</code>","text":"<p>Runtime controls that define simulation scenario boundaries.</p> <p>Parameters:</p> Name Type Description Default <code>max_speed</code> <code>float</code> <p>Hard speed cap used by the quasi-steady profile solver [m/s].</p> required <code>enable_transient_refinement</code> <code>bool</code> <p>Flag for optional second-pass transient solve.</p> <code>DEFAULT_ENABLE_TRANSIENT_REFINEMENT</code>"},{"location":"reference/simulation/#pylapsim.simulation.RuntimeConfig.validate","title":"validate","text":"<pre><code>validate(numerics: NumericsConfig) -&gt; None\n</code></pre> <p>Validate runtime controls against solver numerics.</p> <p>Parameters:</p> Name Type Description Default <code>numerics</code> <code>NumericsConfig</code> <p>Numerical parameter set used by the solver.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If runtime controls are inconsistent with solver numerics.</p>"},{"location":"reference/simulation/#pylapsim.simulation.SimulationConfig","title":"SimulationConfig  <code>dataclass</code>","text":"<p>Top-level solver config composed of runtime and numerics.</p> <p>Parameters:</p> Name Type Description Default <code>runtime</code> <code>RuntimeConfig</code> <p>Scenario and runtime controls, independent of physical car data.</p> required <code>numerics</code> <code>NumericsConfig</code> <p>Discretization and convergence controls for numerical solving.</p> required"},{"location":"reference/simulation/#pylapsim.simulation.SimulationConfig.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate combined simulation settings.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If runtime or numerical configuration values violate their bounds.</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModel","title":"VehicleModel","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol required by the quasi-steady lap-time solver.</p> <p>Any vehicle model (bicycle, point-mass, twin-track, ...) can be used by the simulation pipeline as long as it implements this interface.</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModel.diagnostics","title":"diagnostics","text":"<pre><code>diagnostics(speed: float, longitudinal_accel: float, lateral_accel: float, curvature: float) -&gt; ModelDiagnostics\n</code></pre> <p>Return diagnostic quantities used by analysis and plotting.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>longitudinal_accel</code> <code>float</code> <p>Net longitudinal acceleration along path tangent [m/s^2].</p> required <code>lateral_accel</code> <code>float</code> <p>Lateral acceleration [m/s^2].</p> required <code>curvature</code> <code>float</code> <p>Signed track curvature at the sample point [1/m].</p> required <p>Returns:</p> Type Description <code>ModelDiagnostics</code> <p>Diagnostic signals for post-processing and visualization.</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModel.lateral_accel_limit","title":"lateral_accel_limit","text":"<pre><code>lateral_accel_limit(speed: float, banking: float) -&gt; float\n</code></pre> <p>Return lateral acceleration capability at the given operating point.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed at the queried operating point [m/s].</p> required <code>banking</code> <code>float</code> <p>Track banking angle at the queried point [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum quasi-steady lateral acceleration magnitude [m/s^2].</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModel.max_longitudinal_accel","title":"max_longitudinal_accel","text":"<pre><code>max_longitudinal_accel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return net forward acceleration limit along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum net acceleration along the path tangent [m/s^2].</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModel.max_longitudinal_decel","title":"max_longitudinal_decel","text":"<pre><code>max_longitudinal_decel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return available deceleration magnitude along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum non-negative deceleration magnitude along path tangent [m/s^2].</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModel.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate model parameters and configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If model parameters violate required physical or numerical constraints.</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModelBase","title":"VehicleModelBase","text":"<p>               Bases: <code>ABC</code></p> <p>Nominal OOP base class for solver-compatible vehicle models.</p> <p>The solver continues to depend on :class:<code>VehicleModel</code> (Protocol) for structural flexibility. Concrete library backends can additionally subclass this abstract base class to make inheritance-based contracts and code sharing explicit.</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModelBase.diagnostics","title":"diagnostics  <code>abstractmethod</code>","text":"<pre><code>diagnostics(speed: float, longitudinal_accel: float, lateral_accel: float, curvature: float) -&gt; ModelDiagnostics\n</code></pre> <p>Return diagnostic quantities used by analysis and plotting.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>longitudinal_accel</code> <code>float</code> <p>Net longitudinal acceleration along path tangent [m/s^2].</p> required <code>lateral_accel</code> <code>float</code> <p>Lateral acceleration [m/s^2].</p> required <code>curvature</code> <code>float</code> <p>Signed track curvature at the sample point [1/m].</p> required <p>Returns:</p> Type Description <code>ModelDiagnostics</code> <p>Diagnostic signals for post-processing and visualization.</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModelBase.lateral_accel_limit","title":"lateral_accel_limit  <code>abstractmethod</code>","text":"<pre><code>lateral_accel_limit(speed: float, banking: float) -&gt; float\n</code></pre> <p>Return lateral acceleration capability at the given operating point.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed at the queried operating point [m/s].</p> required <code>banking</code> <code>float</code> <p>Track banking angle at the queried point [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum quasi-steady lateral acceleration magnitude [m/s^2].</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModelBase.max_longitudinal_accel","title":"max_longitudinal_accel  <code>abstractmethod</code>","text":"<pre><code>max_longitudinal_accel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return net forward acceleration limit along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum net acceleration along the path tangent [m/s^2].</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModelBase.max_longitudinal_decel","title":"max_longitudinal_decel  <code>abstractmethod</code>","text":"<pre><code>max_longitudinal_decel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Return available deceleration magnitude along the path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Maximum non-negative deceleration magnitude along path tangent [m/s^2].</p>"},{"location":"reference/simulation/#pylapsim.simulation.VehicleModelBase.validate","title":"validate  <code>abstractmethod</code>","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate model parameters and configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If model parameters violate required physical or numerical constraints.</p>"},{"location":"reference/simulation/#pylapsim.simulation.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Resolve lazily imported symbols for public package exports.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name requested from the package namespace.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Exported class or function matching <code>name</code>.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>name</code> is not part of the public export surface.</p>"},{"location":"reference/simulation/#pylapsim.simulation.build_simulation_config","title":"build_simulation_config","text":"<pre><code>build_simulation_config(max_speed: float = DEFAULT_MAX_SPEED, numerics: NumericsConfig | None = None, enable_transient_refinement: bool = DEFAULT_ENABLE_TRANSIENT_REFINEMENT) -&gt; SimulationConfig\n</code></pre> <p>Build a validated simulation config with sensible numerical defaults.</p> <p>Parameters:</p> Name Type Description Default <code>max_speed</code> <code>float</code> <p>Runtime speed cap for the quasi-steady profile solver [m/s].</p> <code>DEFAULT_MAX_SPEED</code> <code>numerics</code> <code>NumericsConfig | None</code> <p>Optional numerical settings. Defaults to :class:<code>NumericsConfig</code>.</p> <code>None</code> <code>enable_transient_refinement</code> <code>bool</code> <p>Flag for optional transient post-processing.</p> <code>DEFAULT_ENABLE_TRANSIENT_REFINEMENT</code> <p>Returns:</p> Type Description <code>SimulationConfig</code> <p>Fully validated simulation configuration.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If assembled runtime or numerical settings are inconsistent.</p>"},{"location":"reference/tire/","title":"Tire","text":""},{"location":"reference/tire/#pylapsim.tire","title":"tire","text":"<p>Tire models and utilities.</p>"},{"location":"reference/tire/#pylapsim.tire.AxleTireParameters","title":"AxleTireParameters  <code>dataclass</code>","text":"<p>Separate tire coefficients for front and rear axle.</p> <p>Parameters:</p> Name Type Description Default <code>front</code> <code>PacejkaParameters</code> <p>Front-axle Pacejka coefficients.</p> required <code>rear</code> <code>PacejkaParameters</code> <p>Rear-axle Pacejka coefficients.</p> required"},{"location":"reference/tire/#pylapsim.tire.AxleTireParameters.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate both axle parameter sets.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If front or rear coefficient sets are invalid.</p>"},{"location":"reference/tire/#pylapsim.tire.PacejkaParameters","title":"PacejkaParameters  <code>dataclass</code>","text":"<p>Pacejka lateral model coefficients and load-sensitivity behavior.</p> <p>The lateral force model uses coefficients <code>B, C, D, E</code> in a Magic Formula style equation. <code>D</code> is treated as an effective friction coefficient at the current reference condition.</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>float</code> <p>Pacejka stiffness factor (-).</p> required <code>C</code> <code>float</code> <p>Pacejka shape factor (-).</p> required <code>D</code> <code>float</code> <p>Peak friction-like factor at reference load (-).</p> required <code>E</code> <code>float</code> <p>Pacejka curvature factor (-).</p> required <code>reference_load</code> <code>float</code> <p>Reference normal load used by load sensitivity [N].</p> required <code>load_sensitivity</code> <code>float</code> <p>Linear scaling of effective friction with load deviation from reference (-/N).</p> required <code>min_mu_scale</code> <code>float</code> <p>Lower bound for load-scaled friction multiplier (-).</p> required"},{"location":"reference/tire/#pylapsim.tire.PacejkaParameters.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate physical and numerical constraints for coefficients.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any coefficient violates required bounds.</p>"},{"location":"reference/tire/#pylapsim.tire.axle_lateral_forces","title":"axle_lateral_forces","text":"<pre><code>axle_lateral_forces(front_slip_angle: float, rear_slip_angle: float, front_axle_load: float, rear_axle_load: float, axle_params: AxleTireParameters) -&gt; tuple[float, float]\n</code></pre> <p>Compute total front/rear axle lateral force for bicycle-equivalent tires.</p> <p>Parameters:</p> Name Type Description Default <code>front_slip_angle</code> <code>float</code> <p>Front axle equivalent slip angle [rad].</p> required <code>rear_slip_angle</code> <code>float</code> <p>Rear axle equivalent slip angle [rad].</p> required <code>front_axle_load</code> <code>float</code> <p>Total front axle normal load [N].</p> required <code>rear_axle_load</code> <code>float</code> <p>Total rear axle normal load [N].</p> required <code>axle_params</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka parameter sets.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple <code>(Fy_front, Fy_rear)</code> with axle lateral forces [N].</p>"},{"location":"reference/tire/#pylapsim.tire.default_axle_tire_parameters","title":"default_axle_tire_parameters","text":"<pre><code>default_axle_tire_parameters() -&gt; AxleTireParameters\n</code></pre> <p>Create a default high-downforce race-car tire parameterization.</p> <p>Returns:</p> Type Description <code>AxleTireParameters</code> <p>Front and rear Pacejka parameter sets tuned for a high-downforce car.</p>"},{"location":"reference/tire/#pylapsim.tire.magic_formula_lateral","title":"magic_formula_lateral","text":"<pre><code>magic_formula_lateral(slip_angle: float | FloatArray, normal_load: float | FloatArray, params: PacejkaParameters) -&gt; float | FloatArray\n</code></pre> <p>Evaluate lateral tire force with load-sensitive Pacejka coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>slip_angle</code> <code>float | FloatArray</code> <p>Tire slip angle [rad].</p> required <code>normal_load</code> <code>float | FloatArray</code> <p>Tire normal load [N].</p> required <code>params</code> <code>PacejkaParameters</code> <p>Pacejka coefficient set.</p> required <p>Returns:</p> Type Description <code>float | FloatArray</code> <p>Lateral force [N]. Sign follows slip-angle sign.</p>"},{"location":"reference/track/","title":"Track","text":""},{"location":"reference/track/#pylapsim.track","title":"track","text":"<p>Track loading, synthetic layout generation, and geometry processing.</p>"},{"location":"reference/track/#pylapsim.track.TrackData","title":"TrackData  <code>dataclass</code>","text":"<p>Processed track representation in arc-length domain.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Global x-coordinate samples along the centerline [m].</p> required <code>y</code> <code>ndarray</code> <p>Global y-coordinate samples along the centerline [m].</p> required <code>elevation</code> <code>ndarray</code> <p>Elevation samples along the centerline [m].</p> required <code>banking</code> <code>ndarray</code> <p>Banking angle samples [rad].</p> required <code>arc_length</code> <code>ndarray</code> <p>Monotonic arc-length coordinate [m].</p> required <code>heading</code> <code>ndarray</code> <p>Centerline heading angle [rad].</p> required <code>curvature</code> <code>ndarray</code> <p>Signed curvature along arc length [1/m].</p> required <code>grade</code> <code>ndarray</code> <p>Longitudinal grade <code>dz/ds</code> (-).</p> required"},{"location":"reference/track/#pylapsim.track.TrackData.length","title":"length  <code>property</code>","text":"<pre><code>length: float\n</code></pre> <p>Track length [m].</p> <p>Returns:</p> Type Description <code>float</code> <p>Final arc-length value of the discretized track [m].</p>"},{"location":"reference/track/#pylapsim.track.TrackData.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate consistency of all track arrays.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If array lengths, arc length monotonicity, or numeric validity checks fail.</p>"},{"location":"reference/track/#pylapsim.track.build_circular_track","title":"build_circular_track","text":"<pre><code>build_circular_track(radius: float = DEFAULT_CIRCLE_RADIUS, sample_count: int = DEFAULT_CIRCLE_SAMPLE_COUNT, clockwise: bool = False, elevation: float = 0.0, banking: float = 0.0) -&gt; TrackData\n</code></pre> <p>Build a circular closed-loop track with approximately constant curvature.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Circle radius [m].</p> <code>DEFAULT_CIRCLE_RADIUS</code> <code>sample_count</code> <code>int</code> <p>Number of unique samples around the circle.</p> <code>DEFAULT_CIRCLE_SAMPLE_COUNT</code> <code>clockwise</code> <code>bool</code> <p>Whether to traverse the circle clockwise.</p> <code>False</code> <code>elevation</code> <code>float</code> <p>Constant elevation value along the track [m].</p> <code>0.0</code> <code>banking</code> <code>float</code> <p>Constant banking angle along the track [rad].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrackData</code> <p>Validated circular <code>TrackData</code> representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If geometric input values are outside valid bounds.</p>"},{"location":"reference/track/#pylapsim.track.build_figure_eight_track","title":"build_figure_eight_track","text":"<pre><code>build_figure_eight_track(lobe_radius: float = DEFAULT_FIGURE_EIGHT_RADIUS, sample_count: int = DEFAULT_FIGURE_EIGHT_SAMPLE_COUNT, elevation: float = 0.0, banking: float = 0.0) -&gt; TrackData\n</code></pre> <p>Build a closed figure-eight track using a Gerono lemniscate centerline.</p> <p>Parameters:</p> Name Type Description Default <code>lobe_radius</code> <code>float</code> <p>Characteristic lobe radius scaling the layout [m].</p> <code>DEFAULT_FIGURE_EIGHT_RADIUS</code> <code>sample_count</code> <code>int</code> <p>Number of unique samples along the centerline.</p> <code>DEFAULT_FIGURE_EIGHT_SAMPLE_COUNT</code> <code>elevation</code> <code>float</code> <p>Constant elevation value along the track [m].</p> <code>0.0</code> <code>banking</code> <code>float</code> <p>Constant banking angle along the track [rad].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrackData</code> <p>Validated figure-eight <code>TrackData</code> representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If geometric input values are outside valid bounds.</p>"},{"location":"reference/track/#pylapsim.track.build_straight_track","title":"build_straight_track","text":"<pre><code>build_straight_track(length: float = DEFAULT_STRAIGHT_LENGTH, sample_count: int = DEFAULT_STRAIGHT_SAMPLE_COUNT, elevation: float = 0.0, banking: float = 0.0) -&gt; TrackData\n</code></pre> <p>Build a straight track centerline with constant elevation and banking.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>Total straight-line track length [m].</p> <code>DEFAULT_STRAIGHT_LENGTH</code> <code>sample_count</code> <code>int</code> <p>Number of centerline samples.</p> <code>DEFAULT_STRAIGHT_SAMPLE_COUNT</code> <code>elevation</code> <code>float</code> <p>Constant elevation value along the track [m].</p> <code>0.0</code> <code>banking</code> <code>float</code> <p>Constant banking angle along the track [rad].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>TrackData</code> <p>Validated straight <code>TrackData</code> representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If geometric input values are outside valid bounds.</p>"},{"location":"reference/track/#pylapsim.track.load_track_csv","title":"load_track_csv","text":"<pre><code>load_track_csv(path: str | Path) -&gt; TrackData\n</code></pre> <p>Load a track CSV into <code>TrackData</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to a CSV containing <code>x</code>, <code>y</code>, <code>elevation</code>, and <code>banking</code>.</p> required <p>Returns:</p> Type Description <code>TrackData</code> <p>Parsed and validated track representation.</p> <p>Raises:</p> Type Description <code>TrackDataError</code> <p>If the file does not exist, has an invalid schema, or contains too few rows.</p>"},{"location":"reference/vehicle/","title":"Vehicle","text":""},{"location":"reference/vehicle/#pylapsim.vehicle","title":"vehicle","text":"<p>Vehicle models and parameters.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel","title":"BicycleDynamicsModel","text":"<p>3-DOF bicycle dynamics model using lateral Pacejka tire forces.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel.__init__","title":"__init__","text":"<pre><code>__init__(vehicle: VehicleParameters, tires: AxleTireParameters) -&gt; None\n</code></pre> <p>Initialize the bicycle model with validated parameters.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle and chassis parameterization.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka parameter sets.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If vehicle or tire parameters are invalid.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel.derivatives","title":"derivatives","text":"<pre><code>derivatives(state: VehicleState, control: ControlInput) -&gt; VehicleState\n</code></pre> <p>Compute time derivatives for state integration.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state <code>(vx, vy, yaw_rate)</code>.</p> required <code>control</code> <code>ControlInput</code> <p>Steering and longitudinal acceleration command.</p> required <p>Returns:</p> Type Description <code>VehicleState</code> <p>Time derivatives <code>(dvx/dt, dvy/dt, dr/dt)</code> in SI units.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel.force_balance","title":"force_balance","text":"<pre><code>force_balance(state: VehicleState, control: ControlInput) -&gt; ForceBalance\n</code></pre> <p>Evaluate lateral forces and yaw moment for the current state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state <code>(vx, vy, yaw_rate)</code>.</p> required <code>control</code> <code>ControlInput</code> <p>Steering and longitudinal acceleration command.</p> required <p>Returns:</p> Type Description <code>ForceBalance</code> <p>Force-balance terms including slip angles, tire forces, and yaw moment.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel.from_array","title":"from_array  <code>staticmethod</code>","text":"<pre><code>from_array(values: ndarray) -&gt; VehicleState\n</code></pre> <p>Convert ndarray to state dataclass.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>State vector with at least three elements.</p> required <p>Returns:</p> Type Description <code>VehicleState</code> <p>Parsed vehicle state dataclass.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel.sanitize_speed","title":"sanitize_speed  <code>staticmethod</code>","text":"<pre><code>sanitize_speed(speed: float) -&gt; float\n</code></pre> <p>Apply a numerical lower bound to speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Raw speed [m/s].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Speed clamped to a positive lower bound for numerical stability.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel.slip_angles","title":"slip_angles","text":"<pre><code>slip_angles(state: VehicleState, steer: float) -&gt; tuple[float, float]\n</code></pre> <p>Compute front and rear axle slip angles.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state <code>(vx, vy, yaw_rate)</code>.</p> required <code>steer</code> <code>float</code> <p>Front-wheel steering angle [rad].</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple <code>(front_slip_angle, rear_slip_angle)</code>.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleDynamicsModel.to_array","title":"to_array  <code>staticmethod</code>","text":"<pre><code>to_array(state: VehicleState) -&gt; np.ndarray\n</code></pre> <p>Convert state dataclass to ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>VehicleState</code> <p>Vehicle state dataclass.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector <code>[vx, vy, yaw_rate]</code>.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleModel","title":"BicycleModel","text":"<p>               Bases: <code>EnvelopeVehicleModel</code></p> <p>Vehicle-model API implementation for the bicycle dynamics backend.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleModel.__init__","title":"__init__","text":"<pre><code>__init__(vehicle: VehicleParameters, tires: AxleTireParameters, physics: BicyclePhysics, numerics: BicycleNumerics) -&gt; None\n</code></pre> <p>Initialize bicycle-backed solver adapter.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for dynamics and aero.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka tire coefficients.</p> required <code>physics</code> <code>BicyclePhysics</code> <p>Physical model inputs for the adapter.</p> required <code>numerics</code> <code>BicycleNumerics</code> <p>Numerical controls for iterative envelope solving.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any provided parameter set is invalid.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleModel.diagnostics","title":"diagnostics","text":"<pre><code>diagnostics(speed: float, longitudinal_accel: float, lateral_accel: float, curvature: float) -&gt; ModelDiagnostics\n</code></pre> <p>Evaluate yaw moment, axle loads, and power for analysis outputs.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>longitudinal_accel</code> <code>float</code> <p>Net longitudinal acceleration [m/s^2].</p> required <code>lateral_accel</code> <code>float</code> <p>Lateral acceleration [m/s^2].</p> required <code>curvature</code> <code>float</code> <p>Path curvature [1/m].</p> required <p>Returns:</p> Type Description <code>ModelDiagnostics</code> <p>Diagnostic values for plotting and KPI post-processing.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleModel.lateral_accel_limit","title":"lateral_accel_limit","text":"<pre><code>lateral_accel_limit(speed: float, banking: float) -&gt; float\n</code></pre> <p>Estimate lateral acceleration capacity for the operating point.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Quasi-steady lateral acceleration limit [m/s^2].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleModel.max_longitudinal_accel","title":"max_longitudinal_accel","text":"<pre><code>max_longitudinal_accel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Compute net forward acceleration limit along path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Net forward acceleration along path tangent [m/s^2].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleModel.max_longitudinal_decel","title":"max_longitudinal_decel","text":"<pre><code>max_longitudinal_decel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Compute available deceleration magnitude along path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Non-negative deceleration magnitude along path tangent [m/s^2].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleNumerics","title":"BicycleNumerics  <code>dataclass</code>","text":"<p>Numerical controls for the bicycle solver model.</p> <p>Parameters:</p> Name Type Description Default <code>min_lateral_accel_limit</code> <code>float</code> <p>Lower bound for lateral-acceleration iteration to avoid degenerate starts [m/s^2].</p> <code>DEFAULT_MIN_LATERAL_ACCEL_LIMIT</code> <code>lateral_limit_max_iterations</code> <code>int</code> <p>Maximum fixed-point iterations for lateral acceleration limit estimation.</p> <code>DEFAULT_LATERAL_LIMIT_MAX_ITERATIONS</code> <code>lateral_limit_convergence_tolerance</code> <code>float</code> <p>Convergence threshold for lateral acceleration fixed-point updates [m/s^2].</p> <code>DEFAULT_LATERAL_LIMIT_CONVERGENCE_TOLERANCE</code>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicycleNumerics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate numerical settings for the adapter.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If numerical values violate bounds needed for robust convergence.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicyclePhysics","title":"BicyclePhysics  <code>dataclass</code>","text":"<p>Physical and model-level inputs for the bicycle solver model.</p> <p>Parameters:</p> Name Type Description Default <code>max_drive_accel</code> <code>float</code> <p>Maximum forward tire acceleration on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>8.0</code> <code>max_brake_accel</code> <code>float</code> <p>Maximum braking deceleration magnitude on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>16.0</code> <code>peak_slip_angle</code> <code>float</code> <p>Quasi-steady peak slip angle used to evaluate tire lateral force capability in the envelope iteration [rad].</p> <code>0.12</code>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicyclePhysics.bicycle_lateral","title":"bicycle_lateral  <code>property</code>","text":"<pre><code>bicycle_lateral: _BicycleLateralPhysics\n</code></pre> <p>Return bicycle-specific lateral approximation inputs.</p> <p>Returns:</p> Type Description <code>_BicycleLateralPhysics</code> <p>Internal bicycle-specific lateral-envelope representation.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicyclePhysics.envelope","title":"envelope  <code>property</code>","text":"<pre><code>envelope: EnvelopePhysics\n</code></pre> <p>Return shared longitudinal envelope limits.</p> <p>Returns:</p> Type Description <code>EnvelopePhysics</code> <p>Internal shared envelope-limit representation used by multiple</p> <code>EnvelopePhysics</code> <p>solver model families.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.BicyclePhysics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate physical adapter parameters.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If limits are not strictly positive.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.ControlInput","title":"ControlInput  <code>dataclass</code>","text":"<p>Control inputs for the bicycle model.</p> <p>Parameters:</p> Name Type Description Default <code>steer</code> <code>float</code> <p>Front-wheel steering angle [rad].</p> required <code>longitudinal_accel_cmd</code> <code>float</code> <p>Commanded longitudinal acceleration [m/s^2].</p> required"},{"location":"reference/vehicle/#pylapsim.vehicle.ForceBalance","title":"ForceBalance  <code>dataclass</code>","text":"<p>Force-balance quantities used for analysis and integration.</p> <p>Parameters:</p> Name Type Description Default <code>front_slip_angle</code> <code>float</code> <p>Front equivalent slip angle [rad].</p> required <code>rear_slip_angle</code> <code>float</code> <p>Rear equivalent slip angle [rad].</p> required <code>front_lateral_force</code> <code>float</code> <p>Front-axle lateral tire force [N].</p> required <code>rear_lateral_force</code> <code>float</code> <p>Rear-axle lateral tire force [N].</p> required <code>yaw_moment</code> <code>float</code> <p>Net yaw moment about center of gravity [N*m].</p> required"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassCalibrationResult","title":"PointMassCalibrationResult  <code>dataclass</code>","text":"<p>Calibration outputs for matching point-mass lateral limits to bicycle behavior.</p> <p>Parameters:</p> Name Type Description Default <code>friction_coefficient</code> <code>float</code> <p>Identified isotropic friction coefficient (-).</p> required <code>speed_samples</code> <code>ndarray</code> <p>Calibration speed samples used by the identification [m/s].</p> required <code>bicycle_lateral_limit</code> <code>ndarray</code> <p>Bicycle-model lateral limit evaluated at <code>speed_samples</code> [m/s^2].</p> required <code>normal_accel_limit</code> <code>ndarray</code> <p>Point-mass normal acceleration budget evaluated at <code>speed_samples</code> [m/s^2].</p> required <code>mu_samples</code> <code>ndarray</code> <p>Per-sample effective friction ratios computed as <code>bicycle_lateral_limit / normal_accel_limit</code> (-).</p> required"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassModel","title":"PointMassModel","text":"<p>               Bases: <code>EnvelopeVehicleModel</code></p> <p>Vehicle-model API implementation for a point-mass backend.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassModel.__init__","title":"__init__","text":"<pre><code>__init__(vehicle: VehicleParameters, physics: PointMassPhysics) -&gt; None\n</code></pre> <p>Initialize point-mass solver backend.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for mass, aero, and axle split.</p> required <code>physics</code> <code>PointMassPhysics</code> <p>Point-mass physical model settings.</p> required <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any provided parameter set is invalid.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassModel.diagnostics","title":"diagnostics","text":"<pre><code>diagnostics(speed: float, longitudinal_accel: float, lateral_accel: float, curvature: float) -&gt; ModelDiagnostics\n</code></pre> <p>Evaluate point-mass diagnostics for analysis outputs.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>longitudinal_accel</code> <code>float</code> <p>Net longitudinal acceleration [m/s^2].</p> required <code>lateral_accel</code> <code>float</code> <p>Lateral acceleration [m/s^2].</p> required <code>curvature</code> <code>float</code> <p>Path curvature [1/m].</p> required <p>Returns:</p> Type Description <code>ModelDiagnostics</code> <p>Diagnostic values for plotting and KPI post-processing.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassModel.lateral_accel_limit","title":"lateral_accel_limit","text":"<pre><code>lateral_accel_limit(speed: float, banking: float) -&gt; float\n</code></pre> <p>Estimate lateral acceleration capacity for the operating point.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Quasi-steady lateral acceleration limit [m/s^2].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassModel.max_longitudinal_accel","title":"max_longitudinal_accel","text":"<pre><code>max_longitudinal_accel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Compute net forward acceleration limit along path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Net forward acceleration along path tangent [m/s^2].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassModel.max_longitudinal_decel","title":"max_longitudinal_decel","text":"<pre><code>max_longitudinal_decel(speed: float, lateral_accel_required: float, grade: float, banking: float) -&gt; float\n</code></pre> <p>Compute available deceleration magnitude along path tangent.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Vehicle speed [m/s].</p> required <code>lateral_accel_required</code> <code>float</code> <p>Required lateral acceleration magnitude [m/s^2].</p> required <code>grade</code> <code>float</code> <p>Track grade defined as <code>dz/ds</code>.</p> required <code>banking</code> <code>float</code> <p>Track banking angle [rad].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Non-negative deceleration magnitude along path tangent [m/s^2].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassPhysics","title":"PointMassPhysics  <code>dataclass</code>","text":"<p>Physical inputs for the point-mass lap-time model.</p> <p>Parameters:</p> Name Type Description Default <code>max_drive_accel</code> <code>float</code> <p>Maximum forward tire acceleration on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>8.0</code> <code>max_brake_accel</code> <code>float</code> <p>Maximum braking deceleration magnitude on flat road and zero lateral demand, excluding drag and grade [m/s^2].</p> <code>16.0</code> <code>friction_coefficient</code> <code>float</code> <p>Isotropic tire-road friction coefficient used for lateral limit and friction-circle coupling (-).</p> <code>1.7</code>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassPhysics.envelope","title":"envelope  <code>property</code>","text":"<pre><code>envelope: EnvelopePhysics\n</code></pre> <p>Return shared longitudinal envelope limits.</p> <p>Returns:</p> Type Description <code>EnvelopePhysics</code> <p>Internal shared envelope-limit representation used by multiple</p> <code>EnvelopePhysics</code> <p>solver model families.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.PointMassPhysics.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate physical model parameters.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If limits or friction settings violate required bounds.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.VehicleParameters","title":"VehicleParameters  <code>dataclass</code>","text":"<p>Vehicle and chassis parameters for lap-time simulation.</p> <p>Parameters:</p> Name Type Description Default <code>mass</code> <code>float</code> <p>Vehicle mass [kg].</p> required <code>yaw_inertia</code> <code>float</code> <p>Yaw moment of inertia [kg*m^2].</p> required <code>cg_height</code> <code>float</code> <p>Center-of-gravity height above ground [m].</p> required <code>wheelbase</code> <code>float</code> <p>Wheelbase [m].</p> required <code>front_track</code> <code>float</code> <p>Front track width [m].</p> required <code>rear_track</code> <code>float</code> <p>Rear track width [m].</p> required <code>front_weight_fraction</code> <code>float</code> <p>Static front axle weight fraction in [0, 1].</p> required <code>cop_position</code> <code>float</code> <p>Center-of-pressure position relative to CoG [m].</p> required <code>lift_coefficient</code> <code>float</code> <p>Aerodynamic lift/downforce coefficient.</p> required <code>drag_coefficient</code> <code>float</code> <p>Aerodynamic drag coefficient.</p> required <code>frontal_area</code> <code>float</code> <p>Frontal reference area [m^2].</p> required <code>roll_rate</code> <code>float</code> <p>Roll rate [N*m/deg].</p> required <code>front_spring_rate</code> <code>float</code> <p>Front spring rate [N/m].</p> required <code>rear_spring_rate</code> <code>float</code> <p>Rear spring rate [N/m].</p> required <code>front_arb_distribution</code> <code>float</code> <p>Front anti-roll-bar distribution in [0, 1].</p> required <code>front_ride_height</code> <code>float</code> <p>Front ride height [m].</p> required <code>rear_ride_height</code> <code>float</code> <p>Rear ride height [m].</p> required <code>air_density</code> <code>float</code> <p>Air density [kg/m^3].</p> required"},{"location":"reference/vehicle/#pylapsim.vehicle.VehicleParameters.cg_to_front_axle","title":"cg_to_front_axle  <code>property</code>","text":"<pre><code>cg_to_front_axle: float\n</code></pre> <p>Distance from center of gravity to front axle.</p> <p>Returns:</p> Type Description <code>float</code> <p>Front axle distance from center of gravity [m].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.VehicleParameters.cg_to_rear_axle","title":"cg_to_rear_axle  <code>property</code>","text":"<pre><code>cg_to_rear_axle: float\n</code></pre> <p>Distance from center of gravity to rear axle.</p> <p>Returns:</p> Type Description <code>float</code> <p>Rear axle distance from center of gravity [m].</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.VehicleParameters.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validate configuration values before simulation.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If any parameter violates its defined bound.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.VehicleState","title":"VehicleState  <code>dataclass</code>","text":"<p>Vehicle state for the bicycle model.</p> <p>Parameters:</p> Name Type Description Default <code>vx</code> <code>float</code> <p>Longitudinal velocity in body frame [m/s].</p> required <code>vy</code> <code>float</code> <p>Lateral velocity in body frame [m/s].</p> required <code>yaw_rate</code> <code>float</code> <p>Yaw rate [rad/s].</p> required"},{"location":"reference/vehicle/#pylapsim.vehicle.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Resolve lazily imported symbols for public package exports.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name requested from the package namespace.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Exported class or function matching <code>name</code>.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>name</code> is not part of the public export surface.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.build_bicycle_model","title":"build_bicycle_model","text":"<pre><code>build_bicycle_model(vehicle: VehicleParameters, tires: AxleTireParameters, physics: BicyclePhysics | None = None, numerics: BicycleNumerics | None = None) -&gt; BicycleModel\n</code></pre> <p>Build a bicycle solver model with sensible numerical defaults.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for dynamics and aero.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Front/rear Pacejka tire coefficients.</p> required <code>physics</code> <code>BicyclePhysics | None</code> <p>Optional physical model inputs for longitudinal and lateral limits. Defaults to :class:<code>BicyclePhysics</code>.</p> <code>None</code> <code>numerics</code> <code>BicycleNumerics | None</code> <p>Optional numerical controls. Defaults to :class:<code>BicycleNumerics</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>BicycleModel</code> <p>Fully validated solver-facing bicycle model.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.build_point_mass_model","title":"build_point_mass_model","text":"<pre><code>build_point_mass_model(vehicle: VehicleParameters, physics: PointMassPhysics | None = None) -&gt; PointMassModel\n</code></pre> <p>Build a point-mass solver model with sensible defaults.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization for mass, aero, and axle split.</p> required <code>physics</code> <code>PointMassPhysics | None</code> <p>Optional physical model settings. Defaults to :class:<code>PointMassPhysics</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointMassModel</code> <p>Fully validated solver-facing point-mass model.</p>"},{"location":"reference/vehicle/#pylapsim.vehicle.calibrate_point_mass_friction_to_bicycle","title":"calibrate_point_mass_friction_to_bicycle","text":"<pre><code>calibrate_point_mass_friction_to_bicycle(vehicle: VehicleParameters, tires: AxleTireParameters, bicycle_physics: BicyclePhysics | None = None, bicycle_numerics: BicycleNumerics | None = None, speed_samples: ndarray | None = None) -&gt; PointMassCalibrationResult\n</code></pre> <p>Calibrate point-mass friction coefficient to bicycle lateral capability.</p> <p>The calibration matches the point-mass isotropic lateral limit <code>mu * (g + F_down(v)/m)</code> to the bicycle model's quasi-steady lateral limit in a least-squares sense over provided speed samples.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>VehicleParameters</code> <p>Vehicle parameterization shared by both models.</p> required <code>tires</code> <code>AxleTireParameters</code> <p>Tire parameters used by the bicycle model.</p> required <code>bicycle_physics</code> <code>BicyclePhysics | None</code> <p>Optional bicycle-physics settings for calibration. Defaults to :class:<code>pylapsim.vehicle.BicyclePhysics</code>.</p> <code>None</code> <code>bicycle_numerics</code> <code>BicycleNumerics | None</code> <p>Optional bicycle numerical settings for calibration. Defaults to :class:<code>pylapsim.vehicle.BicycleNumerics</code>.</p> <code>None</code> <code>speed_samples</code> <code>ndarray | None</code> <p>Optional calibration speeds [m/s]. If omitted, a linear sweep from 10 to 90 m/s is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointMassCalibrationResult</code> <p>Calibration result with identified friction coefficient and</p> <code>PointMassCalibrationResult</code> <p>intermediate traces.</p> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If provided speed samples are empty or contain non-positive entries.</p>"}]}